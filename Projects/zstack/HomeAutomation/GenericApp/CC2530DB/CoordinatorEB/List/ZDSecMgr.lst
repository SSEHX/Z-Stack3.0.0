###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                26/Oct/2017  13:55:08
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack 3.0.0\Components\stack\zdo\ZDSecMgr.c
#    Command line       =  
#        -f "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        "C:\Texas Instruments\Z-Stack 3.0.0\Components\stack\zdo\ZDSecMgr.c"
#        -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D xZTOOL_P1
#        -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D LEGACY_LCD_DEBUG -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_SCENES -D ZCL_GROUPS -lC
#        "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\List"
#        -lA "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I "C:\Texas
#        Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\" -I
#        "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes
#    List file          =  
#        C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\List\ZDSecMgr.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\Obj\ZDSecMgr.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack 3.0.0\Components\stack\zdo\ZDSecMgr.c
      1          /******************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2014-06-05 11:25:00 -0700 (Thu, 05 Jun 2014) $
      4            Revision:       $Revision: 38833 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ******************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComDef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Nv.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "ZDConfig.h"
     60          #include "ZDSecMgr.h"
     61            
     62          #include "bdb.h"
     63          #include "bdb_interface.h"
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // maximum number of LINK keys this device may store
     74          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     75          
     76          // total number of stored devices
     77          #if !defined ( ZDSECMGR_STORED_DEVICES )
     78            #define ZDSECMGR_STORED_DEVICES 3
     79          #endif
     80          
     81          // Joining Device Policies: r21 spec 4.9.1
     82          // This boolean indicates whether the device will request a new Trust Center Link key after joining.
     83          // TC link key cannot be requested if join is performed on distributed nwk

   \                                 In  segment XDATA_I, align 1, keep-with-next
     84          bool  requestNewTrustCenterLinkKey = TRUE;  
   \                     requestNewTrustCenterLinkKey:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for requestNewTrustCenterLinkKey`
   \   000001                REQUIRE __INIT_XDATA_I
     85          //This integer indicates the maximum time in seconds that a device will wait for a response to a 
     86          //request for a Trust Center link key.

   \                                 In  segment XDATA_I, align 1, keep-with-next
     87          uint32  requestLinkKeyTimeout = BDBC_TC_LINK_KEY_EXANGE_TIMEOUT;
   \                     requestLinkKeyTimeout:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for requestLinkKeyTimeout>`
   \   000004                REQUIRE __INIT_XDATA_I
     88           //bool acceptNewUnsolicitedApplicationLinkKey;   
     89          
     90          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     91            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     92          #endif
     93          
     94          // APSME Stub Implementations
     95          #define ZDSecMgrLinkKeySet       APSME_LinkKeySet
     96          #define ZDSecMgrLinkKeyNVIdGet   APSME_LinkKeyNVIdGet
     97          #define ZDSecMgrKeyFwdToChild    APSME_KeyFwdToChild
     98          #define ZDSecMgrIsLinkKeyValid   APSME_IsLinkKeyValid
     99          
    100          
    101          #define TCLK_DEV_ENTRY_MAX_SEED_SHIFTS     15
    102          /******************************************************************************
    103           * TYPEDEFS
    104           */
    105          typedef struct
    106          {
    107            uint16            ami;
    108            uint16            keyNvId;   // index to the Link Key table in NV
    109            ZDSecMgr_Authentication_Option authenticateOption;
    110          } ZDSecMgrEntry_t;
    111          
    112          typedef struct
    113          {
    114            uint16          nwkAddr;
    115            uint8*          extAddr;
    116            uint16          parentAddr;
    117            uint8           secure;
    118            uint8           devStatus;
    119          } ZDSecMgrDevice_t;
    120          
    121          /******************************************************************************
    122           * EXTERNAL VARIABLES
    123           */
    124          extern CONST uint8 gMAX_NWK_SEC_MATERIAL_TABLE_ENTRIES;
    125          extern pfnZdoCb zdoCBFunc[MAX_ZDO_CB_FUNC];
    126          
    127          
    128          /******************************************************************************
    129           * EXTERNAL FUNCTIONS
    130           */
    131          extern void   ZDApp_ResetTimerCancel( void );
    132          /******************************************************************************
    133           * LOCAL VARIABLES
    134           */
    135          #if 0 // Taken out because the following functionality is only used for test
    136                // purpose. A more efficient (above) way is used. It can be put
    137                // back in if customers request for a white/black list feature.
    138          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    139          {
    140            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    141            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    142            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    143          };
    144          #endif
    145          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    146          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    147            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    148          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    149          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    150          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    151          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    152          
    153          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    154          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    155          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    156          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    157          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    158          APSME_TCLKDevEntry_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 19
   \   000013                REQUIRE __INIT_XDATA_Z
    159          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    160          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    161          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 360
   \   000168                REQUIRE __INIT_XDATA_Z
    162          

   \                                 In  segment CODE_C, align 1
    163           CONST uint8 gZDSECMGR_TC_DEVICE_MAX = ZDSECMGR_TC_DEVICE_MAX;
   \                     gZDSECMGR_TC_DEVICE_MAX:
   \   000000   28           DB 40

   \                                 In  segment CODE_C, align 1
    164           CONST uint8 gZDSECMGR_TC_DEVICE_IC_MAX = ZDSECMGR_TC_DEVICE_IC_MAX;
   \                     gZDSECMGR_TC_DEVICE_IC_MAX:
   \   000000   0C           DB 12
    165          /******************************************************************************
    166           * PRIVATE FUNCTIONS
    167           *
    168           *   ZDSecMgrAddrStore
    169           *   ZDSecMgrExtAddrStore
    170           *   ZDSecMgrExtAddrLookup
    171           *   ZDSecMgrEntryInit
    172           *   ZDSecMgrEntryLookup
    173           *   ZDSecMgrEntryLookupAMI
    174           *   ZDSecMgrEntryLookupExt
    175           *   ZDSecMgrEntryLookupExtGetIndex
    176           *   ZDSecMgrEntryFree
    177           *   ZDSecMgrEntryNew
    178           *   ZDSecMgrAppKeyGet
    179           *   ZDSecMgrAppKeyReq
    180           *   ZDSecMgrTclkReq
    181           *   ZDSecMgrAppConfKeyReq 
    182           *   ZDSecMgrSendNwkKey
    183           *   ZDSecMgrDeviceRemove
    184           *   ZDSecMgrDeviceValidateRM
    185           *   ZDSecMgrDeviceValidate
    186           *   ZDSecMgrDeviceJoin
    187           *   ZDSecMgrDeviceJoinDirect
    188           *   ZDSecMgrDeviceJoinFwd
    189           *   ZDSecMgrDeviceNew
    190           *   ZDSecMgrAssocDeviceAuth
    191           *   ZDSecMgrAuthNwkKey
    192           *   APSME_TCLinkKeyInit
    193           *   APSME_IsDefaultTCLK
    194           */
    195          
    196          //-----------------------------------------------------------------------------
    197          // address management
    198          //-----------------------------------------------------------------------------
    199          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    200          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    201          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    202          
    203          //-----------------------------------------------------------------------------
    204          // Trust Center management
    205          //-----------------------------------------------------------------------------
    206          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );
    207          void ZDSecMgrTCDataLoad( uint8* extAddr );
    208          
    209          //-----------------------------------------------------------------------------
    210          // entry data
    211          //-----------------------------------------------------------------------------
    212          void ZDSecMgrEntryInit(uint8 state);
    213          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    214          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    215          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    216          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    217          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex );
    218          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    219          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    220          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    221          void ZDSecMgrApsLinkKeyInit(uint8 setDefault);
    222          #if defined ( NV_RESTORE )
    223          static void ZDSecMgrWriteNV(void);
    224          static void ZDSecMgrRestoreFromNV(void);
    225          static void ZDSecMgrUpdateNV( uint16 index );
    226          #endif
    227          
    228          //-----------------------------------------------------------------------------
    229          // key support
    230          //-----------------------------------------------------------------------------
    231          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    232                                       uint8*  initExtAddr,
    233                                       uint16  partNwkAddr,
    234                                       uint8*  partExtAddr,
    235                                       uint8** key,
    236                                       uint8*  keyType );
    237          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    238          void ZDSecMgrTclkReq( ZDO_RequestKeyInd_t* ind );
    239          void ZDSecMgrAppConfKeyReq( ZDO_VerifyKeyInd_t* ind );
    240          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    241          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    242          
    243          //-----------------------------------------------------------------------------
    244          // device management
    245          //-----------------------------------------------------------------------------
    246          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    247          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    248          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    249          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    250          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    251          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    252          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    253          
    254          //-----------------------------------------------------------------------------
    255          // association management
    256          //-----------------------------------------------------------------------------
    257          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    258          
    259          //-----------------------------------------------------------------------------
    260          // authentication management
    261          //-----------------------------------------------------------------------------
    262          void ZDSecMgrAuthNwkKey( void );
    263          
    264          //-----------------------------------------------------------------------------
    265          // APSME function
    266          //-----------------------------------------------------------------------------
    267          void APSME_TCLinkKeyInit( uint8 setDefault );
    268          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    269          void ZDSecMgrGenerateSeed(uint8 setDefault );
    270          void ZDSecMgrGenerateKeyFromSeed(uint8 *extAddr, uint8 shift, uint8 *key);
    271          /******************************************************************************
    272           * @fn          ZDSecMgrAddrStore
    273           *
    274           * @brief       Store device addresses.
    275           *
    276           * @param       nwkAddr - [in] NWK address
    277           * @param       extAddr - [in] EXT address
    278           * @param       ami     - [out] Address Manager index
    279           *
    280           * @return      ZStatus_t
    281           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    282          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    283          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    284            ZStatus_t      status;
    285            AddrMgrEntry_t entry;
    286          
    287          
    288            // add entry
    289            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7402         MOV     A,#0x2
   \   000012   F0           MOVX    @DPTR,A
    290            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC     A
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine19 & 0xFFFF
    291            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_8:
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   AA82         MOV     R2,DPL
   \   00001F   AB83         MOV     R3,DPH
   \   000021   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000024   7416         MOV     A,#0x16
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ?Subroutine33 & 0xFFFF
    292          
    293            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_38:
   \   00002C   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00002F   E9           MOV     A,R1
   \   000030   6401         XRL     A,#0x1
   \   000032   700A         JNZ     ??ZDSecMgrAddrStore_0
    294            {
    295              // return successful results
    296              *ami   = entry.index;
   \   000034   740B         MOV     A,#0xb
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine11 & 0xFFFF
    297              status = ZSuccess;
    298            }
   \                     ??CrossCallReturnLabel_77:
   \   00003C   8008         SJMP    ??CrossCallReturnLabel_11
    299            else
    300            {
    301              // return failed results
    302              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ?Subroutine20 & 0xFFFF
    303              status = ZNwkUnknownDevice;
    304            }
    305          
    306            return status;
   \                     ??CrossCallReturnLabel_11:
   \   000046   02....       LJMP    ?Subroutine0 & 0xFFFF
    307          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000003   FE           MOV     R6,A
   \   000004   E9           MOV     A,R1
   \   000005   FF           MOV     R7,A
   \   000006                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000006                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000006   AA..         MOV     R2,?XSP + 0
   \   000008   AB..         MOV     R3,?XSP + 1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   E8           MOV     A,R0
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   E9           MOV     A,R1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   79C8         MOV     R1,#-0x38
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005   7403         MOV     A,#0x3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004                REQUIRE ??Subroutine55_0
   \   000004                ; // Fall through to label ??Subroutine55_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine55_0:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine56_0
   \   000005                ; // Fall through to label ??Subroutine56_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine56_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   740D         MOV     A,#0xd
   \   000002                REQUIRE ??Subroutine65_0
   \   000002                ; // Fall through to label ??Subroutine65_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine65_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine66_0
   \   000003                ; // Fall through to label ??Subroutine66_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine66_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    308          
    309          /******************************************************************************
    310           * @fn          ZDSecMgrExtAddrStore
    311           *
    312           * @brief       Store EXT address.
    313           *
    314           * @param       extAddr - [in] EXT address
    315           * @param       ami     - [out] Address Manager index
    316           *
    317           * @return      ZStatus_t
    318           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    319          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    320          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    321            ZStatus_t      status;
    322            AddrMgrEntry_t entry;
    323          
    324          
    325            // add entry
    326            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7402         MOV     A,#0x2
   \   000012   F0           MOVX    @DPTR,A
    327            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC     A
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine19 & 0xFFFF
    328            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_9:
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   AA82         MOV     R2,DPL
   \   00001F   AB83         MOV     R3,DPH
   \   000021   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000024   7416         MOV     A,#0x16
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ?Subroutine33 & 0xFFFF
    329          
    330            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_39:
   \   00002C   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00002F   E9           MOV     A,R1
   \   000030   6401         XRL     A,#0x1
   \   000032   700A         JNZ     ??ZDSecMgrExtAddrStore_0
    331            {
    332              // return successful results
    333              *ami   = entry.index;
   \   000034   740B         MOV     A,#0xb
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine11 & 0xFFFF
    334              status = ZSuccess;
    335            }
   \                     ??CrossCallReturnLabel_78:
   \   00003C   8008         SJMP    ??CrossCallReturnLabel_12
    336            else
    337            {
    338              // return failed results
    339              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ?Subroutine20 & 0xFFFF
    340              status = ZNwkUnknownDevice;
    341            }
    342          
    343            return status;
   \                     ??CrossCallReturnLabel_12:
   \   000046   02....       LJMP    ?Subroutine0 & 0xFFFF
    344          }
    345          
    346          /******************************************************************************
    347           * @fn          ZDSecMgrExtAddrLookup
    348           *
    349           * @brief       Lookup index for specified EXT address.
    350           *
    351           * @param       extAddr - [in] EXT address
    352           * @param       ami     - [out] Address Manager index
    353           *
    354           * @return      ZStatus_t
    355           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    356          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    357          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    358            ZStatus_t      status;
    359            AddrMgrEntry_t entry;
    360          
    361          
    362            // lookup entry
    363            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
    364            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   AA82         MOV     R2,DPL
   \   000022   AB83         MOV     R3,DPH
   \   000024   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    365          
    366            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   AA..         MOV     R2,?XSP + 0
   \   000029   AB..         MOV     R3,?XSP + 1
   \   00002B   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00002E   E9           MOV     A,R1
   \   00002F   6401         XRL     A,#0x1
   \   000031   700A         JNZ     ??ZDSecMgrExtAddrLookup_0
    367            {
    368              // return successful results
    369              *ami   = entry.index;
   \   000033   740B         MOV     A,#0xb
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   12....       LCALL   ?Subroutine11 & 0xFFFF
    370              status = ZSuccess;
    371            }
   \                     ??CrossCallReturnLabel_79:
   \   00003B   8008         SJMP    ??CrossCallReturnLabel_13
    372            else
    373            {
    374              // return failed results
    375              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   00003D   740B         MOV     A,#0xb
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ?Subroutine20 & 0xFFFF
    376              status = ZNwkUnknownDevice;
    377            }
    378          
    379            return status;
   \                     ??CrossCallReturnLabel_13:
   \   000045   02....       LJMP    ?Subroutine0 & 0xFFFF
    380          }
    381          
    382          /******************************************************************************
    383           * @fn          ZDSecMgrAddrClear
    384           *
    385           * @brief       Clear security bit from Address Manager for specific device.
    386           *
    387           * @param       extAddr - [in] EXT address
    388           *
    389           * @return      ZStatus_t
    390           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    391          ZStatus_t ZDSecMgrAddrClear( uint8* extAddr )
   \                     ZDSecMgrAddrClear:
    392          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    393            ZStatus_t status;
    394            uint16 entryAmi;
    395          
    396            // get Address Manager Index
    397            status = ZDSecMgrExtAddrLookup( extAddr, &entryAmi );
   \   00000A                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000A   AC..         MOV     R4,?XSP + 0
   \   00000C   AD..         MOV     R5,?XSP + 1
   \   00000E   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000011   E9           MOV     A,R1
   \   000012   FE           MOV     R6,A
    398          
    399            if ( status == ZSuccess )
   \   000013   7028         JNZ     ??ZDSecMgrAddrClear_0
    400            {
    401              AddrMgrEntry_t addrEntry;
    402          
    403              // Clear SECURITY User bit from the address manager
    404              addrEntry.user = ADDRMGR_USER_SECURITY;
   \   000015   7402         MOV     A,#0x2
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   7402         MOV     A,#0x2
   \   00001C   F0           MOVX    @DPTR,A
    405              addrEntry.index = entryAmi;
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000026   740D         MOV     A,#0xd
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    406          
    407              if ( AddrMgrEntryRelease( &addrEntry ) != TRUE )
   \                     ??CrossCallReturnLabel_141:
   \   00002E                ; Setup parameters for call to function AddrMgrEntryRelease
   \   00002E   7402         MOV     A,#0x2
   \   000030   12....       LCALL   ?XSTACK_DISP101_8
   \   000033   12....       LCALL   `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   \   000036   E9           MOV     A,R1
   \   000037   6401         XRL     A,#0x1
   \   000039   6002         JZ      ??ZDSecMgrAddrClear_0
    408              {
    409                // return failure results
    410                status = ZFailure;
   \   00003B   7E01         MOV     R6,#0x1
    411              }
    412            }
    413          
    414            return status;
   \                     ??ZDSecMgrAddrClear_0:
   \   00003D   EE           MOV     A,R6
   \   00003E   F9           MOV     R1,A
   \   00003F   740F         MOV     A,#0xf
   \   000041   02....       LJMP    ??Subroutine65_0 & 0xFFFF
    415          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine62_0:
   \   000000   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine64_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    416          
    417          /******************************************************************************
    418           * @fn          ZDSecMgrEntryInit
    419           *
    420           * @brief       Initialize entry sub module
    421           *
    422           * @param       state - device initialization state
    423           *
    424           * @return      none
    425           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    426          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    427          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    428            if (ZDSecMgrEntries == NULL)
   \   000007   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00000A   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   00000D   7030         JNZ     ??ZDSecMgrEntryInit_0
    429            {
    430              uint16 index;
    431          
    432              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A0F         MOV     R2,#0xf
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000016   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000019   EA           MOV     A,R2
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   EB           MOV     A,R3
   \   00001D   12....       LCALL   ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000020   6023         JZ      ??ZDSecMgrEntryInit_1
    433              {
    434                return;
    435              }
    436          
    437              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   000022   7800         MOV     R0,#0x0
   \   000024   7900         MOV     R1,#0x0
    438              {
    439                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_2:
   \   000026   12....       LCALL   ?Subroutine37 & 0xFFFF
    440          
    441                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
    442              }
   \                     ??CrossCallReturnLabel_46:
   \   000029   74FE         MOV     A,#-0x2
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   04           INC     A
   \   00002E   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000031   E4           CLR     A
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   F0           MOVX    @DPTR,A
   \   000035   08           INC     R0
   \   000036   E8           MOV     A,R0
   \   000037   7001         JNZ     ??ZDSecMgrEntryInit_3
   \   000039   09           INC     R1
   \                     ??ZDSecMgrEntryInit_3:
   \   00003A   12....       LCALL   ?Subroutine42 & 0xFFFF
    443            }
   \                     ??CrossCallReturnLabel_85:
   \   00003D   40E7         JC      ??ZDSecMgrEntryInit_2
    444          
    445          #if defined NV_RESTORE
    446            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
   \                     ??ZDSecMgrEntryInit_0:
   \   00003F   EE           MOV     A,R6
   \   000040   7003         JNZ     ??ZDSecMgrEntryInit_1
    447            {
    448              ZDSecMgrRestoreFromNV();
   \   000042                ; Setup parameters for call to function ZDSecMgrRestoreFromNV
   \   000042   12....       LCALL   `??ZDSecMgrRestoreFromNV::?relay`; Banked call to: ZDSecMgrRestoreFromNV
    449            }
    450          #else
    451            (void)state;
    452          #endif
    453          }
   \                     ??ZDSecMgrEntryInit_1:
   \   000045   02....       LJMP    ??Subroutine66_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   C3           CLR     C
   \   000001                REQUIRE ??Subroutine57_0
   \   000001                ; // Fall through to label ??Subroutine57_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine57_0:
   \   000000   9403         SUBB    A,#0x3
   \   000002   E9           MOV     A,R1
   \   000003   9400         SUBB    A,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine58_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000004   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000007   49           ORL     A,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   E8           MOV     A,R0
   \   000001   FA           MOV     R2,A
   \   000002   E9           MOV     A,R1
   \   000003   FB           MOV     R3,A
   \   000004   EA           MOV     A,R2
   \   000005   75F005       MOV     B,#0x5
   \   000008   A4           MUL     AB
   \   000009   FA           MOV     R2,A
   \   00000A   ACF0         MOV     R4,B
   \   00000C   75F005       MOV     B,#0x5
   \   00000F   EB           MOV     A,R3
   \   000010   A4           MUL     AB
   \   000011   2C           ADD     A,R4
   \   000012   FB           MOV     R3,A
   \   000013   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000016   E0           MOVX    A,@DPTR
   \   000017   2A           ADD     A,R2
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   3B           ADDC    A,R3
   \   00001C   FB           MOV     R3,A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine59_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine67_0:
   \   000000   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000003   49           ORL     A,R1
   \   000004   22           RET
    454          
    455          /******************************************************************************
    456           * @fn          ZDSecMgrEntryLookup
    457           *
    458           * @brief       Lookup entry index using specified NWK address.
    459           *
    460           * @param       nwkAddr - [in] NWK address
    461           * @param       entry   - [out] valid entry
    462           *
    463           * @return      ZStatus_t
    464           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    465          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    466          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    467            uint16         index;
    468            AddrMgrEntry_t addrMgrEntry;
    469          
    470            // initialize results
    471            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ?Subroutine10 & 0xFFFF
    472          
    473            // verify data is available
    474            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_90:
   \   000015   6046         JZ      ??ZDSecMgrEntryLookup_0
    475            {
    476              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   7402         MOV     A,#0x2
   \   00001F   F0           MOVX    @DPTR,A
    477              addrMgrEntry.nwkAddr = nwkAddr;
   \   000020   14           DEC     A
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine12 & 0xFFFF
    478          
    479              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_186:
   \   000027   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00002A   E9           MOV     A,R1
   \   00002B   6401         XRL     A,#0x1
   \   00002D   702E         JNZ     ??ZDSecMgrEntryLookup_0
    480              {
    481                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00002F   7800         MOV     R0,#0x0
   \   000031   7900         MOV     R1,#0x0
    482                {
    483                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_1:
   \   000033   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000036   740B         MOV     A,#0xb
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   E0           MOVX    A,@DPTR
   \   000043   6C           XRL     A,R4
   \   000044   7003         JNZ     ??ZDSecMgrEntryLookup_2
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_2:
   \   000049   7008         JNZ     ??ZDSecMgrEntryLookup_3
    484                  {
    485                    // return successful results
    486                    *entry = &ZDSecMgrEntries[index];
   \   00004B   EA           MOV     A,R2
   \   00004C   F8           MOV     R0,A
   \   00004D   EB           MOV     A,R3
   \   00004E   12....       LCALL   ??Subroutine55_0 & 0xFFFF
    487          
    488                    // break from loop
    489                    return ZSuccess;
    490                  }
    491                }
   \                     ??CrossCallReturnLabel_80:
   \   000051   800C         SJMP    ??ZDSecMgrEntryLookup_4
   \                     ??ZDSecMgrEntryLookup_3:
   \   000053   08           INC     R0
   \   000054   E8           MOV     A,R0
   \   000055   7001         JNZ     ??ZDSecMgrEntryLookup_5
   \   000057   09           INC     R1
   \                     ??ZDSecMgrEntryLookup_5:
   \   000058   12....       LCALL   ?Subroutine42 & 0xFFFF
    492              }
    493            }
   \                     ??CrossCallReturnLabel_86:
   \   00005B   40D6         JC      ??ZDSecMgrEntryLookup_1
    494          
    495            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookup_0:
   \   00005D   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookup_4:
   \   00005F   02....       LJMP    ?Subroutine0 & 0xFFFF
    496          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine58_0
   \   000003                ; // Fall through to label ??Subroutine58_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004                REQUIRE ??Subroutine74_0
   \   000004                ; // Fall through to label ??Subroutine74_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine74_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000001                ; Setup parameters for call to function APSME_ConfirmKeyReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000001                ; Setup parameters for call to function APSME_SwitchKeyReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001   AA..         MOV     R2,?XSP + 0
   \   000003   AB..         MOV     R3,?XSP + 1
   \   000005   22           RET
    497          
    498          /******************************************************************************
    499           * @fn          ZDSecMgrEntryLookupAMI
    500           *
    501           * @brief       Lookup entry using specified address index
    502           *
    503           * @param       ami   - [in] Address Manager index
    504           * @param       entry - [out] valid entry
    505           *
    506           * @return      ZStatus_t
    507           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    508          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    509          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    510            uint16 index;
    511          
    512            // initialize results
    513            *entry = NULL;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   12....       LCALL   ?Subroutine10 & 0xFFFF
    514          
    515            // verify data is available
    516            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_91:
   \   00000C   6030         JZ      ??ZDSecMgrEntryLookupAMI_0
    517            {
    518              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   7800         MOV     R0,#0x0
   \   000010   7900         MOV     R1,#0x0
    519              {
    520                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000012   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000015   FE           MOV     R6,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   3F           ADDC    A,R7
   \   000019   FF           MOV     R7,A
   \   00001A   8E82         MOV     DPL,R6
   \   00001C   8F83         MOV     DPH,R7
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6A           XRL     A,R2
   \   000020   7003         JNZ     ??ZDSecMgrEntryLookupAMI_2
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000025   700D         JNZ     ??ZDSecMgrEntryLookupAMI_3
    521                {
    522                  // return successful results
    523                  *entry = &ZDSecMgrEntries[index];
   \   000027   EE           MOV     A,R6
   \   000028   F8           MOV     R0,A
   \   000029   EF           MOV     A,R7
   \   00002A   F9           MOV     R1,A
   \   00002B   8C82         MOV     DPL,R4
   \   00002D   8D83         MOV     DPH,R5
   \   00002F   12....       LCALL   ??Subroutine56_0 & 0xFFFF
    524          
    525                  // break from loop
    526                  return ZSuccess;
    527                }
    528              }
   \                     ??CrossCallReturnLabel_81:
   \   000032   800C         SJMP    ??ZDSecMgrEntryLookupAMI_4
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000034   08           INC     R0
   \   000035   E8           MOV     A,R0
   \   000036   7001         JNZ     ??ZDSecMgrEntryLookupAMI_5
   \   000038   09           INC     R1
   \                     ??ZDSecMgrEntryLookupAMI_5:
   \   000039   12....       LCALL   ?Subroutine42 & 0xFFFF
    529            }
   \                     ??CrossCallReturnLabel_87:
   \   00003C   40D4         JC      ??ZDSecMgrEntryLookupAMI_1
    530          
    531            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   00003E   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   000040   02....       LJMP    ??Subroutine66_0 & 0xFFFF
    532          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E8           MOV     A,R0
   \   000001   FE           MOV     R6,A
   \   000002   E9           MOV     A,R1
   \   000003   FF           MOV     R7,A
   \   000004   EE           MOV     A,R6
   \   000005   75F005       MOV     B,#0x5
   \   000008   A4           MUL     AB
   \   000009   FE           MOV     R6,A
   \   00000A   85F0..       MOV     ?V0,B
   \   00000D   75F005       MOV     B,#0x5
   \   000010   EF           MOV     A,R7
   \   000011   A4           MUL     AB
   \   000012   25..         ADD     A,?V0
   \   000014   FF           MOV     R7,A
   \   000015   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000018   E0           MOVX    A,@DPTR
   \   000019   2E           ADD     A,R6
   \   00001A   22           RET
    533          
    534          /******************************************************************************
    535           * @fn          ZDSecMgrEntryLookupExt
    536           *
    537           * @brief       Lookup entry index using specified EXT address.
    538           *
    539           * @param       extAddr - [in] EXT address
    540           * @param       entry   - [out] valid entry
    541           *
    542           * @return      ZStatus_t
    543           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    544          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    545          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    546            ZStatus_t status;
    547            uint16    ami;
    548          
    549            // initialize results
    550            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    551            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0,#-0x38
    552          
    553            // lookup address index
    554            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   AC..         MOV     R4,?XSP + 0
   \   00001B   AD..         MOV     R5,?XSP + 1
   \   00001D   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000020   E9           MOV     A,R1
   \   000021   7013         JNZ     ??ZDSecMgrEntryLookupExt_0
    555            {
    556              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000023                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000023   EE           MOV     A,R6
   \   000024   FC           MOV     R4,A
   \   000025   EF           MOV     A,R7
   \   000026   FD           MOV     R5,A
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   12....       LCALL   ??Subroutine61_0 & 0xFFFF
    557            }
   \                     ??CrossCallReturnLabel_98:
   \   000030   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000033   E9           MOV     A,R1
   \   000034   F5..         MOV     ?V0,A
    558          
    559            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000036   A9..         MOV     R1,?V0
   \   000038   02....       LJMP    ?Subroutine7 & 0xFFFF
    560          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7402         MOV     A,#0x2
   \   000002   02....       LJMP    ??Subroutine65_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine61_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    561          
    562          /******************************************************************************
    563           * @fn          ZDSecMgrEntryLookupExtGetIndex
    564           *
    565           * @brief       Lookup entry index using specified EXT address.
    566           *
    567           * @param       extAddr - [in] EXT address
    568           * @param       entryIndex - [out] valid index to the entry table
    569           *
    570           * @return      ZStatus_t
    571           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    572          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    573          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    574            uint16 ami;
    575            uint16 index;
    576          
    577            // lookup address index
    578            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV     A,R1
   \   000016   703F         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_0
    579            {
    580              // verify data is available
    581              if ( ZDSecMgrEntries != NULL )
   \   000018   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001B   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   00001E   6037         JZ      ??ZDSecMgrEntryLookupExtGetIndex_0
    582              {
    583                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000020   7800         MOV     R0,#0x0
   \   000022   7900         MOV     R1,#0x0
    584                {
    585                  if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   000024   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000027   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   6C           XRL     A,R4
   \   000032   7003         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_2
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   000037   7014         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_3
    586                  {
    587                    // return successful results
    588                    *entry = &ZDSecMgrEntries[index];
   \   000039   8E82         MOV     DPL,R6
   \   00003B   8F83         MOV     DPH,R7
   \   00003D   12....       LCALL   ?Subroutine26 & 0xFFFF
    589                    *entryIndex = index;
   \                     ??CrossCallReturnLabel_22:
   \   000040   740B         MOV     A,#0xb
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   12....       LCALL   ??Subroutine76_0 & 0xFFFF
    590          
    591                    // break from loop
    592                    return ZSuccess;
    593                  }
    594                }
   \                     ??CrossCallReturnLabel_194:
   \   000048   12....       LCALL   ??Subroutine56_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00004B   800C         SJMP    ??ZDSecMgrEntryLookupExtGetIndex_4
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   00004D   08           INC     R0
   \   00004E   E8           MOV     A,R0
   \   00004F   7001         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_5
   \   000051   09           INC     R1
   \                     ??ZDSecMgrEntryLookupExtGetIndex_5:
   \   000052   12....       LCALL   ?Subroutine42 & 0xFFFF
    595              }
    596            }
   \                     ??CrossCallReturnLabel_88:
   \   000055   40CD         JC      ??ZDSecMgrEntryLookupExtGetIndex_1
    597          
    598            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   000057   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   000059   02....       LJMP    ?Subroutine7 & 0xFFFF
    599          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine76_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8A82         MOV     DPL,R2
   \   000008   22           RET
    600          
    601          /******************************************************************************
    602           * @fn          ZDSecMgrEntryLookupAMIGetIndex
    603           *
    604           * @brief       Lookup entry using specified address index
    605           *
    606           * @param       ami   - [in] Address Manager index
    607           * @param       entryIndex - [out] valid index to the entry table
    608           *
    609           * @return      ZStatus_t
    610           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    611          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupAMIGetIndex:
    612          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    613            uint16 index;
    614          
    615            // verify data is available
    616            if ( ZDSecMgrEntries != NULL )
   \   000005   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000008   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   00000B   602D         JZ      ??ZDSecMgrEntryLookupAMIGetIndex_0
    617            {
    618              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000D   7800         MOV     R0,#0x0
   \   00000F   7900         MOV     R1,#0x0
    619              {
    620                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_1:
   \   000011   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000014   F5..         MOV     ?V0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   3F           ADDC    A,R7
   \   000019   85..82       MOV     DPL,?V0
   \   00001C   F583         MOV     DPH,A
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6A           XRL     A,R2
   \   000020   7003         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_2
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_2:
   \   000025   7009         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_3
    621                {
    622                  // return successful results
    623                  *entryIndex = index;
   \   000027   8C82         MOV     DPL,R4
   \   000029   8D83         MOV     DPH,R5
   \   00002B   12....       LCALL   ??Subroutine56_0 & 0xFFFF
    624          
    625                  // break from loop
    626                  return ZSuccess;
    627                }
    628              }
   \                     ??CrossCallReturnLabel_83:
   \   00002E   800C         SJMP    ??ZDSecMgrEntryLookupAMIGetIndex_4
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_3:
   \   000030   08           INC     R0
   \   000031   E8           MOV     A,R0
   \   000032   7001         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_5
   \   000034   09           INC     R1
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_5:
   \   000035   12....       LCALL   ?Subroutine42 & 0xFFFF
    629            }
   \                     ??CrossCallReturnLabel_89:
   \   000038   40D7         JC      ??ZDSecMgrEntryLookupAMIGetIndex_1
    630          
    631            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_0:
   \   00003A   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_4:
   \   00003C   02....       LJMP    ??Subroutine66_0 & 0xFFFF
    632          }
    633          
    634          /******************************************************************************
    635           * @fn          ZDSecMgrEntryFree
    636           *
    637           * @brief       Free entry.
    638           *
    639           * @param       entry - [in] valid entry
    640           *
    641           * @return      ZStatus_t
    642           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    643          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    644          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    645            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
    646          
    647          #if defined ( NV_RESTORE )
    648            ZStatus_t status;
    649            uint16 entryIndex;
    650          
    651            status = ZDSecMgrEntryLookupAMIGetIndex( entry->ami, &entryIndex );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupAMIGetIndex
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP102_8
   \   000013   8E82         MOV     DPL,R6
   \   000015   8F83         MOV     DPH,R7
   \   000017   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00001A   12....       LCALL   `??ZDSecMgrEntryLookupAMIGetIndex::?relay`; Banked call to: ZDSecMgrEntryLookupAMIGetIndex
   \   00001D   E9           MOV     A,R1
   \   00001E   F5..         MOV     ?V2,A
    652          #endif
    653          
    654            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000020                ; Setup parameters for call to function osal_mem_alloc
   \   000020   7A18         MOV     R2,#0x18
   \   000022   7B00         MOV     R3,#0x0
   \   000024   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000027   8A..         MOV     ?V4,R2
   \   000029   8B..         MOV     ?V5,R3
    655          
    656            if (pApsLinkKey != NULL)
   \   00002B   EA           MOV     A,R2
   \   00002C   45..         ORL     A,?V5
   \   00002E   6041         JZ      ??ZDSecMgrEntryFree_0
    657            {
    658              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000030                ; Setup parameters for call to function osal_memset
   \   000030   7C18         MOV     R4,#0x18
   \   000032   7D00         MOV     R5,#0x0
   \   000034   7900         MOV     R1,#0x0
   \   000036   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    659          
    660              // Clear the APS Link key in NV
    661              osal_nv_write( entry->keyNvId, 0,
    662                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   000039   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   00003C                ; Setup parameters for call to function osal_nv_write
   \   00003C   78..         MOV     R0,#?V4
   \   00003E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000041   75..18       MOV     ?V6,#0x18
   \   000044   75..00       MOV     ?V7,#0x0
   \   000047   78..         MOV     R0,#?V6
   \   000049   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004C   7C00         MOV     R4,#0x0
   \   00004E   7D00         MOV     R5,#0x0
   \   000050   85..82       MOV     DPL,?V0
   \   000053   8983         MOV     DPH,R1
   \   000055   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000058   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00005B   7404         MOV     A,#0x4
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
    663          
    664              // set entry to invalid Key
    665              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   000060   85..82       MOV     DPL,?V0
   \   000063   85..83       MOV     DPH,?V1
   \   000066   E4           CLR     A
   \   000067   F0           MOVX    @DPTR,A
   \   000068   A3           INC     DPTR
   \   000069   F0           MOVX    @DPTR,A
    666          
    667              osal_mem_free(pApsLinkKey);
   \   00006A                ; Setup parameters for call to function osal_mem_free
   \   00006A   AA..         MOV     R2,?V4
   \   00006C   AB..         MOV     R3,?V5
   \   00006E   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    668            }
    669          
    670            // marking the entry as INVALID_NODE_ADDR
    671            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   000071   8E82         MOV     DPL,R6
   \   000073   8F83         MOV     DPH,R7
   \   000075   74FE         MOV     A,#-0x2
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   04           INC     A
   \   00007A   12....       LCALL   ?Subroutine49 & 0xFFFF
    672          
    673            // set to default value
    674            entry->authenticateOption = ZDSecMgr_Not_Authenticated;
   \                     ??CrossCallReturnLabel_66:
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   E4           CLR     A
   \   000082   F0           MOVX    @DPTR,A
    675          
    676          #if defined ( NV_RESTORE )
    677            if ( status == ZSuccess )
   \   000083   E5..         MOV     A,?V2
   \   000085   6003         JZ      $+5
   \   000087   02....       LJMP    ??ZDSecMgrEntryFree_1 & 0xFFFF
    678            {
    679              ZDSecMgrUpdateNV(entryIndex);
   \   00008A   7402         MOV     A,#0x2
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   12....       LCALL   ??Subroutine61_0 & 0xFFFF
    680            }
   \                     ??CrossCallReturnLabel_101:
   \   000092   EA           MOV     A,R2
   \   000093   FE           MOV     R6,A
   \   000094   EB           MOV     A,R3
   \   000095   FF           MOV     R7,A
   \   000096   EE           MOV     A,R6
   \   000097   75F005       MOV     B,#0x5
   \   00009A   A4           MUL     AB
   \   00009B   FE           MOV     R6,A
   \   00009C   A8F0         MOV     R0,B
   \   00009E   75F005       MOV     B,#0x5
   \   0000A1   EF           MOV     A,R7
   \   0000A2   A4           MUL     AB
   \   0000A3   28           ADD     A,R0
   \   0000A4   FF           MOV     R7,A
   \   0000A5   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000A8   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   0000AB   603E         JZ      ??ZDSecMgrEntryFree_2
   \   0000AD                ; Setup parameters for call to function osal_nv_write
   \   0000AD   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   2E           ADD     A,R6
   \   0000B2   F5..         MOV     ?V0,A
   \   0000B4   A3           INC     DPTR
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   3F           ADDC    A,R7
   \   0000B7   F5..         MOV     ?V1,A
   \   0000B9   78..         MOV     R0,#?V0
   \   0000BB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BE   75..05       MOV     ?V0,#0x5
   \   0000C1   75..00       MOV     ?V1,#0x0
   \   0000C4   78..         MOV     R0,#?V0
   \   0000C6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C9   EA           MOV     A,R2
   \   0000CA   75F005       MOV     B,#0x5
   \   0000CD   A4           MUL     AB
   \   0000CE   FA           MOV     R2,A
   \   0000CF   A8F0         MOV     R0,B
   \   0000D1   75F005       MOV     B,#0x5
   \   0000D4   EB           MOV     A,R3
   \   0000D5   A4           MUL     AB
   \   0000D6   28           ADD     A,R0
   \   0000D7   FB           MOV     R3,A
   \   0000D8   EA           MOV     A,R2
   \   0000D9   2402         ADD     A,#0x2
   \   0000DB   FC           MOV     R4,A
   \   0000DC   E4           CLR     A
   \   0000DD   3B           ADDC    A,R3
   \   0000DE   FD           MOV     R5,A
   \   0000DF   7A4C         MOV     R2,#0x4c
   \   0000E1   7B00         MOV     R3,#0x0
   \   0000E3   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000E6   7404         MOV     A,#0x4
   \   0000E8   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??ZDSecMgrEntryFree_2:
   \   0000EB                ; Setup parameters for call to function osal_nv_read
   \   0000EB   A8..         MOV     R0,?XSP + 0
   \   0000ED   A9..         MOV     R1,?XSP + 1
   \   0000EF   88..         MOV     ?V0,R0
   \   0000F1   89..         MOV     ?V1,R1
   \   0000F3   78..         MOV     R0,#?V0
   \   0000F5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F8   75..02       MOV     ?V0,#0x2
   \   0000FB   75..00       MOV     ?V1,#0x0
   \   0000FE   78..         MOV     R0,#?V0
   \   000100   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000103   7C00         MOV     R4,#0x0
   \   000105   7D00         MOV     R5,#0x0
   \   000107   7A4C         MOV     R2,#0x4c
   \   000109   7B00         MOV     R3,#0x0
   \   00010B   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00010E   7404         MOV     A,#0x4
   \   000110   12....       LCALL   ?DEALLOC_XSTACK8
   \   000113   E9           MOV     A,R1
   \   000114   7054         JNZ     ??ZDSecMgrEntryFree_1
   \   000116   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000119   E0           MOVX    A,@DPTR
   \   00011A   64FE         XRL     A,#0xfe
   \   00011C   7003         JNZ     ??ZDSecMgrEntryFree_3
   \   00011E   A3           INC     DPTR
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   F4           CPL     A
   \                     ??ZDSecMgrEntryFree_3:
   \   000121   85..82       MOV     DPL,?XSP + 0
   \   000124   85..83       MOV     DPH,?XSP + 1
   \   000127   7015         JNZ     ??ZDSecMgrEntryFree_4
   \   000129   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   00012C   6014         JZ      ??ZDSecMgrEntryFree_5
   \   00012E   85..82       MOV     DPL,?XSP + 0
   \   000131   85..83       MOV     DPH,?XSP + 1
   \   000134   E0           MOVX    A,@DPTR
   \   000135   24FF         ADD     A,#-0x1
   \   000137   F0           MOVX    @DPTR,A
   \   000138   A3           INC     DPTR
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   34FF         ADDC    A,#-0x1
   \   00013C   8003         SJMP    ??CrossCallReturnLabel_50
   \                     ??ZDSecMgrEntryFree_4:
   \   00013E   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000141   F0           MOVX    @DPTR,A
   \                     ??ZDSecMgrEntryFree_5:
   \   000142                ; Setup parameters for call to function osal_nv_write
   \   000142   A8..         MOV     R0,?XSP + 0
   \   000144   A9..         MOV     R1,?XSP + 1
   \   000146   88..         MOV     ?V0,R0
   \   000148   89..         MOV     ?V1,R1
   \   00014A   78..         MOV     R0,#?V0
   \   00014C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014F   75..02       MOV     ?V0,#0x2
   \   000152   75..00       MOV     ?V1,#0x0
   \   000155   78..         MOV     R0,#?V0
   \   000157   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015A   7C00         MOV     R4,#0x0
   \   00015C   7D00         MOV     R5,#0x0
   \   00015E   7A4C         MOV     R2,#0x4c
   \   000160   7B00         MOV     R3,#0x0
   \   000162   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000165   7404         MOV     A,#0x4
   \   000167   12....       LCALL   ?DEALLOC_XSTACK8
    681          #endif
    682          }
   \                     ??ZDSecMgrEntryFree_1:
   \   00016A   7404         MOV     A,#0x4
   \   00016C                REQUIRE ?Subroutine1
   \   00016C                ; // Fall through to label ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004   E4           CLR     A
   \   000005   3F           ADDC    A,R7
   \   000006   F9           MOV     R1,A
   \   000007   88..         MOV     ?V0,R0
   \   000009   89..         MOV     ?V1,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2401         ADD     A,#0x1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000003   E0           MOVX    A,@DPTR
   \   000004   2E           ADD     A,R6
   \   000005   F8           MOV     R0,A
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   3F           ADDC    A,R7
   \   000009   8882         MOV     DPL,R0
   \   00000B   F583         MOV     DPH,A
   \   00000D   22           RET
    683          
    684          /******************************************************************************
    685           * @fn          ZDSecMgrEntryNew
    686           *
    687           * @brief       Get a new entry.
    688           *
    689           * @param       entry - [out] valid entry
    690           *
    691           * @return      ZStatus_t
    692           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    693          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    694          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    695            uint16 index;
    696          
    697            // initialize results
    698            *entry = NULL;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine10 & 0xFFFF
    699          
    700            // verify data is available
    701            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_92:
   \   00000C   605F         JZ      ??ZDSecMgrEntryNew_0
    702            {
    703              // find available entry
    704              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   7C00         MOV     R4,#0x0
   \   000010   7D00         MOV     R5,#0x0
    705              {
    706                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_1:
   \   000012   EC           MOV     A,R4
   \   000013   F8           MOV     R0,A
   \   000014   ED           MOV     A,R5
   \   000015   F9           MOV     R1,A
   \   000016   E8           MOV     A,R0
   \   000017   75F005       MOV     B,#0x5
   \   00001A   A4           MUL     AB
   \   00001B   F8           MOV     R0,A
   \   00001C   AEF0         MOV     R6,B
   \   00001E   75F005       MOV     B,#0x5
   \   000021   E9           MOV     A,R1
   \   000022   A4           MUL     AB
   \   000023   2E           ADD     A,R6
   \   000024   F9           MOV     R1,A
   \   000025   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000028   E0           MOVX    A,@DPTR
   \   000029   28           ADD     A,R0
   \   00002A   FE           MOV     R6,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   39           ADDC    A,R1
   \   00002E   FF           MOV     R7,A
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E0           MOVX    A,@DPTR
   \   000034   64FE         XRL     A,#0xfe
   \   000036   7003         JNZ     ??ZDSecMgrEntryNew_2
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F4           CPL     A
   \                     ??ZDSecMgrEntryNew_2:
   \   00003B   7023         JNZ     ??ZDSecMgrEntryNew_3
    707                {
    708                  // return successful result
    709                  *entry = &ZDSecMgrEntries[index];
   \   00003D   EE           MOV     A,R6
   \   00003E   FC           MOV     R4,A
   \   00003F   EF           MOV     A,R7
   \   000040   FD           MOV     R5,A
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   EC           MOV     A,R4
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   ED           MOV     A,R5
   \   000049   F0           MOVX    @DPTR,A
    710          
    711                  // Set the authentication option to default
    712                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00004A   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   28           ADD     A,R0
   \   00004F   FA           MOV     R2,A
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   39           ADDC    A,R1
   \   000053   8A82         MOV     DPL,R2
   \   000055   F583         MOV     DPH,A
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
    713          
    714                  // break from loop
    715                  return ZSuccess;
   \   00005D   F9           MOV     R1,A
   \   00005E   800F         SJMP    ??ZDSecMgrEntryNew_4
    716                }
    717              }
   \                     ??ZDSecMgrEntryNew_3:
   \   000060   0C           INC     R4
   \   000061   EC           MOV     A,R4
   \   000062   7001         JNZ     ??ZDSecMgrEntryNew_5
   \   000064   0D           INC     R5
   \                     ??ZDSecMgrEntryNew_5:
   \   000065   C3           CLR     C
   \   000066   9403         SUBB    A,#0x3
   \   000068   ED           MOV     A,R5
   \   000069   9400         SUBB    A,#0x0
   \   00006B   40A5         JC      ??ZDSecMgrEntryNew_1
    718            }
    719          
    720            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryNew_0:
   \   00006D   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryNew_4:
   \   00006F   02....       LJMP    ??Subroutine66_0 & 0xFFFF
    721          }
    722          
    723          /******************************************************************************
    724           * @fn          ZDSecMgrAppKeyGet
    725           *
    726           * @brief       get an APP key - option APP(MASTER or LINK) key
    727           *
    728           * @param       initNwkAddr - [in] NWK address of initiator device
    729           * @param       initExtAddr - [in] EXT address of initiator device
    730           * @param       partNwkAddr - [in] NWK address of partner device
    731           * @param       partExtAddr - [in] EXT address of partner device
    732           * @param       key         - [out] APP(MASTER or LINK) key
    733           * @param       keyType     - [out] APP(MASTER or LINK) key type
    734           *
    735           * @return      ZStatus_t
    736           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    737          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
    738                                                           // to KEY_TYPE_APP_LINK since
    739                                                           // only specific requirement
    740                                                           // right now comes from SE profile

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    741          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
    742                                       uint8*  initExtAddr,
    743                                       uint16  partNwkAddr,
    744                                       uint8*  partExtAddr,
    745                                       uint8** key,
    746                                       uint8*  keyType )
    747          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    748            // Intentionally unreferenced parameters
    749            (void)initNwkAddr;
    750            (void)initExtAddr;
    751            (void)partNwkAddr;
    752            (void)partExtAddr;
    753          
    754            //---------------------------------------------------------------------------
    755            // note:
    756            // should use a robust mechanism to generate keys, for example
    757            // combine EXT addresses and call a hash function
    758            //---------------------------------------------------------------------------
    759            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000004                ; Setup parameters for call to function SSP_GetTrueRand
   \   000004   7404         MOV     A,#0x4
   \   000006   12....       LCALL   ?XSTACK_DISP0_8
   \   000009   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   00000C   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   00000F   7910         MOV     R1,#0x10
   \   000011   12....       LCALL   `??SSP_GetTrueRand::?relay`; Banked call to: SSP_GetTrueRand
    760          
    761            *keyType = ZDSecMgrAppKeyType;
   \   000014   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000017   E0           MOVX    A,@DPTR
   \   000018   C0E0         PUSH    A
   \   00001A   7406         MOV     A,#0x6
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000022   D0E0         POP     A
   \   000024   02....       LJMP    ?Subroutine2 & 0xFFFF
    762          
    763            return ZSuccess;
    764          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7900         MOV     R1,#0x0
   \   000003                REQUIRE ??Subroutine63_0
   \   000003                ; // Fall through to label ??Subroutine63_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine63_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    765          
    766          
    767          
    768          
    769          /******************************************************************************
    770           * @fn          ZDSecMgrAppKeyReq
    771           *
    772           * @brief       Process request for APP key between two devices.
    773           *
    774           * @param       device - [in] ZDO_RequestKeyInd_t, request info
    775           *
    776           * @return      none
    777           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    778          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
    779          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    780            APSME_TransportKeyReq_t req;
    781            uint8                   initExtAddr[Z_EXTADDR_LEN];
    782            uint16                  partNwkAddr;
    783            uint8                   key[SEC_KEY_LEN];
    784          
    785          
    786            // validate initiator and partner
    787            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
    788                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   EE           MOV     A,R6
   \   00000F   2405         ADD     A,#0x5
   \   000011   F5..         MOV     ?V0,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F5..         MOV     ?V1,A
   \   000017                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000017   AC..         MOV     R4,?XSP + 0
   \   000019   AD..         MOV     R5,?XSP + 1
   \   00001B   AA..         MOV     R2,?V0
   \   00001D   FB           MOV     R3,A
   \   00001E   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000021   E9           MOV     A,R1
   \   000022   6401         XRL     A,#0x1
   \   000024   6003         JZ      $+5
   \   000026   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000029   EE           MOV     A,R6
   \   00002A   2402         ADD     A,#0x2
   \   00002C   E4           CLR     A
   \   00002D   3F           ADDC    A,R7
   \   00002E   0E           INC     R6
   \   00002F   0E           INC     R6
   \   000030   FF           MOV     R7,A
   \   000031                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000031   740F         MOV     A,#0xf
   \   000033   12....       LCALL   ?XSTACK_DISP102_8
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   00003D   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   000040   E9           MOV     A,R1
   \   000041   6401         XRL     A,#0x1
   \   000043   6003         JZ      $+5
   \   000045   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
    789            {
    790              // point the key to some memory
    791              req.key = key;
   \   000048   7417         MOV     A,#0x17
   \   00004A   12....       LCALL   ?XSTACK_DISP100_8
   \   00004D   7406         MOV     A,#0x6
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    792          
    793              // get an APP key - option APP (MASTER or LINK) key
    794              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
    795                                      initExtAddr,
    796                                      partNwkAddr,
    797                                      ind->partExtAddr,
    798                                      &req.key,
    799                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_142:
   \   000055                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   8582..       MOV     ?V2,DPL
   \   00005D   8583..       MOV     ?V3,DPH
   \   000060   78..         MOV     R0,#?V2
   \   000062   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000065   7408         MOV     A,#0x8
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   8582..       MOV     ?V2,DPL
   \   00006D   8583..       MOV     ?V3,DPH
   \   000070   78..         MOV     R0,#?V2
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   78..         MOV     R0,#?V0
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   7406         MOV     A,#0x6
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000082   7417         MOV     A,#0x17
   \   000084   12....       LCALL   ?XSTACK_DISP102_8
   \   000087   8E82         MOV     DPL,R6
   \   000089   8F83         MOV     DPH,R7
   \   00008B   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   00008E   12....       LCALL   `??ZDSecMgrAppKeyGet::?relay`; Banked call to: ZDSecMgrAppKeyGet
   \   000091   7408         MOV     A,#0x8
   \   000093   12....       LCALL   ?DEALLOC_XSTACK8
   \   000096   E9           MOV     A,R1
   \   000097   7076         JNZ     ??ZDSecMgrAppKeyReq_0
    800              {
    801                // always secure
    802                req.nwkSecure = TRUE;
   \   000099   740C         MOV     A,#0xc
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   7401         MOV     A,#0x1
   \   0000A0   F0           MOVX    @DPTR,A
    803                req.apsSecure = TRUE;
   \   0000A1   740B         MOV     A,#0xb
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   7401         MOV     A,#0x1
   \   0000A8   F0           MOVX    @DPTR,A
    804                req.tunnel    = NULL;
   \   0000A9   740D         MOV     A,#0xd
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   12....       LCALL   ?Subroutine15 & 0xFFFF
    805          
    806                // send key to initiator device
    807                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_2:
   \   0000B1   7402         MOV     A,#0x2
   \   0000B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B6   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    808                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_143:
   \   0000B9   7408         MOV     A,#0x8
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   E5..         MOV     A,?V0
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   E5..         MOV     A,?V1
   \   0000C4   F0           MOVX    @DPTR,A
    809                req.initiator = TRUE;
   \   0000C5   740A         MOV     A,#0xa
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   7401         MOV     A,#0x1
   \   0000CC   F0           MOVX    @DPTR,A
    810                APSME_TransportKeyReq( &req );
   \   0000CD                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000CD   04           INC     A
   \   0000CE   12....       LCALL   ?XSTACK_DISP101_8
   \   0000D1   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
    811          
    812                // send key to partner device
    813                req.dstAddr   = partNwkAddr;
   \   0000D4   85..82       MOV     DPL,?XSP + 0
   \   0000D7   85..83       MOV     DPH,?XSP + 1
   \   0000DA   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   0000DD   7402         MOV     A,#0x2
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    814                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_144:
   \   0000E5   740F         MOV     A,#0xf
   \   0000E7   12....       LCALL   ?XSTACK_DISP100_8
   \   0000EA   7408         MOV     A,#0x8
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    815                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_145:
   \   0000F2   740A         MOV     A,#0xa
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E4           CLR     A
   \   0000F8   F0           MOVX    @DPTR,A
    816          
    817                APSME_TransportKeyReq( &req );
   \   0000F9                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000F9   7402         MOV     A,#0x2
   \   0000FB   12....       LCALL   ?XSTACK_DISP101_8
   \   0000FE   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
    818          
    819                // clear copy of key in RAM
    820                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   000101                ; Setup parameters for call to function osal_memset
   \   000101   7C10         MOV     R4,#0x10
   \   000103   7D00         MOV     R5,#0x0
   \   000105   7900         MOV     R1,#0x0
   \   000107   7417         MOV     A,#0x17
   \   000109   12....       LCALL   ?XSTACK_DISP101_8
   \   00010C   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    821          
    822              }
    823            }
    824          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   00010F   7427         MOV     A,#0x27
   \   000111   02....       LJMP    ?Subroutine3 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000006   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine77_0
   \   000003                ; // Fall through to label ??Subroutine77_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine77_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    825          
    826          /******************************************************************************
    827           * @fn          ZDSecMgrTclkReq
    828           *
    829           * @brief       Process request for TCLK.
    830           *
    831           * @param       device - [in] ZDO_RequestKeyInd_t, request info
    832           *
    833           * @return      none
    834           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    835          void ZDSecMgrTclkReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrTclkReq:
    836          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 59
   \   000005   74C5         MOV     A,#-0x3b
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    837            APSME_TransportKeyReq_t req;
    838            uint8                   initExtAddr[Z_EXTADDR_LEN];
    839            uint16                  partNwkAddr;
    840            uint8                   key[SEC_KEY_LEN];
    841            APSME_TCLKDevEntry_t    TCLKDevEntry;
    842            uint8                   found;
    843              
    844            // validate initiator and partner
    845            if ( ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) || ( ind->keyType != KEY_TYPE_APP_MASTER ) ) &&
    846                 (   APSME_LookupExtAddr( ind->srcAddr, initExtAddr )      == TRUE ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   7401         MOV     A,#0x1
   \   000010   12....       LCALL   ?XSTACK_DISP102_8
   \   000013   EE           MOV     A,R6
   \   000014   2405         ADD     A,#0x5
   \   000016   FA           MOV     R2,A
   \   000017   E4           CLR     A
   \   000018   3F           ADDC    A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   00001D   E9           MOV     A,R1
   \   00001E   6401         XRL     A,#0x1
   \   000020   6010         JZ      ??ZDSecMgrTclkReq_0
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   6402         XRL     A,#0x2
   \   00002D   7003         JNZ     $+5
   \   00002F   02....       LJMP    ??ZDSecMgrTclkReq_1 & 0xFFFF
   \                     ??ZDSecMgrTclkReq_0:
   \   000032   EE           MOV     A,R6
   \   000033   2402         ADD     A,#0x2
   \   000035   E4           CLR     A
   \   000036   3F           ADDC    A,R7
   \   000037   0E           INC     R6
   \   000038   0E           INC     R6
   \   000039   FF           MOV     R7,A
   \   00003A                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00003A   7410         MOV     A,#0x10
   \   00003C   12....       LCALL   ?XSTACK_DISP102_8
   \   00003F   8E82         MOV     DPL,R6
   \   000041   8F83         MOV     DPH,R7
   \   000043   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000046   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   000049   E9           MOV     A,R1
   \   00004A   6401         XRL     A,#0x1
   \   00004C   6003         JZ      $+5
   \   00004E   02....       LJMP    ??ZDSecMgrTclkReq_1 & 0xFFFF
    847            {
    848              // point the key to some memory
    849              req.key = key;
   \   000051   742B         MOV     A,#0x2b
   \   000053   12....       LCALL   ?XSTACK_DISP100_8
   \   000056   7407         MOV     A,#0x7
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    850          
    851              //Search for the entry
    852              APSME_SearchTCLinkKeyEntry(initExtAddr,&found, &TCLKDevEntry);
   \                     ??CrossCallReturnLabel_146:
   \   00005E                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   00005E   7418         MOV     A,#0x18
   \   000060   12....       LCALL   ?XSTACK_DISP100_8
   \   000063   88..         MOV     ?V0,R0
   \   000065   89..         MOV     ?V1,R1
   \   000067   78..         MOV     R0,#?V0
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   7402         MOV     A,#0x2
   \   00006E   12....       LCALL   ?XSTACK_DISP102_8
   \   000071   7412         MOV     A,#0x12
   \   000073   12....       LCALL   ?XSTACK_DISP101_8
   \   000076   12....       LCALL   `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
    853          
    854              //If found, generate the key accordingly to the key attribute
    855              if(found)
   \   00007E   85..82       MOV     DPL,?XSP + 0
   \   000081   85..83       MOV     DPH,?XSP + 1
   \   000084   E0           MOVX    A,@DPTR
   \   000085   606B         JZ      ??ZDSecMgrTclkReq_1
    856              {
    857                //Generate key from the seed, which would be the unique key
    858                ZDSecMgrGenerateKeyFromSeed(TCLKDevEntry.extAddr,TCLKDevEntry.SeedShift_IcIndex,req.key);
   \   000087                ; Setup parameters for call to function ZDSecMgrGenerateKeyFromSeed
   \   000087   7407         MOV     A,#0x7
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00008F   742A         MOV     A,#0x2a
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   E0           MOVX    A,@DPTR
   \   000095   F9           MOV     R1,A
   \   000096   7420         MOV     A,#0x20
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   AA82         MOV     R2,DPL
   \   00009D   AB83         MOV     R3,DPH
   \   00009F   12....       LCALL   `??ZDSecMgrGenerateKeyFromSeed::?relay`; Banked call to: ZDSecMgrGenerateKeyFromSeed
    859              
    860                // always secure
    861                req.nwkSecure = TRUE;
   \   0000A2   740D         MOV     A,#0xd
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   7401         MOV     A,#0x1
   \   0000A9   F0           MOVX    @DPTR,A
    862                req.apsSecure = TRUE;
   \   0000AA   740C         MOV     A,#0xc
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   7401         MOV     A,#0x1
   \   0000B1   F0           MOVX    @DPTR,A
    863                req.tunnel    = NULL;
   \   0000B2   740E         MOV     A,#0xe
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   12....       LCALL   ?Subroutine15 & 0xFFFF
    864          
    865                // send key to initiator device
    866                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_3:
   \   0000BA   7403         MOV     A,#0x3
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    867                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_147:
   \   0000C2   7410         MOV     A,#0x10
   \   0000C4   12....       LCALL   ?XSTACK_DISP100_8
   \   0000C7   7409         MOV     A,#0x9
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   12....       LCALL   ?Subroutine21 & 0xFFFF
    868                req.initiator = TRUE;
   \                     ??CrossCallReturnLabel_14:
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   7401         MOV     A,#0x1
   \   0000D4   F0           MOVX    @DPTR,A
    869                req.keyType   = KEY_TYPE_TC_LINK;
   \   0000D5   7405         MOV     A,#0x5
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   7404         MOV     A,#0x4
   \   0000DC   F0           MOVX    @DPTR,A
    870                  
    871                APSME_TransportKeyReq( &req );
   \   0000DD                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000DD   14           DEC     A
   \   0000DE   12....       LCALL   ?XSTACK_DISP101_8
   \   0000E1   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
    872                  
    873                // clear copy of key in RAM
    874                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   0000E4                ; Setup parameters for call to function osal_memset
   \   0000E4   7C10         MOV     R4,#0x10
   \   0000E6   7D00         MOV     R5,#0x0
   \   0000E8   7900         MOV     R1,#0x0
   \   0000EA   742B         MOV     A,#0x2b
   \   0000EC   12....       LCALL   ?XSTACK_DISP101_8
   \   0000EF   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    875              
    876              }
    877            }
    878          }
   \                     ??ZDSecMgrTclkReq_1:
   \   0000F2   743B         MOV     A,#0x3b
   \   0000F4   02....       LJMP    ??Subroutine71_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function APSME_GetRequest
   \   000005   740B         MOV     A,#0xb
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine71_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine72_0
   \   000003                ; // Fall through to label ??Subroutine72_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine72_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    879          
    880          /******************************************************************************
    881           * @fn          ZDSecMgrAppConfKeyReq
    882           *
    883           * @brief       Process request for APP key between two devices.
    884           *
    885           * @param       device - [in] ZDO_VerifyKeyInd_t, request info
    886           *
    887           * @return      none
    888           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    889          void ZDSecMgrAppConfKeyReq( ZDO_VerifyKeyInd_t* ind )
   \                     ZDSecMgrAppConfKeyReq:
    890          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 6
   \   000004   74FA         MOV     A,#-0x6
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    891            APSME_ConfirmKeyReq_t   req;
    892          
    893            // send key to initiator device
    894            req.dstAddr      = ind->srcAddr;
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   12....       LCALL   ?Subroutine22 & 0xFFFF
    895            req.status       = ind->verifyKeyStatus;
   \                     ??CrossCallReturnLabel_159:
   \   000012   EA           MOV     A,R2
   \   000013   241D         ADD     A,#0x1d
   \   000015   F582         MOV     DPL,A
   \   000017   E4           CLR     A
   \   000018   3B           ADDC    A,R3
   \   000019   F583         MOV     DPH,A
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   C0E0         PUSH    A
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   D0E0         POP     A
   \   000025   F0           MOVX    @DPTR,A
    896            req.dstExtAddr   = ind->extAddr;
   \   000026   EA           MOV     A,R2
   \   000027   2405         ADD     A,#0x5
   \   000029   F8           MOV     R0,A
   \   00002A   E4           CLR     A
   \   00002B   3B           ADDC    A,R3
   \   00002C   F9           MOV     R1,A
   \   00002D   7403         MOV     A,#0x3
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   12....       LCALL   ?Subroutine17 & 0xFFFF
    897            req.keyType      = ind->keyType;
   \                     ??CrossCallReturnLabel_95:
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   C0E0         PUSH    A
   \   00003A   7405         MOV     A,#0x5
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   D0E0         POP     A
   \   000041   12....       LCALL   ??Subroutine74_0 & 0xFFFF
    898          
    899            if ( ( ZSTACK_DEVICE_BUILD & DEVICE_BUILD_COORDINATOR ) != 0 )
    900            {
    901              APSME_ConfirmKeyReq( &req );
   \                     ??CrossCallReturnLabel_188:
   \   000044   12....       LCALL   `??APSME_ConfirmKeyReq::?relay`; Banked call to: APSME_ConfirmKeyReq
    902            }
    903            
    904          }
   \   000047   7406         MOV     A,#0x6
   \   000049                REQUIRE ?Subroutine9
   \   000049                ; // Fall through to label ?Subroutine9

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine63_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004                REQUIRE ??Subroutine59_0
   \   000004                ; // Fall through to label ??Subroutine59_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009                REQUIRE ??Subroutine64_0
   \   000009                ; // Fall through to label ??Subroutine64_0
    905          
    906          
    907          /******************************************************************************
    908           * @fn          ZDSecMgrSendNwkKey
    909           *
    910           * @brief       Send NWK key to device joining network.
    911           *
    912           * @param       device - [in] ZDSecMgrDevice_t, device info
    913           *
    914           * @return      ZStatus_t
    915           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    916          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
    917          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 34
   \   000005   74DE         MOV     A,#-0x22
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    918            ZStatus_t status;
    919            APSME_TransportKeyReq_t req;
    920            APSDE_FrameTunnel_t tunnel;
    921            nwkKeyDesc tmpKey;
    922          
    923            req.dstAddr   = device->nwkAddr;
   \   00000E   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000011   7404         MOV     A,#0x4
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    924            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_148:
   \   000019   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00001C   8882         MOV     DPL,R0
   \   00001E   F583         MOV     DPH,A
   \   000020   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000023   740A         MOV     A,#0xa
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    925          
    926            req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_149:
   \   00002B   7406         MOV     A,#0x6
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   7401         MOV     A,#0x1
   \   000032   F0           MOVX    @DPTR,A
    927          
    928            // get the Active Key into a local variable
    929            if ( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
    930                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   000033                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   000033   75..3A       MOV     ?V2,#0x3a
   \   000036   75..00       MOV     ?V3,#0x0
   \   000039   78..         MOV     R0,#?V2
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   7413         MOV     A,#0x13
   \   000040   12....       LCALL   ?XSTACK_DISP100_8
   \   000043   88..         MOV     ?V2,R0
   \   000045   89..         MOV     ?V3,R1
   \   000047   78..         MOV     R0,#?V2
   \   000049   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004C   7C11         MOV     R4,#0x11
   \   00004E   7D00         MOV     R5,#0x0
   \   000050   7A00         MOV     R2,#0x0
   \   000052   7B00         MOV     R3,#0x0
   \   000054   12....       LCALL   `??NLME_ReadNwkKeyInfo::?relay`; Banked call to: NLME_ReadNwkKeyInfo
   \   000057   7404         MOV     A,#0x4
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   E9           MOV     A,R1
   \   00005D   600D         JZ      ??ZDSecMgrSendNwkKey_0
    931            {
    932              // set key data to all 0s if NV read fails
    933              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   00005F                ; Setup parameters for call to function osal_memset
   \   00005F   7C11         MOV     R4,#0x11
   \   000061   7D00         MOV     R5,#0x0
   \   000063   7900         MOV     R1,#0x0
   \   000065   EC           MOV     A,R4
   \   000066   12....       LCALL   ?XSTACK_DISP101_8
   \   000069   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    934            }
    935          
    936            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
    937            {
    938              // set values
    939              req.keySeqNum = tmpKey.keySeqNum;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   00006C   7411         MOV     A,#0x11
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   E0           MOVX    A,@DPTR
   \   000072   C0E0         PUSH    A
   \   000074   7407         MOV     A,#0x7
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   D0E0         POP     A
   \   00007B   F0           MOVX    @DPTR,A
    940              req.key       = tmpKey.key;
   \   00007C   7412         MOV     A,#0x12
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   A882         MOV     R0,DPL
   \   000083   A983         MOV     R1,DPH
   \   000085   7408         MOV     A,#0x8
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    941          
    942              //devtag.pro.security.todo - make sure that if there is no link key the NWK
    943              //key isn't used to secure the frame at the APS layer -- since the receiving
    944              //device may not have a NWK key yet
    945              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_150:
   \   00008D   740D         MOV     A,#0xd
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   7401         MOV     A,#0x1
   \   000094   F0           MOVX    @DPTR,A
    946          
    947              // check if using secure hop to parent
    948              if ( device->parentAddr == NLME_GetShortAddr() )
   \   000095                ; Setup parameters for call to function NLME_GetShortAddr
   \   000095   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000098   EE           MOV     A,R6
   \   000099   2404         ADD     A,#0x4
   \   00009B   F8           MOV     R0,A
   \   00009C   E4           CLR     A
   \   00009D   3F           ADDC    A,R7
   \   00009E   F9           MOV     R1,A
   \   00009F   8882         MOV     DPL,R0
   \   0000A1   8983         MOV     DPH,R1
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   6A           XRL     A,R2
   \   0000A5   7003         JNZ     ??ZDSecMgrSendNwkKey_1
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   6B           XRL     A,R3
   \                     ??ZDSecMgrSendNwkKey_1:
   \   0000AA   7011         JNZ     ??ZDSecMgrSendNwkKey_2
    949              {
    950                req.nwkSecure = FALSE;
   \   0000AC   740E         MOV     A,#0xe
   \   0000AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B1   E4           CLR     A
   \   0000B2   F0           MOVX    @DPTR,A
    951                req.tunnel    = NULL;
   \   0000B3   740F         MOV     A,#0xf
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   E4           CLR     A
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   802C         SJMP    ??ZDSecMgrSendNwkKey_3
    952              }
    953              else
    954              {
    955                req.nwkSecure   = TRUE;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000BD   740E         MOV     A,#0xe
   \   0000BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C2   7401         MOV     A,#0x1
   \   0000C4   F0           MOVX    @DPTR,A
    956                req.tunnel      = &tunnel;
   \   0000C5   740F         MOV     A,#0xf
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   E5..         MOV     A,?XSP + 0
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   E5..         MOV     A,?XSP + 1
   \   0000D0   12....       LCALL   ?Subroutine18 & 0xFFFF
    957                req.tunnel->tna = device->parentAddr;
    958                req.tunnel->dea = device->extAddr;
    959              }
    960            }
   \                     ??CrossCallReturnLabel_6:
   \   0000D3   85..82       MOV     DPL,?XSP + 0
   \   0000D6   85..83       MOV     DPH,?XSP + 1
   \   0000D9   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000DC   F8           MOV     R0,A
   \   0000DD   A3           INC     DPTR
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   F9           MOV     R1,A
   \   0000E0   7402         MOV     A,#0x2
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   E8           MOV     A,R0
   \   0000E6   F0           MOVX    @DPTR,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   E9           MOV     A,R1
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000E9   F0           MOVX    @DPTR,A
    961            else
    962            {
    963              // default values
    964              //devtag.0604.verify
    965              req.nwkSecure = TRUE;
    966              req.apsSecure = FALSE;
    967              req.tunnel    = NULL;
    968          
    969              if ( device->parentAddr != NLME_GetShortAddr() )
    970              {
    971                req.dstAddr = device->parentAddr;
    972              }
    973          
    974              // send the real key
    975              if ( zgPreConfigKeys == FALSE )
    976              {
    977                req.keySeqNum = tmpKey.keySeqNum;
    978                req.key       = tmpKey.key;
    979          
    980                // check if using secure hop to to parent
    981                if ( device->parentAddr == NLME_GetShortAddr() )
    982                {
    983                  req.nwkSecure = FALSE;
    984                }
    985              }
    986              else
    987              {
    988                // this is to send the all zero key when the NWK key has been preconfigured
    989                req.key       = NULL;
    990                req.keySeqNum = 0;
    991              }
    992            }
    993          
    994            status = APSME_TransportKeyReq( &req );
   \   0000EA                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000EA   7404         MOV     A,#0x4
   \   0000EC   12....       LCALL   ?XSTACK_DISP101_8
   \   0000EF   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   0000F2   E9           MOV     A,R1
   \   0000F3   FE           MOV     R6,A
    995          
    996            // clear copy of key in RAM before return
    997            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   0000F4                ; Setup parameters for call to function osal_memset
   \   0000F4   7C11         MOV     R4,#0x11
   \   0000F6   7D00         MOV     R5,#0x0
   \   0000F8   7900         MOV     R1,#0x0
   \   0000FA   EC           MOV     A,R4
   \   0000FB   12....       LCALL   ?XSTACK_DISP101_8
   \   0000FE   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    998          
    999            return status;
   \   000101   EE           MOV     A,R6
   \   000102   F9           MOV     R1,A
   \   000103   7422         MOV     A,#0x22
   \   000105   02....       LJMP    ?Subroutine3 & 0xFFFF
   1000          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function osal_memcpy
   \   000005   85..82       MOV     DPL,?V0
   \   000008   85..83       MOV     DPH,?V1
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine62_0
   \   000004                ; // Fall through to label ??Subroutine62_0
   1001          
   1002          /******************************************************************************
   1003           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1004           *
   1005           * @brief       Remove device entry by its ext address.
   1006           *
   1007           * @param       pAddr - pointer to the extended address
   1008           *
   1009           * @return      ZStatus_t
   1010           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1011          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1012          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1013            ZDSecMgrEntry_t *pEntry;
   1014            uint8           retValue;
   1015          
   1016            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000A                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000A   AC..         MOV     R4,?XSP + 0
   \   00000C   AD..         MOV     R5,?XSP + 1
   \   00000E   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000011   E9           MOV     A,R1
   \   000012   FE           MOV     R6,A
   1017          
   1018            if( retValue == ZSuccess )
   \   000013   700C         JNZ     ??ZDSecMgrDeviceRemoveByExtAddr_0
   1019            {
   1020              // remove device from entry data
   1021              ZDSecMgrEntryFree( pEntry );
   \   000015                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   1022            }
   \                     ??CrossCallReturnLabel_106:
   \   00001E   12....       LCALL   `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
   1023          
   1024            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   000021   EE           MOV     A,R6
   \   000022   F9           MOV     R1,A
   \   000023                REQUIRE ?Subroutine7
   \   000023                ; // Fall through to label ?Subroutine7
   1025          }
   1026          
   1027          /******************************************************************************
   1028           * @fn          ZDSecMgrDeviceRemove
   1029           *
   1030           * @brief       Remove device from network.
   1031           *
   1032           * @param       device - [in] ZDSecMgrDevice_t, device info
   1033           *
   1034           * @return      none
   1035           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1036          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1037          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 19
   \   000005   74ED         MOV     A,#-0x13
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1038            APSME_RemoveDeviceReq_t remDevReq;
   1039            NLME_LeaveReq_t         leaveReq;
   1040            associated_devices_t*   assoc;
   1041            uint8 TC_ExtAddr[Z_EXTADDR_LEN];
   1042          
   1043            // check if parent, remove the device
   1044            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000011   8A..         MOV     ?V0,R2
   \   000013   8B..         MOV     ?V1,R3
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   12....       LCALL   ??Subroutine60_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   00001E   EE           MOV     A,R6
   \   00001F   2402         ADD     A,#0x2
   \   000021   F8           MOV     R0,A
   \   000022   E4           CLR     A
   \   000023   3F           ADDC    A,R7
   \   000024   F9           MOV     R1,A
   \   000025   E5..         MOV     A,?V0
   \   000027   6A           XRL     A,R2
   \   000028   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   00002A   E5..         MOV     A,?V1
   \   00002C   6B           XRL     A,R3
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00002D   6003         JZ      $+5
   \   00002F   02....       LJMP    ??ZDSecMgrDeviceRemove_1 & 0xFFFF
   1045            {
   1046              // this is the parent of the device
   1047              leaveReq.extAddr        = device->extAddr;
   \   000032   8882         MOV     DPL,R0
   \   000034   8983         MOV     DPH,R1
   \   000036   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000039   7401         MOV     A,#0x1
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   12....       LCALL   ?Subroutine19 & 0xFFFF
   1048              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_10:
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E4           CLR     A
   \   000045   F0           MOVX    @DPTR,A
   1049              leaveReq.rejoin         = FALSE;
   \   000046   7404         MOV     A,#0x4
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   E4           CLR     A
   \   00004C   F0           MOVX    @DPTR,A
   1050          
   1051              // find child association
   1052              assoc = AssocGetWithExt( device->extAddr );
   \   00004D                ; Setup parameters for call to function AssocGetWithExt
   \   00004D   8882         MOV     DPL,R0
   \   00004F   8983         MOV     DPH,R1
   \   000051   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000054   12....       LCALL   `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000057   8A..         MOV     ?V0,R2
   \   000059   8B..         MOV     ?V1,R3
   \   00005B   A8..         MOV     R0,?V0
   \   00005D   A9..         MOV     R1,?V1
   1053          
   1054              if ( ( assoc != NULL                            ) &&
   1055                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1056                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   00005F   E8           MOV     A,R0
   \   000060   49           ORL     A,R1
   \   000061   6030         JZ      ??ZDSecMgrDeviceRemove_2
   \   000063   8882         MOV     DPL,R0
   \   000065   8983         MOV     DPH,R1
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6025         JZ      ??ZDSecMgrDeviceRemove_2
   \   00006E   C3           CLR     C
   \   00006F   9405         SUBB    A,#0x5
   \   000071   5020         JNC     ??ZDSecMgrDeviceRemove_2
   1057              {
   1058                // check if associated device is authenticated
   1059                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000073   8882         MOV     DPL,R0
   \   000075   8983         MOV     DPH,R1
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   A2E3         MOV     C,0xE0 /* A   */.3
   \   00007F   7405         MOV     A,#0x5
   \   000081   5006         JNC     ??ZDSecMgrDeviceRemove_3
   1060                {
   1061                  leaveReq.silent = FALSE;
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   E4           CLR     A
   \   000087   8005         SJMP    ??ZDSecMgrDeviceRemove_4
   1062                }
   1063                else
   1064                {
   1065                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceRemove_4:
   \   00008E   F0           MOVX    @DPTR,A
   1066                }
   1067          
   1068                NLME_LeaveReq( &leaveReq );
   \   00008F                ; Setup parameters for call to function NLME_LeaveReq
   \   00008F   7401         MOV     A,#0x1
   \   000091   802C         SJMP    ??ZDSecMgrDeviceRemove_5
   1069              }
   1070              else if ( device->nwkAddr == NLME_GetShortAddr() )
   \                     ??ZDSecMgrDeviceRemove_2:
   \   000093                ; Setup parameters for call to function NLME_GetShortAddr
   \   000093   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000096   8A..         MOV     ?V0,R2
   \   000098   8B..         MOV     ?V1,R3
   \   00009A   A8..         MOV     R0,?V0
   \   00009C   A9..         MOV     R1,?V1
   \   00009E   8E82         MOV     DPL,R6
   \   0000A0   8F83         MOV     DPH,R7
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   68           XRL     A,R0
   \   0000A4   7003         JNZ     ??ZDSecMgrDeviceRemove_6
   \   0000A6   A3           INC     DPTR
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   69           XRL     A,R1
   \                     ??ZDSecMgrDeviceRemove_6:
   \   0000A9   6003         JZ      $+5
   \   0000AB   02....       LJMP    ??ZDSecMgrDeviceRemove_7 & 0xFFFF
   1071              {
   1072                // this is when ZC wants that ZR removes itself from the network
   1073                leaveReq.extAddr = NULL;
   \   0000AE   7401         MOV     A,#0x1
   \   0000B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B3   E4           CLR     A
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   F0           MOVX    @DPTR,A
   1074                leaveReq.silent = FALSE;
   \   0000B7   7405         MOV     A,#0x5
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   E4           CLR     A
   \   0000BD   F0           MOVX    @DPTR,A
   1075          
   1076                NLME_LeaveReq( &leaveReq );
   \   0000BE                ; Setup parameters for call to function NLME_LeaveReq
   \   0000BE   04           INC     A
   \                     ??ZDSecMgrDeviceRemove_5:
   \   0000BF   12....       LCALL   ?XSTACK_DISP101_8
   \   0000C2   12....       LCALL   `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   0000C5   806C         SJMP    ??ZDSecMgrDeviceRemove_7
   1077              }
   1078            }
   1079            else
   1080            {
   1081              // this is not the parent of the device
   1082              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   0000C7   7406         MOV     A,#0x6
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   EA           MOV     A,R2
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   EB           MOV     A,R3
   \   0000D0   12....       LCALL   ?Subroutine18 & 0xFFFF
   1083              remDevReq.childExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_7:
   \   0000D3   7408         MOV     A,#0x8
   \   0000D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D8   12....       LCALL   ?Subroutine21 & 0xFFFF
   1084          
   1085              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1086              {
   1087                uint8 found;
   1088                APSME_GetRequest( apsTrustCenterAddress,0, TC_ExtAddr );
   \                     ??CrossCallReturnLabel_15:
   \   0000DB   12....       LCALL   ?XSTACK_DISP102_8
   \   0000DE   7A00         MOV     R2,#0x0
   \   0000E0   7B00         MOV     R3,#0x0
   \   0000E2   79AB         MOV     R1,#-0x55
   \   0000E4   12....       LCALL   `??APSME_GetRequest::?relay`; Banked call to: APSME_GetRequest
   1089                
   1090                APSME_SearchTCLinkKeyEntry(TC_ExtAddr,&found,NULL);
   \   0000E7                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   0000E7   E4           CLR     A
   \   0000E8   F5..         MOV     ?V0,A
   \   0000EA   F5..         MOV     ?V1,A
   \   0000EC   78..         MOV     R0,#?V0
   \   0000EE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F1   7402         MOV     A,#0x2
   \   0000F3   12....       LCALL   ?XSTACK_DISP102_8
   \   0000F6   740D         MOV     A,#0xd
   \   0000F8   12....       LCALL   ?XSTACK_DISP101_8
   \   0000FB   12....       LCALL   `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   0000FE   7402         MOV     A,#0x2
   \   000100   12....       LCALL   ?DEALLOC_XSTACK8
   1091                
   1092                // For ZG_GLOBAL_LINK_KEY the message has to be sent twice, one
   1093                // APS un-encrypted and one APS encrypted, to make sure that it can interoperate
   1094                // with legacy Coordinator devices which can only handle one or the other.
   1095          #if defined ( APP_TP2_TEST_MODE )
   1096                if ( ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY ) && ( found == FALSE ) && ( guTxApsSecON != TRUE ) )
   1097          #else
   1098                if ( ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY ) && ( found == FALSE ) )
   \   000103   90....       MOV     DPTR,#zgApsLinkKeyType
   \   000106   E0           MOVX    A,@DPTR
   \   000107   6401         XRL     A,#0x1
   \   000109   7018         JNZ     ??ZDSecMgrDeviceRemove_8
   \   00010B   85..82       MOV     DPL,?XSP + 0
   \   00010E   85..83       MOV     DPH,?XSP + 1
   \   000111   E0           MOVX    A,@DPTR
   \   000112   700F         JNZ     ??ZDSecMgrDeviceRemove_8
   1099          #endif
   1100                {
   1101                  remDevReq.apsSecure = FALSE;
   \   000114   740A         MOV     A,#0xa
   \   000116   12....       LCALL   ?XSTACK_DISP0_8
   \   000119   E4           CLR     A
   \   00011A   F0           MOVX    @DPTR,A
   1102          
   1103                  APSME_RemoveDeviceReq( &remDevReq );
   \   00011B                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   00011B   7406         MOV     A,#0x6
   \   00011D   12....       LCALL   ?XSTACK_DISP101_8
   \   000120   12....       LCALL   `??APSME_RemoveDeviceReq::?relay`; Banked call to: APSME_RemoveDeviceReq
   1104                }
   1105          
   1106          #if defined ( APP_TP2_TEST_MODE )
   1107                if ( guTxApsSecON != FALSE )
   1108                {
   1109                  remDevReq.apsSecure = TRUE;
   1110          
   1111                  APSME_RemoveDeviceReq( &remDevReq );
   1112                }
   1113          #else
   1114                remDevReq.apsSecure = TRUE;
   \                     ??ZDSecMgrDeviceRemove_8:
   \   000123   740A         MOV     A,#0xa
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   7401         MOV     A,#0x1
   \   00012A   F0           MOVX    @DPTR,A
   1115          
   1116                APSME_RemoveDeviceReq( &remDevReq );
   \   00012B                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   00012B   7406         MOV     A,#0x6
   \   00012D   12....       LCALL   ?XSTACK_DISP101_8
   \   000130   12....       LCALL   `??APSME_RemoveDeviceReq::?relay`; Banked call to: APSME_RemoveDeviceReq
   1117          #endif
   1118              }
   1119              else
   1120              {
   1121                remDevReq.apsSecure = FALSE;
   1122          
   1123                APSME_RemoveDeviceReq( &remDevReq );
   1124              }
   1125            }
   1126          }
   \                     ??ZDSecMgrDeviceRemove_7:
   \   000133   7413         MOV     A,#0x13
   \   000135   02....       LJMP    ??Subroutine71_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine60_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine61_0
   \   000002                ; // Fall through to label ??Subroutine61_0
   1127          
   1128          /******************************************************************************
   1129           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1130           *
   1131           * @brief       Decide whether device is allowed.
   1132           *
   1133           * @param       device - [in] ZDSecMgrDevice_t, device info
   1134           *
   1135           * @return      ZStatus_t
   1136           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1137          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1138          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1139            ZStatus_t status;
   1140          
   1141            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1142          
   1143            (void)device;  // Intentionally unreferenced parameter
   1144          
   1145            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1146            // the trust center to reject any newly joining devices by sending
   1147            // Remove-device to the parents.
   1148            if ( zgSecurePermitJoin == FALSE )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1149            {
   1150              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1151            }
   1152          
   1153          
   1154          
   1155          #if 0  // Taken out because the following functionality is only used for test
   1156                 // purpose. A more efficient (above) way is used. It can be put
   1157                 // back in if customers request for a white/black list feature.
   1158                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1159          
   1160            // The following code processes the device black list (stored device list)
   1161            // If the joining device is not part of the forbidden device list
   1162            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1163            // will send Remove-device and ban the device from joining.
   1164          
   1165            uint8     index;
   1166            uint8*    restricted;
   1167          
   1168            // Look through the stored device list - used for restricted devices
   1169            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1170            {
   1171              restricted = ZDSecMgrStoredDeviceList[index];
   1172          
   1173              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1174              {
   1175                // return as unknown device in regards to validation
   1176                status = ZNwkUnknownDevice;
   1177          
   1178                // break from loop
   1179                index = ZDSECMGR_STORED_DEVICES;
   1180              }
   1181            }
   1182          
   1183          #endif
   1184          
   1185            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP    ??Subroutine63_0 & 0xFFFF
   1186          }
   1187          
   1188          /******************************************************************************
   1189           * @fn          ZDSecMgrDeviceValidate
   1190           *
   1191           * @brief       Decide whether device is allowed.
   1192           *
   1193           * @param       device - [in] ZDSecMgrDevice_t, device info
   1194           *
   1195           * @return      ZStatus_t
   1196           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1197          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1198          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1199            ZStatus_t status;
   1200          
   1201            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7007         JNZ     ??ZDSecMgrDeviceValidate_0
   1202            {
   1203              status = ZDSecMgrDeviceValidateRM( device );
   \   00000C                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   00000C   12....       LCALL   `??ZDSecMgrDeviceValidateRM::?relay`; Banked call to: ZDSecMgrDeviceValidateRM
   \   00000F   E9           MOV     A,R1
   \   000010   F9           MOV     R1,A
   \   000011   8002         SJMP    ??ZDSecMgrDeviceValidate_1
   1204            }
   1205            else
   1206            {
   1207              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   000013   79C8         MOV     R1,#-0x38
   1208            }
   1209          
   1210            return status;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000015   02....       LJMP    ??Subroutine63_0 & 0xFFFF
   1211          }
   1212          
   1213          /******************************************************************************
   1214           * @fn          ZDSecMgrDeviceJoin
   1215           *
   1216           * @brief       Try to join this device.
   1217           *
   1218           * @param       device - [in] ZDSecMgrDevice_t, device info
   1219           *
   1220           * @return      ZStatus_t
   1221           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1222          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   1223          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1224            ZStatus_t status = ZSuccess;
   \   00000E   75..00       MOV     ?V4,#0x0
   1225            uint16    ami;
   1226          
   1227            // attempt to validate device that joined/rejoined without security
   1228            if ( device->secure == FALSE )
   \   000011   EE           MOV     A,R6
   \   000012   2402         ADD     A,#0x2
   \   000014   F5..         MOV     ?V0,A
   \   000016   E4           CLR     A
   \   000017   3F           ADDC    A,R7
   \   000018   F5..         MOV     ?V1,A
   \   00001A   EE           MOV     A,R6
   \   00001B   2406         ADD     A,#0x6
   \   00001D   F8           MOV     R0,A
   \   00001E   E4           CLR     A
   \   00001F   3F           ADDC    A,R7
   \   000020   F9           MOV     R1,A
   \   000021   88..         MOV     ?V2,R0
   \   000023   89..         MOV     ?V3,R1
   \   000025   8882         MOV     DPL,R0
   \   000027   F583         MOV     DPH,A
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   7008         JNZ     ??ZDSecMgrDeviceJoin_0
   1229            {
   1230              status = ZDSecMgrDeviceValidate( device );
   \   00002C                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00002C   12....       LCALL   `??ZDSecMgrDeviceValidate::?relay`; Banked call to: ZDSecMgrDeviceValidate
   \   00002F   E9           MOV     A,R1
   \   000030   F5..         MOV     ?V4,A
   1231            }
   1232          
   1233            if ( status == ZSuccess )
   \   000032   7058         JNZ     ??ZDSecMgrDeviceJoin_1
   1234            {
   1235              // Add the device to the address manager
   1236              ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000034                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000034   A8..         MOV     R0,?XSP + 0
   \   000036   A9..         MOV     R1,?XSP + 1
   \   000038   88..         MOV     ?V6,R0
   \   00003A   89..         MOV     ?V7,R1
   \   00003C   78..         MOV     R0,#?V6
   \   00003E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000041   85..82       MOV     DPL,?V0
   \   000044   85..83       MOV     DPH,?V1
   \   000047   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00004A   8E82         MOV     DPL,R6
   \   00004C   8F83         MOV     DPH,R7
   \   00004E   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000051   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000054   7402         MOV     A,#0x2
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
   1237          
   1238              // Only send the key to devices that have not been authenticated
   1239              if ( ( device->devStatus & DEV_SEC_INIT_STATUS ) &&
   1240                   ( device->secure == FALSE ) )
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   A2E2         MOV     C,0xE0 /* A   */.2
   \   000067   5023         JNC     ??ZDSecMgrDeviceJoin_1
   \   000069   85..82       MOV     DPL,?V2
   \   00006C   85..83       MOV     DPH,?V3
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   701A         JNZ     ??ZDSecMgrDeviceJoin_1
   1241              {
   1242                //send the nwk key data to the joining device
   1243                status = ZDSecMgrSendNwkKey( device );
   \   000072                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000072   EE           MOV     A,R6
   \   000073   FA           MOV     R2,A
   \   000074   EF           MOV     A,R7
   \   000075   FB           MOV     R3,A
   \   000076   12....       LCALL   `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   000079   E9           MOV     A,R1
   \   00007A   F5..         MOV     ?V4,A
   1244              }
   1245          
   1246              if ( status != ZSuccess )
   \   00007C   601B         JZ      ??ZDSecMgrDeviceJoin_2
   1247              {
   1248                ZDSecMgrAddrClear( device->extAddr );
   \   00007E                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   00007E   85..82       MOV     DPL,?V0
   \   000081   85..83       MOV     DPH,?V1
   \   000084   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   1249              }
   1250            }
   \                     ??CrossCallReturnLabel_110:
   \   000087   12....       LCALL   `??ZDSecMgrAddrClear::?relay`; Banked call to: ZDSecMgrAddrClear
   \   00008A   8004         SJMP    ??ZDSecMgrDeviceJoin_3
   1251          
   1252            if ( status != ZSuccess )
   \                     ??ZDSecMgrDeviceJoin_1:
   \   00008C   E5..         MOV     A,?V4
   \   00008E   6009         JZ      ??ZDSecMgrDeviceJoin_2
   1253            {
   1254              // not allowed or transport key failed, remove the device
   1255              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_3:
   \   000090                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000090   EE           MOV     A,R6
   \   000091   FA           MOV     R2,A
   \   000092   EF           MOV     A,R7
   \   000093   FB           MOV     R3,A
   \   000094   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   \   000097   8057         SJMP    ??ZDSecMgrDeviceJoin_4
   1256            }
   1257            else
   1258            {
   1259              // Pass the Trust Center Device Indication to higher layer if callback registered
   1260              if (zdoCBFunc[ZDO_TC_DEVICE_CBID] != NULL )
   \                     ??ZDSecMgrDeviceJoin_2:
   \   000099   90....       MOV     DPTR,#zdoCBFunc + 16
   \   00009C   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   00009F   604F         JZ      ??ZDSecMgrDeviceJoin_4
   1261              {
   1262                ZDO_TC_Device_t dev;
   1263          
   1264                dev.nwkAddr = device->nwkAddr;
   \   0000A1   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   0000A4   7402         MOV     A,#0x2
   \   0000A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A9   12....       LCALL   ?Subroutine16 & 0xFFFF
   1265                osal_memcpy( dev.extAddr, device->extAddr, Z_EXTADDR_LEN );
   \                     ??CrossCallReturnLabel_5:
   \   0000AC   F5..         MOV     ?V0,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   F5..         MOV     ?V1,A
   \   0000B2   75..00       MOV     ?V2,#0x0
   \   0000B5   78..         MOV     R0,#?V0
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000BA   7C08         MOV     R4,#0x8
   \   0000BC   7D00         MOV     R5,#0x0
   \   0000BE   7407         MOV     A,#0x7
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   AA82         MOV     R2,DPL
   \   0000C5   AB83         MOV     R3,DPH
   \   0000C7   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000CA   7403         MOV     A,#0x3
   \   0000CC   12....       LCALL   ?DEALLOC_XSTACK8
   1266                dev.parentAddr = device->parentAddr;
   \   0000CF   8E82         MOV     DPL,R6
   \   0000D1   8F83         MOV     DPH,R7
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   0000DA   740C         MOV     A,#0xc
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   1267          
   1268                zdoCBFunc[ZDO_TC_DEVICE_CBID]( (void*)&dev );
   \                     ??CrossCallReturnLabel_151:
   \   0000E2                ; Setup parameters for indirect call
   \   0000E2   7402         MOV     A,#0x2
   \   0000E4   12....       LCALL   ?XSTACK_DISP101_8
   \   0000E7   90....       MOV     DPTR,#zdoCBFunc + 16
   \   0000EA   12....       LCALL   ?Subroutine36 & 0xFFFF
   1269              }
   1270            }
   \                     ??CrossCallReturnLabel_44:
   \   0000ED   12....       LCALL   ?CALL_IND
   1271          
   1272            return status;
   \                     ??ZDSecMgrDeviceJoin_4:
   \   0000F0   A9..         MOV     R1,?V4
   \   0000F2   740E         MOV     A,#0xe
   \   0000F4   02....       LJMP    ?Subroutine1 & 0xFFFF
   1273          }
   1274          
   1275          /******************************************************************************
   1276           * @fn          ZDSecMgrDeviceJoinDirect
   1277           *
   1278           * @brief       Try to join this device as a direct child.
   1279           *
   1280           * @param       device - [in] ZDSecMgrDevice_t, device info
   1281           *
   1282           * @return      ZStatus_t
   1283           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1284          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   1285          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   1286            ZStatus_t status;
   1287            
   1288            if(device->secure == FALSE)
   \   00000E   EA           MOV     A,R2
   \   00000F   2402         ADD     A,#0x2
   \   000011   F5..         MOV     ?V6,A
   \   000013   E4           CLR     A
   \   000014   35..         ADDC    A,?V3
   \   000016   F5..         MOV     ?V7,A
   \   000018   EA           MOV     A,R2
   \   000019   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00001C   85..82       MOV     DPL,?V4
   \   00001F   F583         MOV     DPH,A
   \   000021   E0           MOVX    A,@DPTR
   \   000022   6003         JZ      $+5
   \   000024   02....       LJMP    ??ZDSecMgrDeviceJoinDirect_0 & 0xFFFF
   1289            {  
   1290              uint8  found;
   1291              uint16 keyNvIndex;
   1292              APSME_TCLKDevEntry_t TCLKDevEntry;
   1293              
   1294              keyNvIndex = APSME_SearchTCLinkKeyEntry(device->extAddr,&found, &TCLKDevEntry);
   \   000027                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   000027   7401         MOV     A,#0x1
   \   000029   12....       LCALL   ?XSTACK_DISP100_8
   \   00002C   88..         MOV     ?V0,R0
   \   00002E   89..         MOV     ?V1,R1
   \   000030   78..         MOV     R0,#?V0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   7402         MOV     A,#0x2
   \   000037   12....       LCALL   ?XSTACK_DISP102_8
   \   00003A   85..82       MOV     DPL,?V6
   \   00003D   85..83       MOV     DPH,?V7
   \   000040   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000043   12....       LCALL   `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   000046   7402         MOV     A,#0x2
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   1295              
   1296              //If found and it was verified, then allow it to join in a fresh state by erasing the key entry
   1297              if((found == TRUE) && (TCLKDevEntry.keyAttributes == ZG_VERIFIED_KEY))
   \   00004B   85..82       MOV     DPL,?XSP + 0
   \   00004E   85..83       MOV     DPH,?XSP + 1
   \   000051   E0           MOVX    A,@DPTR
   \   000052   6401         XRL     A,#0x1
   \   000054   7068         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   \   000056   7411         MOV     A,#0x11
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   6402         XRL     A,#0x2
   \   00005E   705E         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   1298              {
   1299                uint8 index;
   1300                TCLKDevEntry.keyAttributes = ZG_DEFAULT_KEY;
   \   000060   74FF         MOV     A,#-0x1
   \   000062   F0           MOVX    @DPTR,A
   1301                //Increase the shift by one. Validate the maximum shift of the seed which is 15
   1302                TCLKDevEntry.SeedShift_IcIndex++;
   1303                TCLKDevEntry.SeedShift_IcIndex &= 0x0F;
   \   000063   7413         MOV     A,#0x13
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   E0           MOVX    A,@DPTR
   \   000069   04           INC     A
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   540F         ANL     A,#0xf
   \   00006D   F0           MOVX    @DPTR,A
   1304                
   1305                TCLKDevEntry.rxFrmCntr = 0;
   \   00006E   7405         MOV     A,#0x5
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   12....       LCALL   ?Subroutine13 & 0xFFFF
   1306                TCLKDevEntry.txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_198:
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   12....       LCALL   ?Subroutine27 & 0xFFFF
   1307                
   1308                index = keyNvIndex - ZCD_NV_TCLK_TABLE_START;
   \                     ??CrossCallReturnLabel_28:
   \   00007C   12....       LCALL   ?Subroutine46 & 0xFFFF
   1309                
   1310                TCLinkKeyFrmCntr[index].rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_62:
   \   00007F   F5..         MOV     ?V0,A
   \   000081   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000083   39           ADDC    A,R1
   \   000084   F5..         MOV     ?V1,A
   \   000086   85..82       MOV     DPL,?V0
   \   000089   F583         MOV     DPH,A
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   1311                TCLinkKeyFrmCntr[index].txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_176:
   \   000092   85..82       MOV     DPL,?V0
   \   000095   85..83       MOV     DPH,?V1
   \   000098   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   1312                
   1313                //Update the entry
   1314                osal_nv_write(keyNvIndex,0,sizeof(APSME_TCLKDevEntry_t), &TCLKDevEntry );
   1315              }
   1316              
   1317            }
   \                     ??CrossCallReturnLabel_200:
   \   00009B   12....       LCALL   ?XSTACK_DISP100_8
   \   00009E   88..         MOV     ?V0,R0
   \   0000A0   89..         MOV     ?V1,R1
   \   0000A2   78..         MOV     R0,#?V0
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A7   75..13       MOV     ?V0,#0x13
   \   0000AA   75..00       MOV     ?V1,#0x0
   \   0000AD   78..         MOV     R0,#?V0
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B2   7C00         MOV     R4,#0x0
   \   0000B4   7D00         MOV     R5,#0x0
   \   0000B6   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000B9   7404         MOV     A,#0x4
   \   0000BB   12....       LCALL   ?DEALLOC_XSTACK8
   1318          
   1319            status = ZDSecMgrDeviceJoin( device );
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   0000BE                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   0000BE   AA..         MOV     R2,?V2
   \   0000C0   AB..         MOV     R3,?V3
   \   0000C2   12....       LCALL   `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   \   0000C5   E9           MOV     A,R1
   \   0000C6   FE           MOV     R6,A
   1320          
   1321            if ( status == ZSuccess )
   \   0000C7   7027         JNZ     ??ZDSecMgrDeviceJoinDirect_1
   1322            {
   1323              // set association status to authenticated
   1324              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   0000C9                ; Setup parameters for call to function AssocGetWithShort
   \   0000C9   85..82       MOV     DPL,?V2
   \   0000CC   85..83       MOV     DPH,?V3
   \   0000CF   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   0000D2   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   0000D5                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   0000D5   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   1325              
   1326            #if (ZG_BUILD_COORDINATOR_TYPE)    
   1327              //Add the device as joining device, if it did join unsecured
   1328              if(device->secure == FALSE)
   \   0000D8   85..82       MOV     DPL,?V4
   \   0000DB   85..83       MOV     DPH,?V5
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   700F         JNZ     ??ZDSecMgrDeviceJoinDirect_1
   1329              {
   1330                bdb_TCAddJoiningDevice(NLME_GetShortAddr(),device->extAddr);
   \   0000E1                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000E1   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   0000E4                ; Setup parameters for call to function bdb_TCAddJoiningDevice
   \   0000E4   85..82       MOV     DPL,?V6
   \   0000E7   85..83       MOV     DPH,?V7
   \   0000EA   12....       LCALL   ?Subroutine32 & 0xFFFF
   1331              }
   1332            #endif
   1333            }
   \                     ??CrossCallReturnLabel_34:
   \   0000ED   12....       LCALL   `??bdb_TCAddJoiningDevice::?relay`; Banked call to: bdb_TCAddJoiningDevice
   1334          
   1335            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_1:
   \   0000F0   EE           MOV     A,R6
   \   0000F1   F9           MOV     R1,A
   \   0000F2   7414         MOV     A,#0x14
   \   0000F4   02....       LJMP    ?Subroutine1 & 0xFFFF
   1336          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine69_0:
   \   000000   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   E4           CLR     A
   \   000001                REQUIRE ??Subroutine70_0
   \   000001                ; // Fall through to label ??Subroutine70_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine70_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   F0           MOVX    @DPTR,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000003   EA           MOV     A,R2
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   2406         ADD     A,#0x6
   \   000002   F5..         MOV     ?V4,A
   \   000004   E4           CLR     A
   \   000005   35..         ADDC    A,?V3
   \   000007   F5..         MOV     ?V5,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   24EF         ADD     A,#-0x11
   \   000002   F8           MOV     R0,A
   \   000003   75F009       MOV     B,#0x9
   \   000006   A4           MUL     AB
   \   000007   F8           MOV     R0,A
   \   000008   A9F0         MOV     R1,B
   \   00000A   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   00000C   28           ADD     A,R0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E4           CLR     A
   \   000001                REQUIRE ??Subroutine79_0
   \   000001                ; // Fall through to label ??Subroutine79_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine79_0:
   \   000000   12....       LCALL   ??Subroutine70_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000003                ; Setup parameters for call to function osal_nv_write
   \   000003                ; Setup parameters for call to function osal_nv_write
   \   000003   04           INC     A
   \   000004   22           RET
   1337          
   1338          /******************************************************************************
   1339           * @fn          ZDSecMgrDeviceJoinFwd
   1340           *
   1341           * @brief       Forward join to Trust Center.
   1342           *
   1343           * @param       device - [in] ZDSecMgrDevice_t, device info
   1344           *
   1345           * @return      ZStatus_t
   1346           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1347          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   1348          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1349            ZStatus_t               status;
   1350            APSME_UpdateDeviceReq_t req;
   1351            uint8 TC_ExtAddr[Z_EXTADDR_LEN];
   1352          
   1353            // forward any joining device to the Trust Center -- the Trust Center will
   1354            // decide if the device is allowed to join
   1355            status = ZSuccess;
   1356          
   1357            // forward authorization to the Trust Center
   1358            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   00000A   7401         MOV     A,#0x1
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   12....       LCALL   ?Subroutine25 & 0xFFFF
   1359            req.devAddr    = device->nwkAddr;
   \                     ??CrossCallReturnLabel_19:
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   7403         MOV     A,#0x3
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   12....       LCALL   ?Subroutine17 & 0xFFFF
   1360            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_96:
   \   000021   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000024   7405         MOV     A,#0x5
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   1361          
   1362            // set security status, option for router to reject if policy set
   1363            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_152:
   \   00002C   EA           MOV     A,R2
   \   00002D   2407         ADD     A,#0x7
   \   00002F   F582         MOV     DPL,A
   \   000031   E4           CLR     A
   \   000032   3B           ADDC    A,R3
   \   000033   F583         MOV     DPH,A
   \   000035   E0           MOVX    A,@DPTR
   \   000036   A2E7         MOV     C,0xE0 /* A   */.7
   \   000038   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   1364            {
   1365              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   00003A   A2E6         MOV     C,0xE0 /* A   */.6
   \   00003C   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   1366              {
   1367                if ( device->secure == TRUE )
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   6401         XRL     A,#0x1
   \   00004B   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   1368                {
   1369                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   00004D   7407         MOV     A,#0x7
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   7404         MOV     A,#0x4
   \   000054   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1370                }
   1371                else
   1372                {
   1373                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   000056   7407         MOV     A,#0x7
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   7407         MOV     A,#0x7
   \   00005D   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1374                }
   1375              }
   1376              else
   1377              {
   1378                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   00005F   7407         MOV     A,#0x7
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   7405         MOV     A,#0x5
   \   000066   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1379              }
   1380            }
   1381            else
   1382            {
   1383              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000068   A2E6         MOV     C,0xE0 /* A   */.6
   \   00006A   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   1384              {
   1385                if ( device->secure == TRUE )
   \   00006C   8A82         MOV     DPL,R2
   \   00006E   8B83         MOV     DPH,R3
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   6401         XRL     A,#0x1
   \   000079   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   1386                {
   1387                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   00007B   7407         MOV     A,#0x7
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   E4           CLR     A
   \   000081   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1388                }
   1389                else
   1390                {
   1391                  req.status = APSME_UD_STANDARD_TRUST_CENTER_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000083   7407         MOV     A,#0x7
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   7403         MOV     A,#0x3
   \   00008A   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1392                }
   1393              }
   1394              else
   1395              {
   1396                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   00008C   7407         MOV     A,#0x7
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   7401         MOV     A,#0x1
   1397              }
   1398            }
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   000093   12....       LCALL   ?Subroutine25 & 0xFFFF
   1399          
   1400            // set association status to authenticated
   1401            ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \                     ??CrossCallReturnLabel_20:
   \   000096   FA           MOV     R2,A
   \   000097   A3           INC     DPTR
   \   000098   E0           MOVX    A,@DPTR
   \   000099   FB           MOV     R3,A
   \   00009A   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   00009D                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00009D   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   1402          
   1403            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1404            {
   1405              uint8 found;
   1406              APSME_GetRequest( apsTrustCenterAddress,0, TC_ExtAddr );
   \   0000A0                ; Setup parameters for call to function APSME_GetRequest
   \   0000A0   7409         MOV     A,#0x9
   \   0000A2   12....       LCALL   ?XSTACK_DISP102_8
   \   0000A5   7A00         MOV     R2,#0x0
   \   0000A7   7B00         MOV     R3,#0x0
   \   0000A9   79AB         MOV     R1,#-0x55
   \   0000AB   12....       LCALL   `??APSME_GetRequest::?relay`; Banked call to: APSME_GetRequest
   1407              
   1408              APSME_SearchTCLinkKeyEntry(TC_ExtAddr,&found,NULL);
   \   0000AE                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   0000AE   E4           CLR     A
   \   0000AF   F5..         MOV     ?V0,A
   \   0000B1   F5..         MOV     ?V1,A
   \   0000B3   78..         MOV     R0,#?V0
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B8   7402         MOV     A,#0x2
   \   0000BA   12....       LCALL   ?XSTACK_DISP102_8
   \   0000BD   740B         MOV     A,#0xb
   \   0000BF   12....       LCALL   ?XSTACK_DISP101_8
   \   0000C2   12....       LCALL   `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   0000C5   7402         MOV     A,#0x2
   \   0000C7   12....       LCALL   ?DEALLOC_XSTACK8
   1409              
   1410              // For ZG_GLOBAL_LINK_KEY the message has to be sent twice one
   1411              // un-encrypted and one APS encrypted, to make sure that it can interoperate
   1412              // with legacy Coordinator devices which can only handle one or the other.
   1413          #if defined ( APP_TP2_TEST_MODE )
   1414              if ( ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY ) && ( found == FALSE ) && ( guTxApsSecON != TRUE ) )
   1415          #else
   1416              if ( ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY ) && ( found == FALSE ) )
   \   0000CA   90....       MOV     DPTR,#zgApsLinkKeyType
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   6401         XRL     A,#0x1
   \   0000D0   7017         JNZ     ??ZDSecMgrDeviceJoinFwd_6
   \   0000D2   85..82       MOV     DPL,?XSP + 0
   \   0000D5   85..83       MOV     DPH,?XSP + 1
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   700E         JNZ     ??ZDSecMgrDeviceJoinFwd_6
   1417          #endif
   1418              {
   1419                req.apsSecure = FALSE;
   \   0000DB   7408         MOV     A,#0x8
   \   0000DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E0   E4           CLR     A
   \   0000E1   F0           MOVX    @DPTR,A
   1420          
   1421                // send and APSME_UPDATE_DEVICE request to the trust center
   1422                status = APSME_UpdateDeviceReq( &req );
   \   0000E2                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   0000E2   04           INC     A
   \   0000E3   12....       LCALL   ?XSTACK_DISP101_8
   \   0000E6   12....       LCALL   `??APSME_UpdateDeviceReq::?relay`; Banked call to: APSME_UpdateDeviceReq
   1423              }
   1424          
   1425          #if defined ( APP_TP2_TEST_MODE )
   1426              if ( guTxApsSecON != FALSE )
   1427              {
   1428                // send the message APS encrypted
   1429                req.apsSecure = TRUE;
   1430          
   1431                // send and APSME_UPDATE_DEVICE request to the trust center
   1432                status = APSME_UpdateDeviceReq( &req );
   1433              }
   1434          #else
   1435              // send the message APS encrypted
   1436              req.apsSecure = TRUE;
   \                     ??ZDSecMgrDeviceJoinFwd_6:
   \   0000E9   7408         MOV     A,#0x8
   \   0000EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EE   7401         MOV     A,#0x1
   \   0000F0   F0           MOVX    @DPTR,A
   1437          
   1438              // send and APSME_UPDATE_DEVICE request to the trust center
   1439              status = APSME_UpdateDeviceReq( &req );
   1440          #endif
   1441            }
   1442            else
   1443            {
   1444              req.apsSecure = FALSE;
   1445          
   1446              // send and APSME_UPDATE_DEVICE request to the trust center
   1447              status = APSME_UpdateDeviceReq( &req );
   1448            }
   1449          
   1450            return status;
   \   0000F1                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   0000F1   12....       LCALL   ?XSTACK_DISP101_8
   \   0000F4   12....       LCALL   `??APSME_UpdateDeviceReq::?relay`; Banked call to: APSME_UpdateDeviceReq
   \   0000F7   02....       LJMP    ?Subroutine4 & 0xFFFF
   1451          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7411         MOV     A,#0x11
   \   000002                REQUIRE ??Subroutine71_0
   \   000002                ; // Fall through to label ??Subroutine71_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function AssocGetWithShort
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET
   1452          
   1453          /******************************************************************************
   1454           * @fn          ZDSecMgrDeviceNew
   1455           *
   1456           * @brief       Process a new device.
   1457           *
   1458           * @param       device - [in] ZDSecMgrDevice_t, device info
   1459           *
   1460           * @return      ZStatus_t
   1461           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1462          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   1463          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1464            ZStatus_t status;
   1465          
   1466            if ( ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1467                || ( ( ZG_BUILD_RTR_TYPE ) && APSME_IsDistributedSecurity() ) )
   1468            {
   1469              // try to join this device
   1470              status = ZDSecMgrDeviceJoinDirect( joiner );
   1471            }
   1472            else
   1473            {
   1474              status = ZDSecMgrDeviceJoinFwd( joiner );
   1475            }
   1476          
   1477            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinDirect
   \   000004   12....       LCALL   `??ZDSecMgrDeviceJoinDirect::?relay`; Banked call to: ZDSecMgrDeviceJoinDirect
   \   000007   80..         SJMP    ??Subroutine63_0
   1478          }
   1479          
   1480          /******************************************************************************
   1481           * @fn          ZDSecMgrAssocDeviceAuth
   1482           *
   1483           * @brief       Set associated device status to authenticated
   1484           *
   1485           * @param       assoc - [in, out] associated_devices_t
   1486           *
   1487           * @return      none
   1488           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1489          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   1490          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1491            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   1492            {
   1493              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   1494            }
   1495          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   80..         SJMP    ??Subroutine63_0
   1496          
   1497          /******************************************************************************
   1498           * @fn          ZDSecMgrAuthNwkKey
   1499           *
   1500           * @brief       Handle next step in authentication process
   1501           *
   1502           * @param       none
   1503           *
   1504           * @return      none
   1505           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1506          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   1507          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1508            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   1509            {
   1510              // inform ZDO that device has been authenticated
   1511              osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
   1512            }
   1513          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   80..         SJMP    ??Subroutine63_0
   1514          
   1515          /******************************************************************************
   1516           * PUBLIC FUNCTIONS
   1517           */
   1518          /******************************************************************************
   1519           * @fn          ZDSecMgrInit
   1520           *
   1521           * @brief       Initialize ZigBee Device Security Manager.
   1522           *
   1523           * @param       state - device initialization state
   1524           *
   1525           * @return      none
   1526           */
   1527          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1528          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   1529          void ZDSecMgrAddrMgrCB( uint8           update,
   1530                                  AddrMgrEntry_t* newEntry,
   1531                                  AddrMgrEntry_t* oldEntry )
   1532          {
   1533            (void)update;
   1534            (void)newEntry;
   1535            (void)oldEntry;
   1536          }
   1537          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1538          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1539          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   1540          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1541            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1542            {
   1543              // initialize sub modules
   1544              ZDSecMgrEntryInit(state);
   \   000005                ; Setup parameters for call to function ZDSecMgrEntryInit
   \   000005   12....       LCALL   `??ZDSecMgrEntryInit::?relay`; Banked call to: ZDSecMgrEntryInit
   1545          
   1546              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1547              {
   1548                APSME_SetRequest( apsTrustCenterAddress, 0, NLME_GetExtAddr() );
   \   000008                ; Setup parameters for call to function NLME_GetExtAddr
   \   000008   12....       LCALL   `??NLME_GetExtAddr::?relay`; Banked call to: NLME_GetExtAddr
   \   00000B   8A..         MOV     ?V0,R2
   \   00000D   8B..         MOV     ?V1,R3
   \   00000F   AC..         MOV     R4,?V0
   \   000011   AD..         MOV     R5,?V1
   \   000013                ; Setup parameters for call to function APSME_SetRequest
   \   000013   7A00         MOV     R2,#0x0
   \   000015   7B00         MOV     R3,#0x0
   \   000017   79AB         MOV     R1,#-0x55
   \   000019   12....       LCALL   `??APSME_SetRequest::?relay`; Banked call to: APSME_SetRequest
   1549              }
   1550          
   1551              // register with Address Manager
   1552          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1553              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   1554          #endif
   1555            }
   1556          
   1557            if ( ZG_SECURE_ENABLED )
   1558            {
   1559              if ( ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1560                   || ( ( ZG_BUILD_RTR_TYPE ) && APSME_IsDistributedSecurity() ) )
   1561              {
   1562                // setup joining permissions
   1563                ZDSecMgrPermitJoiningEnabled = TRUE;  
   \   00001C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00001F   7401         MOV     A,#0x1
   \   000021   F0           MOVX    @DPTR,A
   1564                ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000022   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000025   E4           CLR     A
   \   000026   F0           MOVX    @DPTR,A
   1565              }
   1566            }
   1567          
   1568            // configure security based on security mode and type of device
   1569            ZDSecMgrConfig();
   \   000027                ; Setup parameters for call to function SSP_Init
   \   000027   12....       LCALL   `??SSP_Init::?relay` ; Banked call to: SSP_Init
   \   00002A                ; Setup parameters for call to function APSME_SecurityCM_CD
   \   00002A   12....       LCALL   `??APSME_SecurityCM_CD::?relay`; Banked call to: APSME_SecurityCM_CD
   1570          }
   \   00002D   02....       LJMP    ??Subroutine72_0 & 0xFFFF
   1571          
   1572          /******************************************************************************
   1573           * @fn          ZDSecMgrConfig
   1574           *
   1575           * @brief       Configure ZigBee Device Security Manager.
   1576           *
   1577           * @param       none
   1578           *
   1579           * @return      none
   1580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1581          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   1582          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1583            if ( ZG_SECURE_ENABLED )
   1584            {
   1585              SSP_Init();
   \   000004                ; Setup parameters for call to function SSP_Init
   \   000004   12....       LCALL   `??SSP_Init::?relay` ; Banked call to: SSP_Init
   1586          
   1587              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1588              {
   1589                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1590                {
   1591                  // COMMERCIAL MODE - COORDINATOR DEVICE
   1592                  APSME_SecurityCM_CD();
   \   000007                ; Setup parameters for call to function APSME_SecurityCM_CD
   \   000007   12....       LCALL   `??APSME_SecurityCM_CD::?relay`; Banked call to: APSME_SecurityCM_CD
   1593                }
   1594                else if ( ZSTACK_ROUTER_BUILD )
   1595                {
   1596                  // COMMERCIAL MODE - ROUTER DEVICE
   1597                  APSME_SecurityCM_RD();
   1598                }
   1599                else
   1600                {
   1601                  // COMMERCIAL MODE - END DEVICE
   1602                  APSME_SecurityCM_ED();
   1603                }
   1604              }
   1605              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1606              {
   1607                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1608                {
   1609                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   1610                  APSME_SecurityRM_CD();
   1611                }
   1612                else if ( ZSTACK_ROUTER_BUILD )
   1613                {
   1614                  // RESIDENTIAL MODE - ROUTER DEVICE
   1615                  APSME_SecurityRM_RD();
   1616                }
   1617                else
   1618                {
   1619                  // RESIDENTIAL MODE - END DEVICE
   1620                  APSME_SecurityRM_ED();
   1621                }
   1622              }
   1623            }
   1624            else
   1625            {
   1626              // NO SECURITY
   1627              APSME_SecurityNM();
   1628            }
   1629          }
   \   00000A   80..         SJMP    ??Subroutine63_0
   1630          
   1631          /******************************************************************************
   1632           * @fn          ZDSecMgrPermitJoining
   1633           *
   1634           * @brief       Process request to change joining permissions.
   1635           *
   1636           * @param       duration - [in] timed duration for join in seconds
   1637           *                         - 0x00 not allowed
   1638           *                         - 0xFF allowed without timeout
   1639           *
   1640           * @return      uint8 - success(TRUE:FALSE)
   1641           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1642          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   1643          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   1644            uint8 accept;
   1645          
   1646            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   1647          
   1648            if ( duration > 0 )
   \   00000B   E8           MOV     A,R0
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   6008         JZ      ??ZDSecMgrPermitJoining_0
   1649            {
   1650              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
   1651          
   1652              ZDSecMgrPermitJoiningTimed = TRUE;
   \   000014   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000017   8001         SJMP    ??ZDSecMgrPermitJoining_1
   1653            }
   1654            else
   1655            {
   1656              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000019   E4           CLR     A
   \                     ??ZDSecMgrPermitJoining_1:
   \   00001A   F0           MOVX    @DPTR,A
   1657            }
   1658          
   1659            accept = TRUE;
   1660          
   1661            return accept;
   \   00001B   7901         MOV     R1,#0x1
   \   00001D   80..         SJMP    ??Subroutine63_0
   1662          }
   1663          
   1664          /******************************************************************************
   1665           * @fn          ZDSecMgrPermitJoiningTimeout
   1666           *
   1667           * @brief       Process permit joining timeout
   1668           *
   1669           * @param       none
   1670           *
   1671           * @return      none
   1672           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1673          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   1674          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1675            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   1676            {
   1677              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   1678              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   1679            }
   1680          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   80..         SJMP    ??Subroutine63_0
   1681          
   1682          /******************************************************************************
   1683           * @fn          ZDSecMgrNewDeviceEvent
   1684           *
   1685           * @brief       Process a the new device event, if found reset new device
   1686           *              event/timer.
   1687           *
   1688           * @param       ShortAddr - of New Device to process
   1689           *
   1690           * @return      uint8 - found(TRUE:FALSE)
   1691           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1692          uint8 ZDSecMgrNewDeviceEvent( uint16 ShortAddr )
   \                     ZDSecMgrNewDeviceEvent:
   1693          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1694            uint8                 found;
   1695            ZDSecMgrDevice_t      device;
   1696            AddrMgrEntry_t        addrEntry;
   1697            associated_devices_t* assoc;
   1698            ZStatus_t             status;
   1699          
   1700            // initialize return results
   1701            found = FALSE;
   \   00000A   75..00       MOV     ?V0,#0x0
   1702          
   1703            assoc = AssocGetWithShort( ShortAddr );
   \   00000D                ; Setup parameters for call to function AssocGetWithShort
   \   00000D   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   000010   8A..         MOV     ?V2,R2
   \   000012   8B..         MOV     ?V3,R3
   \   000014   AE..         MOV     R6,?V2
   \   000016   AF..         MOV     R7,?V3
   1704          
   1705            if ( assoc != NULL )
   \   000018   EE           MOV     A,R6
   \   000019   4F           ORL     A,R7
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   1706            {
   1707              // device found
   1708              found = TRUE;
   \   00001F   75..01       MOV     ?V0,#0x1
   1709          
   1710              // check for preconfigured security
   1711              if ( zgPreConfigKeys == TRUE )
   \   000022   90....       MOV     DPTR,#zgPreConfigKeys
   \   000025   E0           MOVX    A,@DPTR
   \   000026   6401         XRL     A,#0x1
   \   000028   7003         JNZ     ??ZDSecMgrNewDeviceEvent_1
   1712              {
   1713                // set association status to authenticated
   1714                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002A                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002A   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   1715              }
   1716          
   1717              // set up device info
   1718              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002D   7408         MOV     A,#0x8
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E4           CLR     A
   \   000033   12....       LCALL   ?Subroutine49 & 0xFFFF
   1719              addrEntry.index = assoc->addrIdx;
   \                     ??CrossCallReturnLabel_68:
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   00003B   7413         MOV     A,#0x13
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   1720              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_153:
   \   000043                ; Setup parameters for call to function AddrMgrEntryGet
   \   000043   7408         MOV     A,#0x8
   \   000045   12....       LCALL   ?XSTACK_DISP101_8
   \   000048   12....       LCALL   `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   1721          
   1722              device.nwkAddr    = assoc->shortAddr;
   \   00004B   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   12....       LCALL   ?Subroutine21 & 0xFFFF
   1723              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_16:
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   A882         MOV     R0,DPL
   \   00005C   A983         MOV     R1,DPH
   \   00005E   7402         MOV     A,#0x2
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   1724              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_154:
   \   000066                ; Setup parameters for call to function NLME_GetShortAddr
   \   000066   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000069   7404         MOV     A,#0x4
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   12....       LCALL   ?Subroutine26 & 0xFFFF
   1725          
   1726              // the new device performed Secured Rejoin
   1727              if ( ( assoc->devStatus & DEV_SECURED_JOIN ) &&
   1728                   ( assoc->devStatus & DEV_REJOIN_STATUS ) )
   \                     ??CrossCallReturnLabel_23:
   \   000071   EE           MOV     A,R6
   \   000072   2405         ADD     A,#0x5
   \   000074   F8           MOV     R0,A
   \   000075   E4           CLR     A
   \   000076   3F           ADDC    A,R7
   \   000077   F9           MOV     R1,A
   \   000078   E8           MOV     A,R0
   \   000079   FE           MOV     R6,A
   \   00007A   E9           MOV     A,R1
   \   00007B   FF           MOV     R7,A
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \   000080   E0           MOVX    A,@DPTR
   \   000081   5460         ANL     A,#0x60
   \   000083   6460         XRL     A,#0x60
   \   000085   7009         JNZ     ??ZDSecMgrNewDeviceEvent_2
   1729              {
   1730                device.secure     = TRUE;
   \   000087   7406         MOV     A,#0x6
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   7401         MOV     A,#0x1
   \   00008E   8006         SJMP    ??ZDSecMgrNewDeviceEvent_3
   1731              }
   1732              else
   1733              {
   1734                device.secure     = FALSE;
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   000090   7406         MOV     A,#0x6
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   E4           CLR     A
   1735              }
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   000096   12....       LCALL   ?Subroutine49 & 0xFFFF
   1736              device.devStatus  = assoc->devStatus;
   \                     ??CrossCallReturnLabel_69:
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   C0E0         PUSH    A
   \   00009C   7407         MOV     A,#0x7
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   D0E0         POP     A
   \   0000A3   12....       LCALL   ??Subroutine74_0 & 0xFFFF
   1737          
   1738              // process new device
   1739              status = ZDSecMgrDeviceNew( &device );
   1740          
   1741              if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_189:
   \   0000A6   12....       LCALL   `??ZDSecMgrDeviceNew::?relay`; Banked call to: ZDSecMgrDeviceNew
   \   0000A9   E9           MOV     A,R1
   \   0000AA   700A         JNZ     ??ZDSecMgrNewDeviceEvent_4
   1742              {
   1743                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   0000AC   8E82         MOV     DPL,R6
   \   0000AE   8F83         MOV     DPH,R7
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   C2E2         CLR     0xE0 /* A   */.2
   \   0000B3   F0           MOVX    @DPTR,A
   \   0000B4   8018         SJMP    ??ZDSecMgrNewDeviceEvent_0
   1744              }
   1745              else
   1746              {
   1747                // Clear SECURITY bit from Address Manager
   1748                ZDSecMgrAddrClear( addrEntry.extAddr );
   \                     ??ZDSecMgrNewDeviceEvent_4:
   \   0000B6                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   0000B6   740B         MOV     A,#0xb
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   AA82         MOV     R2,DPL
   \   0000BD   AB83         MOV     R3,DPH
   \   0000BF   12....       LCALL   `??ZDSecMgrAddrClear::?relay`; Banked call to: ZDSecMgrAddrClear
   1749          
   1750                // Remove the Association completely
   1751                AssocRemove( addrEntry.extAddr );
   \   0000C2                ; Setup parameters for call to function AssocRemove
   \   0000C2   740B         MOV     A,#0xb
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   AA82         MOV     R2,DPL
   \   0000C9   AB83         MOV     R3,DPH
   \   0000CB   12....       LCALL   `??AssocRemove::?relay`; Banked call to: AssocRemove
   1752              }
   1753            }
   1754          
   1755            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000CE   A9..         MOV     R1,?V0
   \   0000D0   7415         MOV     A,#0x15
   \   0000D2   02....       LJMP    ?Subroutine3 & 0xFFFF
   1756          }
   1757          
   1758          /******************************************************************************
   1759           * @fn          ZDSecMgrTCExtAddrCheck
   1760           *
   1761           * @brief       Verifies if received ext. address matches TC ext. address.
   1762           *
   1763           * @param       extAddr - Extended address to be verified.
   1764           *
   1765           * @return      TRUE - extended address matches
   1766           *              FALSE - otherwise
   1767           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1768          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   1769          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1770            uint8  lookup[Z_EXTADDR_LEN];
   1771            APSME_GetRequest( apsTrustCenterAddress, 0, lookup );
   \   00000E                ; Setup parameters for call to function APSME_GetRequest
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   7A00         MOV     R2,#0x0
   \   000014   7B00         MOV     R3,#0x0
   \   000016   79AB         MOV     R1,#-0x55
   \   000018   12....       LCALL   `??APSME_GetRequest::?relay`; Banked call to: APSME_GetRequest
   1772            return osal_ExtAddrEqual( extAddr, lookup );
   \   00001B                ; Setup parameters for call to function sAddrExtCmp
   \   00001B   AC..         MOV     R4,?XSP + 0
   \   00001D   AD..         MOV     R5,?XSP + 1
   \   00001F   EE           MOV     A,R6
   \   000020   FA           MOV     R2,A
   \   000021   EF           MOV     A,R7
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   `??sAddrExtCmp::?relay`; Banked call to: sAddrExtCmp
   \   000026                REQUIRE ?Subroutine8
   \   000026                ; // Fall through to label ?Subroutine8
   1773          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7408         MOV     A,#0x8
   \   000002   80..         SJMP    ??Subroutine65_0
   1774          
   1775          /******************************************************************************
   1776           * @fn          ZDSecMgrTCDataLoad
   1777           *
   1778           * @brief       Stores the address of TC into address manager.
   1779           *
   1780           * @param       extAddr - Extended address to be verified.
   1781           *
   1782           * @return      none
   1783           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1784          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   1785          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1786            uint16 ami;
   1787            AddrMgrEntry_t entry;
   1788          
   1789            // lookup using TC short address
   1790            entry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   F0           MOVX    @DPTR,A
   1791            osal_cpyExtAddr( entry.extAddr, extAddr );
   \   000015                ; Setup parameters for call to function sAddrExtCpy
   \   000015   EE           MOV     A,R6
   \   000016   FC           MOV     R4,A
   \   000017   EF           MOV     A,R7
   \   000018   FD           MOV     R5,A
   \   000019   7405         MOV     A,#0x5
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   AA82         MOV     R2,DPL
   \   000020   AB83         MOV     R3,DPH
   \   000022   12....       LCALL   `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
   1792          
   1793            // Verify if TC address has been added to Address Manager
   1794            if ( !APSME_IsDistributedSecurity() && ( AddrMgrEntryLookupExt( &entry ) != TRUE ) )
   \   000025                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000025   12....       LCALL   `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   000028   E9           MOV     A,R1
   \   000029   702A         JNZ     ??ZDSecMgrTCDataLoad_0
   \   00002B                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?XSTACK_DISP101_8
   \   000030   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   000033   E9           MOV     A,R1
   \   000034   6401         XRL     A,#0x1
   \   000036   601D         JZ      ??ZDSecMgrTCDataLoad_0
   1795            {
   1796              ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami );
   \   000038                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000038   A8..         MOV     R0,?XSP + 0
   \   00003A   A9..         MOV     R1,?XSP + 1
   \   00003C   88..         MOV     ?V0,R0
   \   00003E   89..         MOV     ?V1,R1
   \   000040   78..         MOV     R0,#?V0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   EE           MOV     A,R6
   \   000046   FC           MOV     R4,A
   \   000047   EF           MOV     A,R7
   \   000048   FD           MOV     R5,A
   \   000049   7A00         MOV     R2,#0x0
   \   00004B   7B00         MOV     R3,#0x0
   \   00004D   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000050   7402         MOV     A,#0x2
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   1797            }
   1798          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000055   740F         MOV     A,#0xf
   \   000057   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   1799          
   1800          /******************************************************************************
   1801           * @fn          ZDSecMgrTransportKeyInd
   1802           *
   1803           * @brief       Process the ZDO_TransportKeyInd_t message.
   1804           *
   1805           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   1806           *
   1807           * @return      none
   1808           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1809          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   1810          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 40
   \   000005   74D8         MOV     A,#-0x28
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   1811            uint8 index;
   1812            uint8 zgPreConfigKey[SEC_KEY_LEN];
   1813          
   1814            ZDSecMgrUpdateTCAddress( ind->srcExtAddr );
   \   00000E   EA           MOV     A,R2
   \   00000F   2416         ADD     A,#0x16
   \   000011   FE           MOV     R6,A
   \   000012   E4           CLR     A
   \   000013   35..         ADDC    A,?V1
   \   000015   FF           MOV     R7,A
   \   000016                ; Setup parameters for call to function ZDSecMgrUpdateTCAddress
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   `??ZDSecMgrUpdateTCAddress::?relay`; Banked call to: ZDSecMgrUpdateTCAddress
   1815            
   1816          #if ZG_BUILD_JOINING_TYPE
   1817            if(ZG_DEVICE_JOINING_TYPE)
   1818            {
   1819              //Update the TC address in the entry
   1820              osal_nv_write(ZCD_NV_TCLK_TABLE_START, osal_offsetof(APSME_TCLKDevEntry_t,extAddr), Z_EXTADDR_LEN, ind->srcExtAddr);
   1821            }
   1822          #endif
   1823            
   1824            // check for distributed security
   1825            if ( ( ZG_BUILD_RTR_TYPE ) && osal_isbufset( ind->srcExtAddr, 0xFF, Z_EXTADDR_LEN ) )
   \   00001D                ; Setup parameters for call to function osal_isbufset
   \   00001D   7C08         MOV     R4,#0x8
   \   00001F   79FF         MOV     R1,#-0x1
   \   000021   EE           MOV     A,R6
   \   000022   FA           MOV     R2,A
   \   000023   EF           MOV     A,R7
   \   000024   FB           MOV     R3,A
   \   000025   12....       LCALL   `??osal_isbufset::?relay`; Banked call to: osal_isbufset
   \   000028   E9           MOV     A,R1
   \   000029   6006         JZ      ??ZDSecMgrTransportKeyInd_0
   1826            {
   1827              ZDSecMgrPermitJoiningEnabled = TRUE;  
   \   00002B   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00002E   7401         MOV     A,#0x1
   \   000030   F0           MOVX    @DPTR,A
   1828            }
   1829            
   1830            // load Trust Center data if needed
   1831            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   000031                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000031   EE           MOV     A,R6
   \   000032   FA           MOV     R2,A
   \   000033   EF           MOV     A,R7
   \   000034   FB           MOV     R3,A
   \   000035   12....       LCALL   `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   1832            
   1833            if ( ( ind->keyType == KEY_TYPE_NWK ) ||
   1834                 ( ind->keyType == 6            ) )
   \   000038   85..82       MOV     DPL,?V0
   \   00003B   85..83       MOV     DPH,?V1
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   E5..         MOV     A,?V0
   \   000046   2406         ADD     A,#0x6
   \   000048   F5..         MOV     ?V2,A
   \   00004A   E4           CLR     A
   \   00004B   35..         ADDC    A,?V1
   \   00004D   F5..         MOV     ?V3,A
   \   00004F   7401         MOV     A,#0x1
   \   000051   68           XRL     A,R0
   \   000052   6008         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000054   7406         MOV     A,#0x6
   \   000056   68           XRL     A,R0
   \   000057   6003         JZ      $+5
   \   000059   02....       LJMP    ??ZDSecMgrTransportKeyInd_2 & 0xFFFF
   1835            {
   1836              // check for dummy NWK key (all zeros)
   1837              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   00005C   7A00         MOV     R2,#0x0
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   00005E   EA           MOV     A,R2
   \   00005F   F8           MOV     R0,A
   \   000060   E5..         MOV     A,?V0
   \   000062   28           ADD     A,R0
   \   000063   F582         MOV     DPL,A
   \   000065   E4           CLR     A
   \   000066   35..         ADDC    A,?V1
   \   000068   F583         MOV     DPH,A
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   7007         JNZ     ??ZDSecMgrTransportKeyInd_4
   1838                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   1839                    index++ );
   \   000073   0A           INC     R2
   \   000074   EA           MOV     A,R2
   \   000075   C3           CLR     C
   \   000076   9410         SUBB    A,#0x10
   \   000078   40E4         JC      ??ZDSecMgrTransportKeyInd_3
   1840          
   1841              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   00007A   7410         MOV     A,#0x10
   \   00007C   6A           XRL     A,R2
   \   00007D   7031         JNZ     ??ZDSecMgrTransportKeyInd_5
   1842              {
   1843                // load preconfigured key - once!!
   1844                if ( !_NIB.nwkKeyLoaded )
   \   00007F   90....       MOV     DPTR,#_NIB + 61
   \   000082   E0           MOVX    A,@DPTR
   \   000083   7054         JNZ     ??ZDSecMgrTransportKeyInd_6
   1845                {
   1846                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   000085                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   000085   7418         MOV     A,#0x18
   \   000087   12....       LCALL   ?XSTACK_DISP102_8
   \   00008A   7A62         MOV     R2,#0x62
   \   00008C   7B00         MOV     R3,#0x0
   \   00008E   12....       LCALL   `??ZDSecMgrReadKeyFromNv::?relay`; Banked call to: ZDSecMgrReadKeyFromNv
   1847                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   000091                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000091   7900         MOV     R1,#0x0
   \   000093   7418         MOV     A,#0x18
   \   000095   12....       LCALL   ?XSTACK_DISP101_8
   \   000098   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   1848                  SSP_SwitchNwkKey( 0 );
   \   00009B                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00009B   7900         MOV     R1,#0x0
   \   00009D   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   1849          
   1850                  // clear local copy of key
   1851                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   0000A0                ; Setup parameters for call to function osal_memset
   \   0000A0   7C10         MOV     R4,#0x10
   \   0000A2   7D00         MOV     R5,#0x0
   \   0000A4   7900         MOV     R1,#0x0
   \   0000A6   7418         MOV     A,#0x18
   \   0000A8   12....       LCALL   ?XSTACK_DISP101_8
   \   0000AB   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   \   0000AE   8029         SJMP    ??ZDSecMgrTransportKeyInd_6
   1852                }
   1853              }
   1854              else
   1855              {
   1856                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000B0   E5..         MOV     A,?V0
   \   0000B2   2405         ADD     A,#0x5
   \   0000B4   F8           MOV     R0,A
   \   0000B5   E4           CLR     A
   \   0000B6   35..         ADDC    A,?V1
   \   0000B8   F9           MOV     R1,A
   \   0000B9   E8           MOV     A,R0
   \   0000BA   FE           MOV     R6,A
   \   0000BB   E9           MOV     A,R1
   \   0000BC   FF           MOV     R7,A
   \   0000BD                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   0000BD   8E82         MOV     DPL,R6
   \   0000BF   8F83         MOV     DPH,R7
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F9           MOV     R1,A
   \   0000C3   AA..         MOV     R2,?V2
   \   0000C5   AB..         MOV     R3,?V3
   \   0000C7   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   1857                if ( !_NIB.nwkKeyLoaded )
   \   0000CA   90....       MOV     DPTR,#_NIB + 61
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   7009         JNZ     ??ZDSecMgrTransportKeyInd_6
   1858                {
   1859                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000D0                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000D0   8E82         MOV     DPL,R6
   \   0000D2   8F83         MOV     DPH,R7
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   F9           MOV     R1,A
   \   0000D6   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   1860                }
   1861              }
   1862          
   1863              // handle next step in authentication process
   1864              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   0000D9                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000D9   12....       LCALL   `??ZDSecMgrAuthNwkKey::?relay`; Banked call to: ZDSecMgrAuthNwkKey
   \   0000DC   02....       LJMP    ??ZDSecMgrTransportKeyInd_7 & 0xFFFF
   1865            }
   1866            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   0000DF   7404         MOV     A,#0x4
   \   0000E1   68           XRL     A,R0
   \   0000E2   6003         JZ      $+5
   \   0000E4   02....       LJMP    ??ZDSecMgrTransportKeyInd_8 & 0xFFFF
   1867            {
   1868              uint16 entryIndex;
   1869              uint8 found;
   1870              APSME_TCLKDevEntry_t TCLKDevEntry;
   1871              
   1872              //Search the entry, which should exist at this point
   1873              entryIndex = APSME_SearchTCLinkKeyEntry(ind->srcExtAddr, &found, &TCLKDevEntry);
   \   0000E7                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   0000E7   7405         MOV     A,#0x5
   \   0000E9   12....       LCALL   ?XSTACK_DISP100_8
   \   0000EC   88..         MOV     ?V0,R0
   \   0000EE   89..         MOV     ?V1,R1
   \   0000F0   78..         MOV     R0,#?V0
   \   0000F2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F5   7402         MOV     A,#0x2
   \   0000F7   12....       LCALL   ?XSTACK_DISP102_8
   \   0000FA   EE           MOV     A,R6
   \   0000FB   FA           MOV     R2,A
   \   0000FC   EF           MOV     A,R7
   \   0000FD   FB           MOV     R3,A
   \   0000FE   12....       LCALL   `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   000101   7402         MOV     A,#0x2
   \   000103   12....       LCALL   ?DEALLOC_XSTACK8
   \   000106   8A..         MOV     ?V0,R2
   \   000108   8B..         MOV     ?V1,R3
   \   00010A   AE..         MOV     R6,?V0
   \   00010C   AF..         MOV     R7,?V1
   1874              
   1875              if(found)
   \   00010E   85..82       MOV     DPL,?XSP + 0
   \   000111   85..83       MOV     DPH,?XSP + 1
   \   000114   E0           MOVX    A,@DPTR
   \   000115   7003         JNZ     $+5
   \   000117   02....       LJMP    ??ZDSecMgrTransportKeyInd_7 & 0xFFFF
   1876              {
   1877                //If the key was an IC, then erase the entry since that will not longer be used.
   1878                if(TCLKDevEntry.keyAttributes == ZG_PROVISIONAL_KEY)
   \   00011A   7415         MOV     A,#0x15
   \   00011C   12....       LCALL   ?XSTACK_DISP0_8
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   700C         JNZ     ??ZDSecMgrTransportKeyInd_9
   1879                {
   1880                  APSME_EraseICEntry(&TCLKDevEntry.SeedShift_IcIndex);
   \   000122                ; Setup parameters for call to function APSME_EraseICEntry
   \   000122   7417         MOV     A,#0x17
   \   000124   12....       LCALL   ?XSTACK_DISP0_8
   \   000127   AA82         MOV     R2,DPL
   \   000129   AB83         MOV     R3,DPH
   \   00012B   12....       LCALL   `??APSME_EraseICEntry::?relay`; Banked call to: APSME_EraseICEntry
   1881                }
   1882                
   1883                TCLKDevEntry.keyAttributes = ZG_UNVERIFIED_KEY;
   \                     ??ZDSecMgrTransportKeyInd_9:
   \   00012E   7415         MOV     A,#0x15
   \   000130   12....       LCALL   ?XSTACK_DISP0_8
   \   000133   7401         MOV     A,#0x1
   \   000135   F0           MOVX    @DPTR,A
   1884                TCLKDevEntry.keyType = ZG_UNIQUE_LINK_KEY;
   \   000136   7416         MOV     A,#0x16
   \   000138   12....       LCALL   ?XSTACK_DISP0_8
   \   00013B   E4           CLR     A
   \   00013C   F0           MOVX    @DPTR,A
   1885                TCLKDevEntry.rxFrmCntr = 0;
   \   00013D   7409         MOV     A,#0x9
   \   00013F   12....       LCALL   ?XSTACK_DISP0_8
   \   000142   12....       LCALL   ?Subroutine24 & 0xFFFF
   1886                TCLKDevEntry.txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_17:
   \   000145   12....       LCALL   ?XSTACK_DISP0_8
   \   000148   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   1887                TCLKDevEntry.SeedShift_IcIndex = 0;
   \                     ??CrossCallReturnLabel_177:
   \   00014B   7417         MOV     A,#0x17
   \   00014D   12....       LCALL   ?XSTACK_DISP0_8
   \   000150   E4           CLR     A
   \   000151   F0           MOVX    @DPTR,A
   1888                
   1889                //Update the entry
   1890                osal_nv_write(entryIndex,0,sizeof(APSME_TCLKDevEntry_t),&TCLKDevEntry);
   \   000152                ; Setup parameters for call to function osal_nv_write
   \   000152   7405         MOV     A,#0x5
   \   000154   12....       LCALL   ?XSTACK_DISP100_8
   \   000157   88..         MOV     ?V0,R0
   \   000159   89..         MOV     ?V1,R1
   \   00015B   78..         MOV     R0,#?V0
   \   00015D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000160   75..13       MOV     ?V0,#0x13
   \   000163   75..00       MOV     ?V1,#0x0
   \   000166   78..         MOV     R0,#?V0
   \   000168   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016B   7C00         MOV     R4,#0x0
   \   00016D   7D00         MOV     R5,#0x0
   \   00016F   EE           MOV     A,R6
   \   000170   FA           MOV     R2,A
   \   000171   EF           MOV     A,R7
   \   000172   FB           MOV     R3,A
   \   000173   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000176   7404         MOV     A,#0x4
   \   000178   12....       LCALL   ?DEALLOC_XSTACK8
   1891          
   1892                //Create the entry for the key
   1893                if(ZSUCCESS == osal_nv_item_init(ZCD_NV_TCLK_JOIN_DEV,SEC_KEY_LEN,ind->key) )
   \   00017B                ; Setup parameters for call to function osal_nv_item_init
   \   00017B   78..         MOV     R0,#?V2
   \   00017D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000180   7C10         MOV     R4,#0x10
   \   000182   7D00         MOV     R5,#0x0
   \   000184   7A02         MOV     R2,#0x2
   \   000186   7B01         MOV     R3,#0x1
   \   000188   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00018B   7402         MOV     A,#0x2
   \   00018D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000190   E9           MOV     A,R1
   \   000191   701D         JNZ     ??ZDSecMgrTransportKeyInd_10
   1894                {
   1895                  //Or replace it if already existed
   1896                  osal_nv_write(ZCD_NV_TCLK_JOIN_DEV,0,SEC_KEY_LEN,ind->key);
   \   000193                ; Setup parameters for call to function osal_nv_write
   \   000193   78..         MOV     R0,#?V2
   \   000195   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000198   75..10       MOV     ?V0,#0x10
   \   00019B   78..         MOV     R0,#?V0
   \   00019D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A0   7C00         MOV     R4,#0x0
   \   0001A2   7D00         MOV     R5,#0x0
   \   0001A4   7A02         MOV     R2,#0x2
   \   0001A6   7B01         MOV     R3,#0x1
   \   0001A8   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0001AB   7404         MOV     A,#0x4
   \   0001AD   12....       LCALL   ?DEALLOC_XSTACK8
   1897                }
   1898                
   1899                bdb_tcLinkKeyExchangeAttempt(TRUE,BDB_REQ_VERIFY_TC_LINK_KEY);
   \                     ??ZDSecMgrTransportKeyInd_10:
   \   0001B0                ; Setup parameters for call to function bdb_tcLinkKeyExchangeAttempt
   \   0001B0   7A03         MOV     R2,#0x3
   \   0001B2   7901         MOV     R1,#0x1
   \   0001B4   12....       LCALL   `??bdb_tcLinkKeyExchangeAttempt::?relay`; Banked call to: bdb_tcLinkKeyExchangeAttempt
   \   0001B7   02....       LJMP    ??ZDSecMgrTransportKeyInd_7 & 0xFFFF
   1900              }
   1901            }
   1902            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   \                     ??ZDSecMgrTransportKeyInd_8:
   \   0001BA   7403         MOV     A,#0x3
   \   0001BC   68           XRL     A,R0
   \   0001BD   6003         JZ      $+5
   \   0001BF   02....       LJMP    ??ZDSecMgrTransportKeyInd_7 & 0xFFFF
   1903            {
   1904              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1905              {
   1906                uint16           ami;
   1907                ZDSecMgrEntry_t* entry;
   1908          
   1909                // get the address index
   1910                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   \   0001C2                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   0001C2   7403         MOV     A,#0x3
   \   0001C4   12....       LCALL   ?XSTACK_DISP102_8
   \   0001C7   EE           MOV     A,R6
   \   0001C8   FA           MOV     R2,A
   \   0001C9   EF           MOV     A,R7
   \   0001CA   FB           MOV     R3,A
   \   0001CB   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   0001CE   E9           MOV     A,R1
   \   0001CF   602B         JZ      ??ZDSecMgrTransportKeyInd_11
   1911                {
   1912                  // store new EXT address
   1913                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   \   0001D1                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   0001D1   7403         MOV     A,#0x3
   \   0001D3   12....       LCALL   ?XSTACK_DISP100_8
   \   0001D6   88..         MOV     ?V0,R0
   \   0001D8   89..         MOV     ?V1,R1
   \   0001DA   78..         MOV     R0,#?V0
   \   0001DC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DF   EE           MOV     A,R6
   \   0001E0   FC           MOV     R4,A
   \   0001E1   EF           MOV     A,R7
   \   0001E2   FD           MOV     R5,A
   \   0001E3   7AFE         MOV     R2,#-0x2
   \   0001E5   7BFF         MOV     R3,#-0x1
   \   0001E7   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   0001EA   7402         MOV     A,#0x2
   \   0001EC   12....       LCALL   ?DEALLOC_XSTACK8
   1914                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   0001EF                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   0001EF   7D00         MOV     R5,#0x0
   \   0001F1   7C00         MOV     R4,#0x0
   \   0001F3   7900         MOV     R1,#0x0
   \   0001F5   EE           MOV     A,R6
   \   0001F6   FA           MOV     R2,A
   \   0001F7   EF           MOV     A,R7
   \   0001F8   FB           MOV     R3,A
   \   0001F9   12....       LCALL   `??ZDP_NwkAddrReq::?relay`; Banked call to: ZDP_NwkAddrReq
   1915                }
   1916          
   1917                ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrTransportKeyInd_11:
   \   0001FC                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   0001FC   7401         MOV     A,#0x1
   \   0001FE   12....       LCALL   ?XSTACK_DISP102_8
   \   000201   7403         MOV     A,#0x3
   \   000203   12....       LCALL   ?XSTACK_DISP0_8
   \   000206   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000209   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   1918          
   1919                if ( entry == NULL )
   \   00020C   7401         MOV     A,#0x1
   \   00020E   12....       LCALL   ?XSTACK_DISP0_8
   \   000211   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000214   701E         JNZ     ??CrossCallReturnLabel_155
   1920                {
   1921                  // get new entry
   1922                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000216                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000216   7401         MOV     A,#0x1
   \   000218   12....       LCALL   ?XSTACK_DISP101_8
   \   00021B   12....       LCALL   `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   00021E   E9           MOV     A,R1
   \   00021F   7013         JNZ     ??CrossCallReturnLabel_155
   1923                  {
   1924                    // finish setting up entry
   1925                    entry->ami = ami;
   \   000221   7403         MOV     A,#0x3
   \   000223   12....       LCALL   ?XSTACK_DISP0_8
   \   000226   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   1926                  }
   1927                }
   \                     ??CrossCallReturnLabel_130:
   \   000229   7401         MOV     A,#0x1
   \   00022B   12....       LCALL   ?XSTACK_DISP0_8
   \   00022E   12....       LCALL   ??Subroutine76_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000231   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   1928          
   1929                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   \                     ??CrossCallReturnLabel_155:
   \   000234                ; Setup parameters for call to function APSME_LinkKeySet
   \   000234   AC..         MOV     R4,?V2
   \   000236   AD..         MOV     R5,?V3
   \   000238   EE           MOV     A,R6
   \   000239   FA           MOV     R2,A
   \   00023A   EF           MOV     A,R7
   \   00023B   FB           MOV     R3,A
   \   00023C   12....       LCALL   `??APSME_LinkKeySet::?relay`; Banked call to: APSME_LinkKeySet
   1930          
   1931          #if defined NV_RESTORE
   1932                ZDSecMgrWriteNV();  // Write the control record for the new established link key to NV.
   \   00023F                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   00023F   12....       LCALL   `??ZDSecMgrWriteNV::?relay`; Banked call to: ZDSecMgrWriteNV
   1933          #endif
   1934              }
   1935            }
   1936          }
   \                     ??ZDSecMgrTransportKeyInd_7:
   \   000242   7428         MOV     A,#0x28
   \   000244   02....       LJMP    ?Subroutine3 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000003   7405         MOV     A,#0x5
   \   000005   22           RET
   1937          
   1938          /******************************************************************************
   1939           * @fn          ZDSecMgrUpdateDeviceInd
   1940           *
   1941           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   1942           *
   1943           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   1944           *
   1945           * @return      none
   1946           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1947          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   1948          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 28
   \   000005   74E4         MOV     A,#-0x1c
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   F8           MOV     R0,A
   \   00000C   EB           MOV     A,R3
   \   00000D   F9           MOV     R1,A
   1949            ZDSecMgrDevice_t device;
   1950          
   1951            device.nwkAddr    = ind->devAddr;
   \   00000E   E8           MOV     A,R0
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   39           ADDC    A,R1
   \   000015   F583         MOV     DPH,A
   \   000017   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   00001A   7401         MOV     A,#0x1
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ?Subroutine26 & 0xFFFF
   1952            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_24:
   \   000022   E8           MOV     A,R0
   \   000023   2404         ADD     A,#0x4
   \   000025   FA           MOV     R2,A
   \   000026   E4           CLR     A
   \   000027   39           ADDC    A,R1
   \   000028   FB           MOV     R3,A
   \   000029   7403         MOV     A,#0x3
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   12....       LCALL   ?Subroutine26 & 0xFFFF
   1953            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_25:
   \   000031   8882         MOV     DPL,R0
   \   000033   8983         MOV     DPH,R1
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   00003A   7405         MOV     A,#0x5
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   EC           MOV     A,R4
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   ED           MOV     A,R5
   \   000043   F0           MOVX    @DPTR,A
   1954            device.devStatus  = DEV_SEC_INIT_STATUS;
   \   000044   7408         MOV     A,#0x8
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   7404         MOV     A,#0x4
   \   00004B   F0           MOVX    @DPTR,A
   1955            device.secure     = FALSE;
   \   00004C   7407         MOV     A,#0x7
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   E4           CLR     A
   \   000052   F0           MOVX    @DPTR,A
   1956          
   1957            // Trust Center should identify the type of JOIN/REJOIN and
   1958            // Transport the NWK key accordingly, it will only be transported for:
   1959            //              APSME_UD_STANDARD_UNSECURED_JOIN
   1960            //   OR         APSME_UD_STANDARD_TRUST_CENTER_REJOIN
   1961            if ( ind->status != APSME_UD_DEVICE_LEFT )
   \   000053   E8           MOV     A,R0
   \   000054   240E         ADD     A,#0xe
   \   000056   F582         MOV     DPL,A
   \   000058   E4           CLR     A
   \   000059   39           ADDC    A,R1
   \   00005A   F583         MOV     DPH,A
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F8           MOV     R0,A
   \   00005E   7402         MOV     A,#0x2
   \   000060   68           XRL     A,R0
   \   000061   7003         JNZ     $+5
   \   000063   02....       LJMP    ??ZDSecMgrUpdateDeviceInd_0 & 0xFFFF
   1962            {
   1963              if ( ind->status == APSME_UD_STANDARD_SECURED_REJOIN )
   \   000066   E8           MOV     A,R0
   \   000067   7011         JNZ     ??ZDSecMgrUpdateDeviceInd_1
   1964              {
   1965                device.devStatus &= ~DEV_SEC_INIT_STATUS;
   1966                device.devStatus |=  DEV_SEC_AUTH_STATUS;
   \   000069   7408         MOV     A,#0x8
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   7408         MOV     A,#0x8
   \   000070   F0           MOVX    @DPTR,A
   1967                device.secure = TRUE;
   \   000071   14           DEC     A
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   7401         MOV     A,#0x1
   \   000077   F0           MOVX    @DPTR,A
   \   000078   807D         SJMP    ??ZDSecMgrUpdateDeviceInd_2
   1968              }
   1969              else
   1970              {
   1971          #if (ZG_BUILD_COORDINATOR_TYPE)
   1972                uint8  found;
   1973                uint16 keyNvIndex;
   1974                APSME_TCLKDevEntry_t TCLKDevEntry;
   1975                
   1976                keyNvIndex = APSME_SearchTCLinkKeyEntry(device.extAddr,&found, &TCLKDevEntry);
   \                     ??ZDSecMgrUpdateDeviceInd_1:
   \   00007A                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   00007A   7409         MOV     A,#0x9
   \   00007C   12....       LCALL   ?XSTACK_DISP100_8
   \   00007F   88..         MOV     ?V0,R0
   \   000081   89..         MOV     ?V1,R1
   \   000083   78..         MOV     R0,#?V0
   \   000085   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000088   7402         MOV     A,#0x2
   \   00008A   12....       LCALL   ?XSTACK_DISP102_8
   \   00008D   12....       LCALL   `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   000090   7402         MOV     A,#0x2
   \   000092   12....       LCALL   ?DEALLOC_XSTACK8
   1977                
   1978                //If found and it was verified, then allow it to join in a fresh state by erasing the key entry
   1979                if((found == TRUE) && (TCLKDevEntry.keyAttributes == ZG_VERIFIED_KEY))
   \   000095   85..82       MOV     DPL,?XSP + 0
   \   000098   85..83       MOV     DPH,?XSP + 1
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   6401         XRL     A,#0x1
   \   00009E   7044         JNZ     ??ZDSecMgrUpdateDeviceInd_3
   \   0000A0   7419         MOV     A,#0x19
   \   0000A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   6402         XRL     A,#0x2
   \   0000A8   703A         JNZ     ??ZDSecMgrUpdateDeviceInd_3
   1980                {
   1981                  TCLKDevEntry.keyAttributes = ZG_DEFAULT_KEY;
   \   0000AA   74FF         MOV     A,#-0x1
   \   0000AC   F0           MOVX    @DPTR,A
   1982                  //Increase the shift by one. Validate the maximum shift of the seed which is 15
   1983                  TCLKDevEntry.SeedShift_IcIndex++;
   1984                  TCLKDevEntry.SeedShift_IcIndex &= 0x0F;
   \   0000AD   741B         MOV     A,#0x1b
   \   0000AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   04           INC     A
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   540F         ANL     A,#0xf
   \   0000B7   F0           MOVX    @DPTR,A
   1985                  
   1986                  TCLKDevEntry.rxFrmCntr = 0;
   \   0000B8   740D         MOV     A,#0xd
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   1987                  TCLKDevEntry.txFrmCntr = 0;  
   \                     ??CrossCallReturnLabel_178:
   \   0000C0   7409         MOV     A,#0x9
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   1988                  
   1989                  //Update the entry
   1990                  osal_nv_write(keyNvIndex,0,sizeof(APSME_TCLKDevEntry_t), &TCLKDevEntry );
   \                     ??CrossCallReturnLabel_179:
   \   0000C8                ; Setup parameters for call to function osal_nv_write
   \   0000C8   78..         MOV     R0,#?V0
   \   0000CA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CD   75..13       MOV     ?V0,#0x13
   \   0000D0   75..00       MOV     ?V1,#0x0
   \   0000D3   78..         MOV     R0,#?V0
   \   0000D5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D8   7C00         MOV     R4,#0x0
   \   0000DA   7D00         MOV     R5,#0x0
   \   0000DC   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000DF   7404         MOV     A,#0x4
   \   0000E1   12....       LCALL   ?DEALLOC_XSTACK8
   1991                }
   1992                
   1993                bdb_TCAddJoiningDevice(device.parentAddr,device.extAddr);
   \                     ??ZDSecMgrUpdateDeviceInd_3:
   \   0000E4                ; Setup parameters for call to function bdb_TCAddJoiningDevice
   \   0000E4   7403         MOV     A,#0x3
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   12....       LCALL   ?Subroutine32 & 0xFFFF
   1994          #endif
   1995              
   1996              }
   \                     ??CrossCallReturnLabel_36:
   \   0000EC   7405         MOV     A,#0x5
   \   0000EE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F1   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   0000F4   12....       LCALL   `??bdb_TCAddJoiningDevice::?relay`; Banked call to: bdb_TCAddJoiningDevice
   1997          
   1998              ZDSecMgrDeviceJoin( &device );
   \                     ??ZDSecMgrUpdateDeviceInd_2:
   \   0000F7                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   0000F7   7401         MOV     A,#0x1
   \   0000F9   12....       LCALL   ?XSTACK_DISP101_8
   \   0000FC   12....       LCALL   `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   1999            }
   2000          }
   \                     ??ZDSecMgrUpdateDeviceInd_0:
   \   0000FF   741C         MOV     A,#0x1c
   \   000101   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   2001          
   2002          /******************************************************************************
   2003           * @fn          ZDSecMgrRemoveDeviceInd
   2004           *
   2005           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2006           *
   2007           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2008           *
   2009           * @return      none
   2010           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2011          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2012          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2013            ZDSecMgrDevice_t device;
   2014          
   2015            // only accept from Trust Center
   2016            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000013   702F         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2017            {
   2018              // look up NWK address
   2019              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000015   EA           MOV     A,R2
   \   000016   2404         ADD     A,#0x4
   \   000018   FE           MOV     R6,A
   \   000019   E4           CLR     A
   \   00001A   3B           ADDC    A,R3
   \   00001B   FF           MOV     R7,A
   \   00001C                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001C   AC..         MOV     R4,?XSP + 0
   \   00001E   AD..         MOV     R5,?XSP + 1
   \   000020   EE           MOV     A,R6
   \   000021   FA           MOV     R2,A
   \   000022   EF           MOV     A,R7
   \   000023   FB           MOV     R3,A
   \   000024   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000027   E9           MOV     A,R1
   \   000028   6401         XRL     A,#0x1
   \   00002A   7018         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2020              {
   2021                device.parentAddr = NLME_GetShortAddr();
   \   00002C                ; Setup parameters for call to function NLME_GetShortAddr
   \   00002C   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00002F   7404         MOV     A,#0x4
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   12....       LCALL   ??Subroutine73_0 & 0xFFFF
   2022                device.extAddr    = ind->childExtAddr;
   2023          
   2024                // remove device
   2025                ZDSecMgrDeviceRemove( &device );
   2026              }
   2027            }
   \                     ??CrossCallReturnLabel_185:
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   EE           MOV     A,R6
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   EF           MOV     A,R7
   \   00003E   12....       LCALL   ??Subroutine74_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000041   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2028          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000044   02....       LJMP    ?Subroutine8 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine73_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7402         MOV     A,#0x2
   \   000007   22           RET
   2029          
   2030          /******************************************************************************
   2031           * @fn          ZDSecMgrRequestKeyInd
   2032           *
   2033           * @brief       Process the ZDO_RequestKeyInd_t message.
   2034           *
   2035           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2036           *
   2037           * @return      none
   2038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2039          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2040          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2041            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F8           MOV     R0,A
   \   00000E   7401         MOV     A,#0x1
   \   000010   68           XRL     A,R0
   \   000011   6012         JZ      ??ZDSecMgrRequestKeyInd_0
   2042            {
   2043            }
   2044            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   7402         MOV     A,#0x2
   \   000015   68           XRL     A,R0
   \   000016   7005         JNZ     ??ZDSecMgrRequestKeyInd_1
   2045            {
   2046              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL   `??ZDSecMgrAppKeyReq::?relay`; Banked call to: ZDSecMgrAppKeyReq
   \   00001B   8008         SJMP    ??ZDSecMgrRequestKeyInd_0
   2047            }
   2048            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   \                     ??ZDSecMgrRequestKeyInd_1:
   \   00001D   7404         MOV     A,#0x4
   \   00001F   68           XRL     A,R0
   \   000020   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   2049            {
   2050              ZDSecMgrTclkReq( ind );
   \   000022                ; Setup parameters for call to function ZDSecMgrTclkReq
   \   000022   12....       LCALL   `??ZDSecMgrTclkReq::?relay`; Banked call to: ZDSecMgrTclkReq
   2051            }
   2052            //else ignore
   2053          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   000025   02....       LJMP    ??Subroutine63_0 & 0xFFFF
   2054          
   2055          
   2056          /******************************************************************************
   2057           * @fn          ZDSecMgrVerifyKeyInd
   2058           *
   2059           * @brief       Process the ZDO_VerifyKeyInd_t message.
   2060           *
   2061           * @param       ind - [in] ZDO_VerifyKeyInd_t indication
   2062           *
   2063           * @return      none
   2064           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2065          void ZDSecMgrVerifyKeyInd( ZDO_VerifyKeyInd_t* ind )
   \                     ZDSecMgrVerifyKeyInd:
   2066          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2067            ZDSecMgrAppConfKeyReq( ind );
   \   000004                ; Setup parameters for call to function ZDSecMgrAppConfKeyReq
   \   000004   12....       LCALL   `??ZDSecMgrAppConfKeyReq::?relay`; Banked call to: ZDSecMgrAppConfKeyReq
   2068          }
   \   000007   02....       LJMP    ??Subroutine63_0 & 0xFFFF
   2069          
   2070          
   2071          /******************************************************************************
   2072           * @fn          ZDSecMgrSwitchKeyInd
   2073           *
   2074           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2075           *
   2076           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2077           *
   2078           * @return      none
   2079           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2080          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2081          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2082            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2083          
   2084            // Save if nv
   2085            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   2086          }
   \   000014   02....       LJMP    ??Subroutine63_0 & 0xFFFF
   2087            
   2088          /******************************************************************************
   2089           * @fn          ZDSecMgrGenerateSeed
   2090           *
   2091           * @brief       Generate the seed for TC link keys and store it in Nv
   2092           *
   2093           * @param       SetDefault, force to use new seed
   2094           *
   2095           * @return      none
   2096           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2097          void ZDSecMgrGenerateSeed(uint8 SetDefault)
   \                     ZDSecMgrGenerateSeed:
   2098          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2099            uint8 SeedKey[SEC_KEY_LEN];  
   2100            
   2101            ZDSecMgrGenerateRndKey(SeedKey);
   \   00000C                ; Setup parameters for call to function ZDSecMgrGenerateRndKey
   \   00000C   AA..         MOV     R2,?XSP + 0
   \   00000E   AB..         MOV     R3,?XSP + 1
   \   000010   12....       LCALL   `??ZDSecMgrGenerateRndKey::?relay`; Banked call to: ZDSecMgrGenerateRndKey
   2102            
   2103            if((SUCCESS == osal_nv_item_init(ZCD_NV_TCLK_SEED,SEC_KEY_LEN,SeedKey)) && SetDefault)
   \   000013                ; Setup parameters for call to function osal_nv_item_init
   \   000013   A8..         MOV     R0,?XSP + 0
   \   000015   A9..         MOV     R1,?XSP + 1
   \   000017   88..         MOV     ?V0,R0
   \   000019   89..         MOV     ?V1,R1
   \   00001B   78..         MOV     R0,#?V0
   \   00001D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000020   7C10         MOV     R4,#0x10
   \   000022   7D00         MOV     R5,#0x0
   \   000024   7A01         MOV     R2,#0x1
   \   000026   7B01         MOV     R3,#0x1
   \   000028   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000030   E9           MOV     A,R1
   \   000031   7023         JNZ     ??ZDSecMgrGenerateSeed_0
   \   000033   EE           MOV     A,R6
   \   000034   6020         JZ      ??ZDSecMgrGenerateSeed_0
   2104            {
   2105              //Force to use a new seed
   2106              osal_nv_write(ZCD_NV_TCLK_SEED,0,SEC_KEY_LEN,SeedKey);
   \   000036                ; Setup parameters for call to function osal_nv_write
   \   000036   78..         MOV     R0,#?V0
   \   000038   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003B   75..10       MOV     ?V0,#0x10
   \   00003E   75..00       MOV     ?V1,#0x0
   \   000041   78..         MOV     R0,#?V0
   \   000043   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000046   7C00         MOV     R4,#0x0
   \   000048   7D00         MOV     R5,#0x0
   \   00004A   7A01         MOV     R2,#0x1
   \   00004C   7B01         MOV     R3,#0x1
   \   00004E   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000051   7404         MOV     A,#0x4
   \   000053   12....       LCALL   ?DEALLOC_XSTACK8
   2107            }
   2108          
   2109            osal_memset(SeedKey,0,SEC_KEY_LEN);
   \                     ??ZDSecMgrGenerateSeed_0:
   \   000056                ; Setup parameters for call to function osal_memset
   \   000056   7C10         MOV     R4,#0x10
   \   000058   7D00         MOV     R5,#0x0
   \   00005A   7900         MOV     R1,#0x0
   \   00005C   AA..         MOV     R2,?XSP + 0
   \   00005E   AB..         MOV     R3,?XSP + 1
   \   000060   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2110          }
   \   000063   7410         MOV     A,#0x10
   \   000065   80..         SJMP    ??Subroutine71_0
   2111          
   2112          
   2113          /******************************************************************************
   2114           * @fn          ZDSecMgrGenerateKeyFromSeed
   2115           *
   2116           * @brief       Generate the TC link key for an specific device usign seed and ExtAddr
   2117           *
   2118           * @param       [in]  extAddr  
   2119           * @param       [in]  shift    number of byte shifts that the seed will do to 
   2120           *                             generate a new key for the same device. 
   2121           *                             This value must be less than SEC_KEY_LEN
   2122           * @param       [out] key      buffer in which the key will be copied
   2123           *
   2124           * @return      none
   2125           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2126          void ZDSecMgrGenerateKeyFromSeed(uint8 *extAddr, uint8 shift, uint8 *key)
   \                     ZDSecMgrGenerateKeyFromSeed:
   2127          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V8,R2
   \   00000C   8B..         MOV     ?V9,R3
   \   00000E   89..         MOV     ?V2,R1
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   2128            uint8 i;
   2129            uint8 tempKey[SEC_KEY_LEN];
   2130            
   2131            if((key != NULL) && (extAddr != NULL))
   \   000014   EE           MOV     A,R6
   \   000015   4F           ORL     A,R7
   \   000016   7003         JNZ     $+5
   \   000018   02....       LJMP    ??ZDSecMgrGenerateKeyFromSeed_0 & 0xFFFF
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V9
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrGenerateKeyFromSeed_0 & 0xFFFF
   2132            {
   2133              //Read the key
   2134              osal_nv_read(ZCD_NV_TCLK_SEED,0,SEC_KEY_LEN,tempKey);
   \   000023                ; Setup parameters for call to function osal_nv_read
   \   000023   A8..         MOV     R0,?XSP + 0
   \   000025   A9..         MOV     R1,?XSP + 1
   \   000027   88..         MOV     ?V0,R0
   \   000029   89..         MOV     ?V1,R1
   \   00002B   78..         MOV     R0,#?V0
   \   00002D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000030   75..10       MOV     ?V0,#0x10
   \   000033   75..00       MOV     ?V1,#0x0
   \   000036   78..         MOV     R0,#?V0
   \   000038   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003B   7C00         MOV     R4,#0x0
   \   00003D   7D00         MOV     R5,#0x0
   \   00003F   7A01         MOV     R2,#0x1
   \   000041   7B01         MOV     R3,#0x1
   \   000043   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000046   7404         MOV     A,#0x4
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   2135          
   2136              //shift the seed
   2137              osal_memcpy(key, &tempKey[shift], SEC_KEY_LEN - shift);
   \   00004B   85....       MOV     ?V0,?V2
   \   00004E                ; Setup parameters for call to function osal_memcpy
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   E582         MOV     A,DPL
   \   000056   25..         ADD     A,?V0
   \   000058   F5..         MOV     ?V4,A
   \   00005A   E4           CLR     A
   \   00005B   3583         ADDC    A,DPH
   \   00005D   F5..         MOV     ?V5,A
   \   00005F   75..00       MOV     ?V6,#0x0
   \   000062   78..         MOV     R0,#?V4
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000067   7410         MOV     A,#0x10
   \   000069   C3           CLR     C
   \   00006A   95..         SUBB    A,?V0
   \   00006C   FC           MOV     R4,A
   \   00006D   95E0         SUBB    A,0xE0 /* A   */
   \   00006F   FD           MOV     R5,A
   \   000070   EE           MOV     A,R6
   \   000071   FA           MOV     R2,A
   \   000072   EF           MOV     A,R7
   \   000073   FB           MOV     R3,A
   \   000074   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000077   7403         MOV     A,#0x3
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   2138              osal_memcpy(&key[SEC_KEY_LEN - shift], tempKey, shift);
   \   00007C                ; Setup parameters for call to function osal_memcpy
   \   00007C   A8..         MOV     R0,?XSP + 0
   \   00007E   A9..         MOV     R1,?XSP + 1
   \   000080   88..         MOV     ?V4,R0
   \   000082   89..         MOV     ?V5,R1
   \   000084   78..         MOV     R0,#?V4
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000089   AC..         MOV     R4,?V2
   \   00008B   7D00         MOV     R5,#0x0
   \   00008D   C3           CLR     C
   \   00008E   E4           CLR     A
   \   00008F   95..         SUBB    A,?V0
   \   000091   F8           MOV     R0,A
   \   000092   95E0         SUBB    A,0xE0 /* A   */
   \   000094   F9           MOV     R1,A
   \   000095   EE           MOV     A,R6
   \   000096   28           ADD     A,R0
   \   000097   F8           MOV     R0,A
   \   000098   EF           MOV     A,R7
   \   000099   39           ADDC    A,R1
   \   00009A   F9           MOV     R1,A
   \   00009B   E8           MOV     A,R0
   \   00009C   2410         ADD     A,#0x10
   \   00009E   FA           MOV     R2,A
   \   00009F   E4           CLR     A
   \   0000A0   39           ADDC    A,R1
   \   0000A1   FB           MOV     R3,A
   \   0000A2   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000A5   7403         MOV     A,#0x3
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   2139             
   2140              //Create the key from the seed
   2141              for(i = 0; i < Z_EXTADDR_LEN; i++)
   \   0000AA   7C00         MOV     R4,#0x0
   2142              {
   2143                key[i] ^= extAddr[i];
   \                     ??ZDSecMgrGenerateKeyFromSeed_1:
   \   0000AC   EC           MOV     A,R4
   \   0000AD   F8           MOV     R0,A
   \   0000AE   E5..         MOV     A,?V8
   \   0000B0   28           ADD     A,R0
   \   0000B1   FA           MOV     R2,A
   \   0000B2   E4           CLR     A
   \   0000B3   35..         ADDC    A,?V9
   \   0000B5   FB           MOV     R3,A
   \   0000B6   EE           MOV     A,R6
   \   0000B7   28           ADD     A,R0
   \   0000B8   F8           MOV     R0,A
   \   0000B9   E4           CLR     A
   \   0000BA   3F           ADDC    A,R7
   \   0000BB   F9           MOV     R1,A
   \   0000BC   8A82         MOV     DPL,R2
   \   0000BE   8B83         MOV     DPH,R3
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   FD           MOV     R5,A
   \   0000C2   8882         MOV     DPL,R0
   \   0000C4   8983         MOV     DPH,R1
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   6D           XRL     A,R5
   \   0000C8   12....       LCALL   ?Subroutine25 & 0xFFFF
   2144                key[i+Z_EXTADDR_LEN] ^= extAddr[i];
   2145              }
   \                     ??CrossCallReturnLabel_21:
   \   0000CB   FA           MOV     R2,A
   \   0000CC   8882         MOV     DPL,R0
   \   0000CE   8983         MOV     DPH,R1
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   6A           XRL     A,R2
   \   0000DA   F0           MOVX    @DPTR,A
   \   0000DB   0C           INC     R4
   \   0000DC   EC           MOV     A,R4
   \   0000DD   C3           CLR     C
   \   0000DE   9408         SUBB    A,#0x8
   \   0000E0   40CA         JC      ??ZDSecMgrGenerateKeyFromSeed_1
   2146            }
   2147          }
   \                     ??ZDSecMgrGenerateKeyFromSeed_0:
   \   0000E2   7410         MOV     A,#0x10
   \   0000E4   02....       LJMP    ?Subroutine5 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine78_0
   \   000003                ; // Fall through to label ??Subroutine78_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine78_0:
   \   000000   7F0A         MOV     R7,#0xa
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   2148          
   2149          
   2150          /******************************************************************************
   2151           * @fn          ZDSecMgrGenerateRndKey
   2152           *
   2153          * @brief       Generate a random key. NOTE: Random key is generated by osal_rand, refer to osal_rand to see the random properties of the key generated by this mean.
   2154           *
   2155           * @param       pKey - [out] Buffer pointer in which the key will be passed.
   2156           *
   2157           * @return      none
   2158           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2159          void ZDSecMgrGenerateRndKey(uint8* pKey)
   \                     ZDSecMgrGenerateRndKey:
   2160          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2161            uint16  temp;
   2162            uint8   index = 0;
   \   000009   75..00       MOV     ?V0,#0x0
   2163            
   2164            while(index < (SEC_KEY_LEN/2))
   2165            {
   2166              temp = osal_rand();
   \                     ??ZDSecMgrGenerateRndKey_0:
   \   00000C                ; Setup parameters for call to function osal_rand
   \   00000C   12....       LCALL   `??osal_rand::?relay`; Banked call to: osal_rand
   \   00000F   8A..         MOV     ?V2,R2
   \   000011   8B..         MOV     ?V3,R3
   2167              pKey[index*2]   = (uint8) (temp & 0x00FF);
   \   000013   AA..         MOV     R2,?V0
   \   000015   EA           MOV     A,R2
   \   000016   2A           ADD     A,R2
   \   000017   FA           MOV     R2,A
   \   000018   E4           CLR     A
   \   000019   33           RLC     A
   \   00001A   FB           MOV     R3,A
   \   00001B   EE           MOV     A,R6
   \   00001C   2A           ADD     A,R2
   \   00001D   F582         MOV     DPL,A
   \   00001F   EF           MOV     A,R7
   \   000020   3B           ADDC    A,R3
   \   000021   F583         MOV     DPH,A
   \   000023   E5..         MOV     A,?V2
   \   000025   F0           MOVX    @DPTR,A
   2168              pKey[index*2+1] = (uint8) ((temp >> 8) & 0x00FF);
   \   000026   A3           INC     DPTR
   \   000027   E5..         MOV     A,?V3
   \   000029   F0           MOVX    @DPTR,A
   2169              index++;
   \   00002A   05..         INC     ?V0
   2170            }
   \   00002C   E5..         MOV     A,?V0
   \   00002E   C3           CLR     C
   \   00002F   9408         SUBB    A,#0x8
   \   000031   40D9         JC      ??ZDSecMgrGenerateRndKey_0
   2171          }
   \   000033   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   2172          
   2173          
   2174          #if ( ZG_BUILD_COORDINATOR_TYPE )
   2175          /******************************************************************************
   2176           * @fn          ZDSecMgrUpdateNwkKey
   2177           *
   2178           * @brief       Load a new NWK key and trigger a network update to the dstAddr.
   2179           *
   2180           * @param       key       - [in] new NWK key
   2181           * @param       keySeqNum - [in] new NWK key sequence number
   2182           *
   2183           * @return      ZStatus_t
   2184           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2185          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrUpdateNwkKey:
   2186          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 26
   \   000005   74E6         MOV     A,#-0x1a
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V1,R1
   2187            ZStatus_t               status;
   2188            APSME_TransportKeyReq_t req;
   2189          
   2190            // initialize common elements of local variables
   2191            req.keyType   = KEY_TYPE_NWK;
   \   000010   7402         MOV     A,#0x2
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   7401         MOV     A,#0x1
   \   000017   F0           MOVX    @DPTR,A
   2192          
   2193            req.dstAddr   = dstAddr;
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   EC           MOV     A,R4
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   ED           MOV     A,R5
   \   000022   F0           MOVX    @DPTR,A
   2194            req.keySeqNum = keySeqNum;
   \   000023   7403         MOV     A,#0x3
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E9           MOV     A,R1
   \   000029   F0           MOVX    @DPTR,A
   2195            req.key       = key;
   \   00002A   7404         MOV     A,#0x4
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   EE           MOV     A,R6
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   EF           MOV     A,R7
   \   000033   F0           MOVX    @DPTR,A
   2196            req.extAddr   = NULL;
   \   000034   7406         MOV     A,#0x6
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   E4           CLR     A
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   A3           INC     DPTR
   \   00003C   F0           MOVX    @DPTR,A
   2197            req.nwkSecure = TRUE;
   \   00003D   740A         MOV     A,#0xa
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   7401         MOV     A,#0x1
   \   000044   F0           MOVX    @DPTR,A
   2198            req.tunnel    = NULL;
   \   000045   740B         MOV     A,#0xb
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   F0           MOVX    @DPTR,A
   2199          
   2200            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2201            {
   2202              // Broadcast transport NWK key
   2203              if (( dstAddr == NWK_BROADCAST_SHORTADDR_DEVALL ) ||
   2204                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVZCZR) ||
   2205                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVRXON))
   \   00004E   74FF         MOV     A,#-0x1
   \   000050   6C           XRL     A,R4
   \   000051   7003         JNZ     ??ZDSecMgrUpdateNwkKey_0
   \   000053   74FF         MOV     A,#-0x1
   \   000055   6D           XRL     A,R5
   \                     ??ZDSecMgrUpdateNwkKey_0:
   \   000056   6014         JZ      ??ZDSecMgrUpdateNwkKey_1
   \   000058   74FC         MOV     A,#-0x4
   \   00005A   6C           XRL     A,R4
   \   00005B   7003         JNZ     ??ZDSecMgrUpdateNwkKey_2
   \   00005D   74FF         MOV     A,#-0x1
   \   00005F   6D           XRL     A,R5
   \                     ??ZDSecMgrUpdateNwkKey_2:
   \   000060   600A         JZ      ??ZDSecMgrUpdateNwkKey_1
   \   000062   74FD         MOV     A,#-0x3
   \   000064   6C           XRL     A,R4
   \   000065   7003         JNZ     ??ZDSecMgrUpdateNwkKey_3
   \   000067   74FF         MOV     A,#-0x1
   \   000069   6D           XRL     A,R5
   \                     ??ZDSecMgrUpdateNwkKey_3:
   \   00006A   7008         JNZ     ??ZDSecMgrUpdateNwkKey_4
   2206              {
   2207                req.apsSecure = FALSE;
   \                     ??ZDSecMgrUpdateNwkKey_1:
   \   00006C   7409         MOV     A,#0x9
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   E4           CLR     A
   \   000072   803A         SJMP    ??ZDSecMgrUpdateNwkKey_5
   2208                status = APSME_TransportKeyReq( &req );
   2209              }
   2210              else
   2211              {
   2212                AddrMgrEntry_t          addrEntry;
   2213          
   2214                addrEntry.user = ADDRMGR_USER_SECURITY;
   \                     ??ZDSecMgrUpdateNwkKey_4:
   \   000074   740D         MOV     A,#0xd
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   7402         MOV     A,#0x2
   \   00007B   F0           MOVX    @DPTR,A
   2215                addrEntry.nwkAddr = dstAddr;
   \   00007C   740E         MOV     A,#0xe
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   EC           MOV     A,R4
   \   000082   F0           MOVX    @DPTR,A
   \   000083   A3           INC     DPTR
   \   000084   ED           MOV     A,R5
   \   000085   F0           MOVX    @DPTR,A
   2216          
   2217                status = ZFailure;
   \   000086   75..01       MOV     ?V0,#0x1
   2218          
   2219                if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \   000089                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000089   740D         MOV     A,#0xd
   \   00008B   12....       LCALL   ?XSTACK_DISP101_8
   \   00008E   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   000091   E9           MOV     A,R1
   \   000092   6401         XRL     A,#0x1
   \   000094   7021         JNZ     ??ZDSecMgrUpdateNwkKey_6
   2220                {
   2221                  req.extAddr = addrEntry.extAddr;
   \   000096   7410         MOV     A,#0x10
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   A882         MOV     R0,DPL
   \   00009D   A983         MOV     R1,DPH
   \   00009F   7406         MOV     A,#0x6
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   2222                  req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_156:
   \   0000A7   7409         MOV     A,#0x9
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   7401         MOV     A,#0x1
   2223                  status = APSME_TransportKeyReq( &req );
   2224                }
   2225              }
   2226            }
   \                     ??ZDSecMgrUpdateNwkKey_5:
   \   0000AE   12....       LCALL   ??Subroutine74_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   0000B1   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   0000B4   E9           MOV     A,R1
   \   0000B5   F5..         MOV     ?V0,A
   2227            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2228            {
   2229              req.apsSecure = FALSE;
   2230              status = APSME_TransportKeyReq( &req );
   2231            }
   2232          
   2233            SSP_UpdateNwkKey( key, keySeqNum );
   \                     ??ZDSecMgrUpdateNwkKey_6:
   \   0000B7                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   0000B7   A9..         MOV     R1,?V1
   \   0000B9   EE           MOV     A,R6
   \   0000BA   FA           MOV     R2,A
   \   0000BB   EF           MOV     A,R7
   \   0000BC   FB           MOV     R3,A
   \   0000BD   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2234          
   2235            // Save if nv
   2236            ZDApp_NVUpdate();
   \   0000C0                ; Setup parameters for call to function ZDApp_NVUpdate
   \   0000C0   12....       LCALL   `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   2237          
   2238            return status;
   \   0000C3   A9..         MOV     R1,?V0
   \   0000C5   741A         MOV     A,#0x1a
   \   0000C7   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   2239          }
   2240          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   2241          
   2242          #if ( ZG_BUILD_COORDINATOR_TYPE )
   2243          /******************************************************************************
   2244           * @fn          ZDSecMgrSwitchNwkKey
   2245           *
   2246           * @brief       Causes the NWK key to switch via a network command to the dstAddr.
   2247           *
   2248           * @param       keySeqNum - [in] new NWK key sequence number
   2249           *
   2250           * @return      ZStatus_t
   2251           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2252          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrSwitchNwkKey:
   2253          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   8A..         MOV     ?V0,R2
   \   00000E   8B..         MOV     ?V1,R3
   2254            ZStatus_t            status;
   2255            APSME_SwitchKeyReq_t req;
   2256          
   2257            // initialize common elements of local variables
   2258            req.dstAddr = dstAddr;
   \   000010   12....       LCALL   ?Subroutine23 & 0xFFFF
   2259            req.keySeqNum = keySeqNum;
   \                     ??CrossCallReturnLabel_183:
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   E9           MOV     A,R1
   \   000017   F0           MOVX    @DPTR,A
   2260          
   2261            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2262            {
   2263              // Broadcast switch NWK key
   2264              if (( dstAddr == NWK_BROADCAST_SHORTADDR_DEVALL ) ||
   2265                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVZCZR) ||
   2266                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVRXON))
   \   000018   74FF         MOV     A,#-0x1
   \   00001A   65..         XRL     A,?V0
   \   00001C   7004         JNZ     ??ZDSecMgrSwitchNwkKey_0
   \   00001E   74FF         MOV     A,#-0x1
   \   000020   65..         XRL     A,?V1
   \                     ??ZDSecMgrSwitchNwkKey_0:
   \   000022   6018         JZ      ??ZDSecMgrSwitchNwkKey_1
   \   000024   74FC         MOV     A,#-0x4
   \   000026   65..         XRL     A,?V0
   \   000028   7004         JNZ     ??ZDSecMgrSwitchNwkKey_2
   \   00002A   74FF         MOV     A,#-0x1
   \   00002C   65..         XRL     A,?V1
   \                     ??ZDSecMgrSwitchNwkKey_2:
   \   00002E   600C         JZ      ??ZDSecMgrSwitchNwkKey_1
   \   000030   74FD         MOV     A,#-0x3
   \   000032   65..         XRL     A,?V0
   \   000034   7004         JNZ     ??ZDSecMgrSwitchNwkKey_3
   \   000036   74FF         MOV     A,#-0x1
   \   000038   65..         XRL     A,?V1
   \                     ??ZDSecMgrSwitchNwkKey_3:
   \   00003A   7008         JNZ     ??ZDSecMgrSwitchNwkKey_4
   2267              {
   2268                req.apsSecure = FALSE;
   \                     ??ZDSecMgrSwitchNwkKey_1:
   \   00003C   7403         MOV     A,#0x3
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E4           CLR     A
   \   000042   802D         SJMP    ??ZDSecMgrSwitchNwkKey_5
   2269                status = APSME_SwitchKeyReq( &req );
   2270              }
   2271              else
   2272              {
   2273                AddrMgrEntry_t          addrEntry;
   2274          
   2275                addrEntry.user = ADDRMGR_USER_SECURITY;
   \                     ??ZDSecMgrSwitchNwkKey_4:
   \   000044   7404         MOV     A,#0x4
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   7402         MOV     A,#0x2
   \   00004B   F0           MOVX    @DPTR,A
   2276                addrEntry.nwkAddr = dstAddr;
   \   00004C   7405         MOV     A,#0x5
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   12....       LCALL   ?Subroutine26 & 0xFFFF
   2277          
   2278                status = ZFailure;
   \                     ??CrossCallReturnLabel_26:
   \   000054   7E01         MOV     R6,#0x1
   2279          
   2280                if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \   000056                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000056   7404         MOV     A,#0x4
   \   000058   12....       LCALL   ?XSTACK_DISP101_8
   \   00005B   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00005E   E9           MOV     A,R1
   \   00005F   6401         XRL     A,#0x1
   \   000061   7016         JNZ     ??ZDSecMgrSwitchNwkKey_6
   2281                {
   2282                  req.dstAddr = addrEntry.nwkAddr;
   \   000063   7405         MOV     A,#0x5
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   12....       LCALL   ?Subroutine22 & 0xFFFF
   2283                  req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_160:
   \   00006B   7403         MOV     A,#0x3
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   EE           MOV     A,R6
   2284                  status = APSME_SwitchKeyReq( &req );
   2285                }
   2286              }
   2287            }
   \                     ??ZDSecMgrSwitchNwkKey_5:
   \   000071   12....       LCALL   ??Subroutine74_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000074   12....       LCALL   `??APSME_SwitchKeyReq::?relay`; Banked call to: APSME_SwitchKeyReq
   \   000077   E9           MOV     A,R1
   \   000078   FE           MOV     R6,A
   2288            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2289            {
   2290              req.apsSecure = FALSE;
   2291              status = APSME_SwitchKeyReq( &req );
   2292            }
   2293          
   2294            if ( dstAddr >= NWK_BROADCAST_SHORTADDR_DEVZCZR)
   \                     ??ZDSecMgrSwitchNwkKey_6:
   \   000079   C3           CLR     C
   \   00007A   E5..         MOV     A,?V0
   \   00007C   94FC         SUBB    A,#-0x4
   \   00007E   E5..         MOV     A,?V1
   \   000080   94FF         SUBB    A,#-0x1
   \   000082   400B         JC      ??ZDSecMgrSwitchNwkKey_7
   2295            {
   2296              zgSwitchCoordKey = TRUE;
   \   000084   90....       MOV     DPTR,#zgSwitchCoordKey
   \   000087   7401         MOV     A,#0x1
   \   000089   F0           MOVX    @DPTR,A
   2297              zgSwitchCoordKeyIndex = keySeqNum;
   \   00008A   EF           MOV     A,R7
   \   00008B   90....       MOV     DPTR,#zgSwitchCoordKeyIndex
   \   00008E   F0           MOVX    @DPTR,A
   2298            }
   2299            // Save if nv
   2300            ZDApp_NVUpdate();
   \                     ??ZDSecMgrSwitchNwkKey_7:
   \   00008F                ; Setup parameters for call to function ZDApp_NVUpdate
   \   00008F   12....       LCALL   `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   2301          
   2302            return status;
   \   000092   EE           MOV     A,R6
   \   000093   F9           MOV     R1,A
   \   000094   02....       LJMP    ?Subroutine4 & 0xFFFF
   2303          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine73_0
   \   000006                ; // Fall through to label ??Subroutine73_0
   2304          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   2305          
   2306          /******************************************************************************
   2307           * @fn          ZDSecMgrRequestAppKey
   2308           *
   2309           * @brief       Request an application key with partner.
   2310           *
   2311           * @param       partExtAddr - [in] partner extended address
   2312           *
   2313           * @return      ZStatus_t
   2314           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2315          ZStatus_t ZDSecMgrRequestAppKey( uint8 *partExtAddr )
   \                     ZDSecMgrRequestAppKey:
   2316          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV     A,#-0x4
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2317            ZStatus_t status;
   2318            APSME_RequestKeyReq_t req;
   2319          
   2320            req.dstAddr = 0;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   2321            req.keyType = KEY_TYPE_APP_MASTER;
   \   000011   04           INC     A
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   7402         MOV     A,#0x2
   \   000017   F0           MOVX    @DPTR,A
   2322          
   2323            req.partExtAddr = partExtAddr;
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine12 & 0xFFFF
   2324            status = APSME_RequestKeyReq( &req );
   2325          
   2326            return status;
   \                     ??CrossCallReturnLabel_187:
   \   00001E   12....       LCALL   `??APSME_RequestKeyReq::?relay`; Banked call to: APSME_RequestKeyReq
   \   000021   7404         MOV     A,#0x4
   \   000023   02....       LJMP    ?Subroutine9 & 0xFFFF
   2327          }
   2328          
   2329          #if ( ZG_BUILD_JOINING_TYPE )
   2330          /******************************************************************************
   2331           * @fn          ZDSecMgrSetupPartner
   2332           *
   2333           * @brief       Setup for application key partner.
   2334           *
   2335           * @param       partNwkAddr - [in] partner network address
   2336           *
   2337           * @return      ZStatus_t
   2338           */
   2339          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   2340          {
   2341            AddrMgrEntry_t entry;
   2342            ZStatus_t      status;
   2343          
   2344            status = ZFailure;
   2345          
   2346            // update the address manager
   2347            entry.user    = ADDRMGR_USER_SECURITY;
   2348            entry.nwkAddr = partNwkAddr;
   2349            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   2350          
   2351            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   2352            {
   2353              status = ZSuccess;
   2354          
   2355              // check for address discovery
   2356              if ( partNwkAddr == INVALID_NODE_ADDR )
   2357              {
   2358                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2359              }
   2360              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   2361              {
   2362                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2363              }
   2364            }
   2365          
   2366            return status;
   2367          }
   2368          #endif // ( ZG_BUILD_JOINING_TYPE )
   2369          
   2370          #if ( ZG_BUILD_COORDINATOR_TYPE )
   2371          /******************************************************************************
   2372           * @fn          ZDSecMgrAppKeyTypeSet
   2373           *
   2374           * @brief       Set application key type.
   2375           *
   2376           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   2377           *                                                   KEY_TYPE_APP_LINK@3
   2378           *
   2379           * @return      ZStatus_t
   2380           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2381          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   \                     ZDSecMgrAppKeyTypeSet:
   2382          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2383            if ( keyType == KEY_TYPE_APP_LINK )
   \   000006   7403         MOV     A,#0x3
   \   000008   68           XRL     A,R0
   \   000009   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   00000C   7004         JNZ     ??ZDSecMgrAppKeyTypeSet_0
   2384            {
   2385              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   \   00000E   7403         MOV     A,#0x3
   \   000010   8002         SJMP    ??ZDSecMgrAppKeyTypeSet_1
   2386            }
   2387            else
   2388            {
   2389              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   \                     ??ZDSecMgrAppKeyTypeSet_0:
   \   000012   7402         MOV     A,#0x2
   2390            }
   \                     ??ZDSecMgrAppKeyTypeSet_1:
   \   000014   02....       LJMP    ?Subroutine2 & 0xFFFF
   2391          
   2392            return ZSuccess;
   2393          }
   2394          #endif
   2395          
   2396          /******************************************************************************
   2397           * ZigBee Device Security Manager - Stub Implementations
   2398           */
   2399          
   2400          
   2401          /******************************************************************************
   2402           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   2403           *
   2404           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   2405           *
   2406           * @param       extAddr - [in] EXT address
   2407           * @param       data    - [in] APSME_LinkKeyData_t
   2408           *
   2409           * @return      ZStatus_t
   2410           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000003                REQUIRE ??Subroutine60_0
   \   000003                ; // Fall through to label ??Subroutine60_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   F582         MOV     DPL,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V3
   \   000005                REQUIRE ??Subroutine68_0
   \   000005                ; // Fall through to label ??Subroutine68_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine68_0:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine69_0
   \   000002                ; // Fall through to label ??Subroutine69_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2411          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   2412          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   2413            ZStatus_t status;
   2414            ZDSecMgrEntry_t* entry;
   2415            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   2416            uint16 Index;
   2417          
   2418            // lookup entry index for specified EXT address
   2419            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP100_8
   \   000013   88..         MOV     ?V0,R0
   \   000015   89..         MOV     ?V1,R1
   \   000017   78..         MOV     R0,#?V0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP102_8
   \   000021   12....       LCALL   `??ZDSecMgrEntryLookupExtGetIndex::?relay`; Banked call to: ZDSecMgrEntryLookupExtGetIndex
   \   000024   7402         MOV     A,#0x2
   \   000026   12....       LCALL   ?DEALLOC_XSTACK8
   \   000029   E9           MOV     A,R1
   \   00002A   F5..         MOV     ?V0,A
   2420          
   2421            if ( status == ZSuccess )
   \   00002C   6003         JZ      $+5
   \   00002E   02....       LJMP    ??CrossCallReturnLabel_180 & 0xFFFF
   2422            {
   2423              // point to NV item
   2424              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E0           MOVX    A,@DPTR
   \   000037   2401         ADD     A,#0x1
   \   000039   F8           MOV     R0,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   3402         ADDC    A,#0x2
   \   00003E   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   2425          
   2426              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??CrossCallReturnLabel_157:
   \   000046                ; Setup parameters for call to function osal_mem_alloc
   \   000046   7A18         MOV     R2,#0x18
   \   000048   7B00         MOV     R3,#0x0
   \   00004A   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00004D   8A..         MOV     ?V2,R2
   \   00004F   8B..         MOV     ?V3,R3
   2427          
   2428              if (pApsLinkKey != NULL)
   \   000051   EA           MOV     A,R2
   \   000052   45..         ORL     A,?V3
   \   000054   7003         JNZ     $+5
   \   000056   02....       LJMP    ??CrossCallReturnLabel_180 & 0xFFFF
   2429              {
   2430                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   2431                osal_nv_read( entry->keyNvId, 0,
   2432                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000059                ; Setup parameters for call to function osal_nv_read
   \   000059   78..         MOV     R0,#?V2
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005E   75..18       MOV     ?V4,#0x18
   \   000061   75..00       MOV     ?V5,#0x0
   \   000064   78..         MOV     R0,#?V4
   \   000066   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000069   7C00         MOV     R4,#0x0
   \   00006B   7D00         MOV     R5,#0x0
   \   00006D   7404         MOV     A,#0x4
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000075   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000078   7404         MOV     A,#0x4
   \   00007A   12....       LCALL   ?DEALLOC_XSTACK8
   2433          
   2434                // set new values of the key
   2435                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   00007D                ; Setup parameters for call to function osal_memcpy
   \   00007D   8E..         MOV     ?V4,R6
   \   00007F   8F..         MOV     ?V5,R7
   \   000081   75..00       MOV     ?V6,#0x0
   \   000084   78..         MOV     R0,#?V4
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000089   7C10         MOV     R4,#0x10
   \   00008B   7D00         MOV     R5,#0x0
   \   00008D   AA..         MOV     R2,?V2
   \   00008F   AB..         MOV     R3,?V3
   \   000091   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000094   7403         MOV     A,#0x3
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   2436                pApsLinkKey->rxFrmCntr = 0;
   \   000099   E5..         MOV     A,?V2
   \   00009B   2414         ADD     A,#0x14
   \   00009D   12....       LCALL   ?Subroutine28 & 0xFFFF
   2437                pApsLinkKey->txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_181:
   \   0000A0   E5..         MOV     A,?V2
   \   0000A2   2410         ADD     A,#0x10
   \   0000A4   12....       LCALL   ?Subroutine28 & 0xFFFF
   2438          
   2439                osal_nv_write( entry->keyNvId, 0,
   2440                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \                     ??CrossCallReturnLabel_182:
   \   0000A7                ; Setup parameters for call to function osal_nv_write
   \   0000A7   78..         MOV     R0,#?V2
   \   0000A9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AC   75..18       MOV     ?V4,#0x18
   \   0000AF   75..00       MOV     ?V5,#0x0
   \   0000B2   78..         MOV     R0,#?V4
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B7   7C00         MOV     R4,#0x0
   \   0000B9   7D00         MOV     R5,#0x0
   \   0000BB   7404         MOV     A,#0x4
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   0000C3   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000C6   7404         MOV     A,#0x4
   \   0000C8   12....       LCALL   ?DEALLOC_XSTACK8
   2441          
   2442                // clear copy of key in RAM
   2443                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   0000CB                ; Setup parameters for call to function osal_memset
   \   0000CB   7C18         MOV     R4,#0x18
   \   0000CD   7D00         MOV     R5,#0x0
   \   0000CF   7900         MOV     R1,#0x0
   \   0000D1   AA..         MOV     R2,?V2
   \   0000D3   AB..         MOV     R3,?V3
   \   0000D5   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2444          
   2445                osal_mem_free(pApsLinkKey);
   \   0000D8                ; Setup parameters for call to function osal_mem_free
   \   0000D8   AA..         MOV     R2,?V2
   \   0000DA   AB..         MOV     R3,?V3
   \   0000DC   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000DF   85..82       MOV     DPL,?XSP + 0
   \   0000E2   85..83       MOV     DPH,?XSP + 1
   \   0000E5   12....       LCALL   ?Subroutine36 & 0xFFFF
   2446          
   2447                // set initial values for counters in RAM
   2448                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   2449                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   2450              }
   2451            }
   \                     ??CrossCallReturnLabel_45:
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   0000ED   E8           MOV     A,R0
   \   0000EE   75F009       MOV     B,#0x9
   \   0000F1   A4           MUL     AB
   \   0000F2   F8           MOV     R0,A
   \   0000F3   AAF0         MOV     R2,B
   \   0000F5   75F009       MOV     B,#0x9
   \   0000F8   E9           MOV     A,R1
   \   0000F9   A4           MUL     AB
   \   0000FA   2A           ADD     A,R2
   \   0000FB   F9           MOV     R1,A
   \   0000FC   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   0000FE   28           ADD     A,R0
   \   0000FF   FA           MOV     R2,A
   \   000100   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   000102   39           ADDC    A,R1
   \   000103   FB           MOV     R3,A
   \   000104   EA           MOV     A,R2
   \   000105   24F7         ADD     A,#-0x9
   \   000107   F582         MOV     DPL,A
   \   000109   EB           MOV     A,R3
   \   00010A   34ED         ADDC    A,#-0x13
   \   00010C   F583         MOV     DPH,A
   \   00010E   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000111   24FB         ADD     A,#-0x5
   \   000113   F582         MOV     DPL,A
   \   000115   EB           MOV     A,R3
   \   000116   34ED         ADDC    A,#-0x13
   \   000118   12....       LCALL   ??Subroutine68_0 & 0xFFFF
   2452          
   2453            return status;
   \                     ??CrossCallReturnLabel_180:
   \   00011B   A9..         MOV     R1,?V0
   \   00011D   7404         MOV     A,#0x4
   \   00011F                REQUIRE ?Subroutine6
   \   00011F                ; // Fall through to label ?Subroutine6
   2454          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine75_0
   \   000003                ; // Fall through to label ??Subroutine75_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine75_0:
   \   000000   7F07         MOV     R7,#0x7
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   F9           MOV     R1,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007                REQUIRE ??Subroutine76_0
   \   000007                ; // Fall through to label ??Subroutine76_0
   2455          
   2456          /******************************************************************************
   2457           * @fn          ZDSecMgrAuthenticationSet
   2458           *
   2459           * @brief       Mark the specific device as authenticated or not
   2460           *
   2461           * @param       extAddr - [in] EXT address
   2462           * @param       option  - [in] authenticated or not
   2463           *
   2464           * @return      ZStatus_t
   2465           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2466          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   2467          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2468            ZStatus_t        status;
   2469            ZDSecMgrEntry_t* entry;
   2470          
   2471          
   2472            // lookup entry index for specified EXT address
   2473            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   AC..         MOV     R4,?XSP + 0
   \   00000E   AD..         MOV     R5,?XSP + 1
   \   000010   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000013   E9           MOV     A,R1
   \   000014   F9           MOV     R1,A
   2474          
   2475            if ( status == ZSuccess )
   \   000015   7005         JNZ     ??ZDSecMgrAuthenticationSet_0
   2476            {
   2477              entry->authenticateOption = option;
   \   000017   12....       LCALL   ?Subroutine35 & 0xFFFF
   2478            }
   \                     ??CrossCallReturnLabel_40:
   \   00001A   EE           MOV     A,R6
   \   00001B   F0           MOVX    @DPTR,A
   2479          
   2480            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   00001C   02....       LJMP    ?Subroutine7 & 0xFFFF
   2481          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET
   2482          
   2483          /******************************************************************************
   2484           * @fn          ZDSecMgrAuthenticationCheck
   2485           *
   2486           * @brief       Check if the specific device has been authenticated or not
   2487           *              For non-trust center device, always return TRUE
   2488           *
   2489           * @param       shortAddr - [in] short address
   2490           *
   2491           * @return      TRUE @ authenticated with CBKE
   2492           *              FALSE @ not authenticated
   2493           */
   2494          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2495          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   2496          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2497          #if defined (TC_LINKKEY_JOIN)
   2498          
   2499            ZDSecMgrEntry_t* entry;
   2500            uint8 extAddr[Z_EXTADDR_LEN];
   2501          
   2502            // If the local device is not the trust center, always return TRUE
   2503            APSME_GetRequest( apsTrustCenterAddress, 0, extAddr );
   \   00000E                ; Setup parameters for call to function APSME_GetRequest
   \   00000E   7404         MOV     A,#0x4
   \   000010   12....       LCALL   ?XSTACK_DISP102_8
   \   000013   7A00         MOV     R2,#0x0
   \   000015   7B00         MOV     R3,#0x0
   \   000017   79AB         MOV     R1,#-0x55
   \   000019   12....       LCALL   `??APSME_GetRequest::?relay`; Banked call to: APSME_GetRequest
   2504            if ( ! osal_ExtAddrEqual( extAddr , NLME_GetExtAddr() ) )
   \   00001C                ; Setup parameters for call to function NLME_GetExtAddr
   \   00001C   12....       LCALL   `??NLME_GetExtAddr::?relay`; Banked call to: NLME_GetExtAddr
   \   00001F   8A..         MOV     ?V0,R2
   \   000021   8B..         MOV     ?V1,R3
   \   000023   AC..         MOV     R4,?V0
   \   000025   AD..         MOV     R5,?V1
   \   000027                ; Setup parameters for call to function sAddrExtCmp
   \   000027   7404         MOV     A,#0x4
   \   000029   12....       LCALL   ?XSTACK_DISP101_8
   \   00002C   12....       LCALL   `??sAddrExtCmp::?relay`; Banked call to: sAddrExtCmp
   \   00002F   E9           MOV     A,R1
   \   000030   603B         JZ      ??ZDSecMgrAuthenticationCheck_0
   2505            {
   2506              return TRUE;
   2507            }
   2508            // Otherwise, check the authentication option
   2509            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   \   000032                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000032   7404         MOV     A,#0x4
   \   000034   12....       LCALL   ?XSTACK_DISP102_8
   \   000037   EE           MOV     A,R6
   \   000038   FA           MOV     R2,A
   \   000039   EF           MOV     A,R7
   \   00003A   FB           MOV     R3,A
   \   00003B   12....       LCALL   `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   00003E   E9           MOV     A,R1
   \   00003F   6015         JZ      ??ZDSecMgrAuthenticationCheck_1
   2510            {
   2511              // lookup entry index for specified EXT address
   2512              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   \   000041                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000041   AC..         MOV     R4,?XSP + 0
   \   000043   AD..         MOV     R5,?XSP + 1
   \   000045   7404         MOV     A,#0x4
   \   000047   12....       LCALL   ?XSTACK_DISP101_8
   \   00004A   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   00004D   E9           MOV     A,R1
   \   00004E   700D         JNZ     ??ZDSecMgrAuthenticationCheck_2
   2513              {
   2514                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   \   000050   12....       LCALL   ?Subroutine35 & 0xFFFF
   2515                {
   2516                  return TRUE;
   2517                }
   2518                else
   2519                {
   2520                  return FALSE;
   2521                }
   2522              }
   \                     ??CrossCallReturnLabel_41:
   \   000053   E0           MOVX    A,@DPTR
   \   000054   7017         JNZ     ??ZDSecMgrAuthenticationCheck_0
   2523              else
   2524              {
   2525                // it may have been secured with TCLK only
   2526                uint16    ami;
   2527          
   2528                // lookup address index in address manager
   2529                if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   2530                {
   2531                  return TRUE;
   2532                }
   2533              }
   2534            }
   2535            return FALSE;
   \                     ??ZDSecMgrAuthenticationCheck_1:
   \   000056   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAuthenticationCheck_3:
   \   000058   740C         MOV     A,#0xc
   \   00005A   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   \                     ??ZDSecMgrAuthenticationCheck_2:
   \   00005D                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?XSTACK_DISP102_8
   \   000062   7404         MOV     A,#0x4
   \   000064   12....       LCALL   ?XSTACK_DISP101_8
   \   000067   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   00006A   E9           MOV     A,R1
   \   00006B   70E9         JNZ     ??ZDSecMgrAuthenticationCheck_1
   \                     ??ZDSecMgrAuthenticationCheck_0:
   \   00006D   7901         MOV     R1,#0x1
   \   00006F   80E7         SJMP    ??ZDSecMgrAuthenticationCheck_3
   2536          
   2537          #else
   2538            (void)shortAddr;  // Intentionally unreferenced parameter
   2539          
   2540            // For non AMI/SE Profile, perform no check and always return TRUE.
   2541            return TRUE;
   2542          
   2543          #endif // TC_LINKKEY_JOIN
   2544          }
   2545          
   2546          
   2547          /******************************************************************************
   2548           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   2549           *
   2550           * @brief       Get Key NV ID for specified NWK address.
   2551           *
   2552           * @param       extAddr - [in] EXT address
   2553           * @param       keyNvId - [out] NV ID
   2554           *
   2555           * @return      ZStatus_t
   2556           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2557          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   2558          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   2559            ZStatus_t status;
   2560            ZDSecMgrEntry_t* entry;
   2561          
   2562            // lookup entry index for specified NWK address
   2563            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000015   E9           MOV     A,R1
   \   000016   F9           MOV     R1,A
   2564          
   2565            if ( status == ZSuccess )
   \   000017   7013         JNZ     ??APSME_LinkKeyNVIdGet_0
   2566            {
   2567              // return the index to the NV table
   2568              *pKeyNvId = entry->keyNvId;
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   12....       LCALL   ?Subroutine29 & 0xFFFF
   2569            }
   \                     ??CrossCallReturnLabel_123:
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   EA           MOV     A,R2
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   EB           MOV     A,R3
   \   00002A   8007         SJMP    ??APSME_LinkKeyNVIdGet_1
   2570            else
   2571            {
   2572              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   00002C   8E82         MOV     DPL,R6
   \   00002E   8F83         MOV     DPH,R7
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000033   F0           MOVX    @DPTR,A
   2573            }
   2574          
   2575            return status;
   \   000034   02....       LJMP    ?Subroutine7 & 0xFFFF
   2576          }
   2577          
   2578          /******************************************************************************
   2579           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   2580           *
   2581           * @brief       Verifies if Link Key in NV has been set.
   2582           *
   2583           * @param       extAddr - [in] EXT address
   2584           *
   2585           * @return      TRUE - Link Key has been established
   2586           *              FALSE - Link Key in NV has default value.
   2587           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine67_0
   \   000006                ; // Fall through to label ??Subroutine67_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2588          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   2589          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2590            APSME_LinkKeyData_t *pKeyData;
   2591            uint16 apsLinkKeyNvId;
   2592            uint8 nullKey[SEC_KEY_LEN];
   2593            uint8 status = FALSE;
   \   00000E   75..00       MOV     ?V0,#0x0
   2594          
   2595            // initialize default vealue to compare to
   2596            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000011                ; Setup parameters for call to function osal_memset
   \   000011   7C10         MOV     R4,#0x10
   \   000013   7D00         MOV     R5,#0x0
   \   000015   7900         MOV     R1,#0x0
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP101_8
   \   00001C   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2597          
   2598            // check for APS link NV ID
   2599            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \   00001F                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   00001F   AC..         MOV     R4,?XSP + 0
   \   000021   AD..         MOV     R5,?XSP + 1
   \   000023   EE           MOV     A,R6
   \   000024   FA           MOV     R2,A
   \   000025   EF           MOV     A,R7
   \   000026   FB           MOV     R3,A
   \   000027   12....       LCALL   `??APSME_LinkKeyNVIdGet::?relay`; Banked call to: APSME_LinkKeyNVIdGet
   2600          
   2601            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   00002A   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   00002D   607A         JZ      ??APSME_IsLinkKeyValid_0
   2602            {
   2603              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00002F                ; Setup parameters for call to function osal_mem_alloc
   \   00002F   7A18         MOV     R2,#0x18
   \   000031   7B00         MOV     R3,#0x0
   \   000033   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000036   8A..         MOV     ?V2,R2
   \   000038   8B..         MOV     ?V3,R3
   2604          
   2605              if (pKeyData != NULL)
   \   00003A   EA           MOV     A,R2
   \   00003B   45..         ORL     A,?V3
   \   00003D   606A         JZ      ??APSME_IsLinkKeyValid_0
   2606              {
   2607                // retrieve key from NV
   2608                if ( osal_nv_read( apsLinkKeyNvId, 0,
   2609                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   00003F                ; Setup parameters for call to function osal_nv_read
   \   00003F   78..         MOV     R0,#?V2
   \   000041   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000044   75..18       MOV     ?V4,#0x18
   \   000047   75..00       MOV     ?V5,#0x0
   \   00004A   78..         MOV     R0,#?V4
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   7C00         MOV     R4,#0x0
   \   000051   7D00         MOV     R5,#0x0
   \   000053   7404         MOV     A,#0x4
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00005B   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00005E   7404         MOV     A,#0x4
   \   000060   12....       LCALL   ?DEALLOC_XSTACK8
   \   000063   E9           MOV     A,R1
   \   000064   702F         JNZ     ??APSME_IsLinkKeyValid_1
   2610                {
   2611                  // if stored key is different than default value, then a key has been established
   2612                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   000066                ; Setup parameters for call to function osal_memcmp
   \   000066   7402         MOV     A,#0x2
   \   000068   12....       LCALL   ?XSTACK_DISP100_8
   \   00006B   88..         MOV     ?V4,R0
   \   00006D   89..         MOV     ?V5,R1
   \   00006F   75..00       MOV     ?V6,#0x0
   \   000072   78..         MOV     R0,#?V4
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000077   7C10         MOV     R4,#0x10
   \   000079   7D00         MOV     R5,#0x0
   \   00007B   85..82       MOV     DPL,?V2
   \   00007E   85..83       MOV     DPH,?V3
   \   000081   A982         MOV     R1,DPL
   \   000083   AA83         MOV     R2,DPH
   \   000085   7B00         MOV     R3,#0x0
   \   000087   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   00008A   7403         MOV     A,#0x3
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   E9           MOV     A,R1
   \   000090   7003         JNZ     ??APSME_IsLinkKeyValid_1
   2613                  {
   2614                    status = TRUE;
   \   000092   75..01       MOV     ?V0,#0x1
   2615                  }
   2616                }
   2617          
   2618                // clear copy of key in RAM
   2619                osal_memset(pKeyData, 0x00, sizeof(APSME_LinkKeyData_t));
   \                     ??APSME_IsLinkKeyValid_1:
   \   000095                ; Setup parameters for call to function osal_memset
   \   000095   7C18         MOV     R4,#0x18
   \   000097   7D00         MOV     R5,#0x0
   \   000099   7900         MOV     R1,#0x0
   \   00009B   AA..         MOV     R2,?V2
   \   00009D   AB..         MOV     R3,?V3
   \   00009F   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2620          
   2621                osal_mem_free(pKeyData);
   \   0000A2                ; Setup parameters for call to function osal_mem_free
   \   0000A2   AA..         MOV     R2,?V2
   \   0000A4   AB..         MOV     R3,?V3
   \   0000A6   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2622              }
   2623            }
   2624          
   2625            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   0000A9   A9..         MOV     R1,?V0
   \   0000AB   7412         MOV     A,#0x12
   \   0000AD   02....       LJMP    ?Subroutine6 & 0xFFFF
   2626          }
   2627          
   2628          /******************************************************************************
   2629           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   2630           *
   2631           * @brief       Verify and process key transportation to child.
   2632           *
   2633           * @param       ind - [in] APSME_TransportKeyInd_t
   2634           *
   2635           * @return      uint8 - success(TRUE:FALSE)
   2636           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2637          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   2638          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2639            // verify from Trust Center
   2640            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   00000C   7027         JNZ     ??APSME_KeyFwdToChild_0
   2641            {
   2642              // check for initial NWK key
   2643              if ( ( ind->keyType == KEY_TYPE_NWK ) ||
   2644                   ( ind->keyType == 6            ) )
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   7401         MOV     A,#0x1
   \   000018   68           XRL     A,R0
   \   000019   6005         JZ      ??APSME_KeyFwdToChild_1
   \   00001B   7406         MOV     A,#0x6
   \   00001D   68           XRL     A,R0
   \   00001E   7011         JNZ     ??APSME_KeyFwdToChild_2
   2645              {
   2646                // set association status to authenticated
   2647                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   000020                ; Setup parameters for call to function AssocGetWithExt
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   12....       LCALL   ??Subroutine60_0 & 0xFFFF
   2648              }
   \                     ??CrossCallReturnLabel_119:
   \   00002B   12....       LCALL   `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   00002E                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002E   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2649          
   2650              return TRUE;
   \                     ??APSME_KeyFwdToChild_2:
   \   000031   7901         MOV     R1,#0x1
   \   000033   8002         SJMP    ??APSME_KeyFwdToChild_3
   2651            }
   2652          
   2653            return FALSE;
   \                     ??APSME_KeyFwdToChild_0:
   \   000035   7900         MOV     R1,#0x0
   \                     ??APSME_KeyFwdToChild_3:
   \   000037   02....       LJMP    ??Subroutine72_0 & 0xFFFF
   2654          }
   2655          
   2656          /******************************************************************************
   2657           * @fn          ZDSecMgrAddLinkKey
   2658           *
   2659           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   2660           *              as authenticated in the authenticateOption. Note that this function
   2661           *              is hardwared to CBKE right now.
   2662           *
   2663           * @param       shortAddr - short address of the partner device
   2664           * @param       extAddr - extended address of the partner device
   2665           * @param       key - link key
   2666           *
   2667           * @return      ZStatus_t
   2668           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2669          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   2670          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   2671            uint16           ami;
   2672            ZDSecMgrEntry_t* entry;
   2673          
   2674            /* Store the device address in the addr manager */
   2675            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP100_8
   \   000013   88..         MOV     ?V0,R0
   \   000015   89..         MOV     ?V1,R1
   \   000017   78..         MOV     R0,#?V0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?DEALLOC_XSTACK8
   \   000024   E9           MOV     A,R1
   \   000025   6004         JZ      ??ZDSecMgrAddLinkKey_0
   2676            {
   2677              /* Adding to Addr Manager fails */
   2678              return ZFailure;
   \   000027   7901         MOV     R1,#0x1
   \   000029   804A         SJMP    ??ZDSecMgrAddLinkKey_1
   2679            }
   2680          
   2681            /* Lookup entry using specified address index */
   2682            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   00002B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00002B   AC..         MOV     R4,?XSP + 0
   \   00002D   AD..         MOV     R5,?XSP + 1
   \   00002F   7402         MOV     A,#0x2
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000037   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   2683          
   2684            // If no existing entry, create one
   2685            if ( entry == NULL )
   \   00003A   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   00003D   7019         JNZ     ??CrossCallReturnLabel_158
   2686            {
   2687              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00003F                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00003F   AA..         MOV     R2,?XSP + 0
   \   000041   AB..         MOV     R3,?XSP + 1
   \   000043   12....       LCALL   `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   000046   E9           MOV     A,R1
   \   000047   7031         JNZ     ??ZDSecMgrAddLinkKey_2
   2688              {
   2689                entry->ami = ami;
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F8           MOV     R0,A
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   12....       LCALL   ?Subroutine31 & 0xFFFF
   2690              }
   \                     ??CrossCallReturnLabel_197:
   \   000055   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   2691              else
   2692              {
   2693                /* Security Manager full */
   2694                return ZBufferFull;
   2695              }
   2696            }
   2697            // Write the link key
   2698            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_158:
   \   000058                ; Setup parameters for call to function APSME_LinkKeySet
   \   000058   740E         MOV     A,#0xe
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000060   EE           MOV     A,R6
   \   000061   FA           MOV     R2,A
   \   000062   EF           MOV     A,R7
   \   000063   FB           MOV     R3,A
   \   000064   12....       LCALL   `??APSME_LinkKeySet::?relay`; Banked call to: APSME_LinkKeySet
   2699          
   2700          #if defined (TC_LINKKEY_JOIN)
   2701            // Mark the device as authenticated.
   2702            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   \   000067                ; Setup parameters for call to function ZDSecMgrAuthenticationSet
   \   000067   7901         MOV     R1,#0x1
   \   000069   EE           MOV     A,R6
   \   00006A   FA           MOV     R2,A
   \   00006B   EF           MOV     A,R7
   \   00006C   FB           MOV     R3,A
   \   00006D   12....       LCALL   `??ZDSecMgrAuthenticationSet::?relay`; Banked call to: ZDSecMgrAuthenticationSet
   2703          #endif
   2704          
   2705          #if defined NV_RESTORE
   2706            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   \   000070                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   000070   12....       LCALL   `??ZDSecMgrWriteNV::?relay`; Banked call to: ZDSecMgrWriteNV
   2707          #endif
   2708          
   2709            return ZSuccess;
   \   000073   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000075   7404         MOV     A,#0x4
   \   000077   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   \                     ??ZDSecMgrAddLinkKey_2:
   \   00007A   7911         MOV     R1,#0x11
   \   00007C   80F7         SJMP    ??ZDSecMgrAddLinkKey_1
   2710          }
   2711          
   2712          /******************************************************************************
   2713           * @fn          ZDSecMgrInitNV
   2714           *
   2715           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   2716           *
   2717           * @param       none
   2718           *
   2719           * @return      uint8 - <osal_nv_item_init> return codes
   2720           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2721          uint8 ZDSecMgrInitNV(void)
   \                     ZDSecMgrInitNV:
   2722          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2723          
   2724            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE,
   2725                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   \   00000A                ; Setup parameters for call to function osal_nv_item_init
   \   00000A   E4           CLR     A
   \   00000B   F5..         MOV     ?V0,A
   \   00000D   F5..         MOV     ?V1,A
   \   00000F   78..         MOV     R0,#?V0
   \   000011   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000014   7C11         MOV     R4,#0x11
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7A4C         MOV     R2,#0x4c
   \   00001A   7B00         MOV     R3,#0x0
   \   00001C   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?DEALLOC_XSTACK8
   \   000024   E9           MOV     A,R1
   \   000025   FE           MOV     R6,A
   2726          
   2727            // If the item does not already exist, set all values to 0
   2728            if (rtrn == NV_ITEM_UNINIT)
   \   000026   7409         MOV     A,#0x9
   \   000028   6E           XRL     A,R6
   \   000029   7021         JNZ     ??ZDSecMgrInitNV_0
   2729            {
   2730              nvDeviceListHdr_t hdr;
   2731              hdr.numRecs = 0;
   \   00002B   12....       LCALL   ?Subroutine14 & 0xFFFF
   2732              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   2733            }
   \                     ??CrossCallReturnLabel_0:
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   75..02       MOV     ?V0,#0x2
   \   000034   75..00       MOV     ?V1,#0x0
   \   000037   78..         MOV     R0,#?V0
   \   000039   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003C   7C00         MOV     R4,#0x0
   \   00003E   7D00         MOV     R5,#0x0
   \   000040   7A4C         MOV     R2,#0x4c
   \   000042   7B00         MOV     R3,#0x0
   \   000044   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000047   7404         MOV     A,#0x4
   \   000049   12....       LCALL   ?DEALLOC_XSTACK8
   2734          
   2735            rtrn |= osal_nv_item_init( ZCD_NV_TRUSTCENTER_ADDR, Z_EXTADDR_LEN,
   2736                                       zgApsTrustCenterAddr );
   2737          
   2738            return rtrn;
   \                     ??ZDSecMgrInitNV_0:
   \   00004C                ; Setup parameters for call to function osal_nv_item_init
   \   00004C   75....       MOV     ?V0,#zgApsTrustCenterAddr & 0xff
   \   00004F   75....       MOV     ?V1,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   000052   78..         MOV     R0,#?V0
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000057   7C08         MOV     R4,#0x8
   \   000059   7D00         MOV     R5,#0x0
   \   00005B   7A71         MOV     R2,#0x71
   \   00005D   7B00         MOV     R3,#0x0
   \   00005F   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000062   7402         MOV     A,#0x2
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067   E9           MOV     A,R1
   \   000068   4E           ORL     A,R6
   \   000069   F9           MOV     R1,A
   \   00006A   7402         MOV     A,#0x2
   \   00006C   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   2739          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E4           CLR     A
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   F0           MOVX    @DPTR,A
   \   00000A                ; Setup parameters for call to function osal_nv_write
   \   00000A                ; Setup parameters for call to function osal_nv_write
   \   00000A   A8..         MOV     R0,?XSP + 0
   \   00000C   A9..         MOV     R1,?XSP + 1
   \   00000E   88..         MOV     ?V0,R0
   \   000010   89..         MOV     ?V1,R1
   \   000012   78..         MOV     R0,#?V0
   \   000014   22           RET
   2740          
   2741          #if defined ( NV_RESTORE )
   2742          /*********************************************************************
   2743           * @fn      ZDSecMgrWriteNV()
   2744           *
   2745           * @brief   Save off the APS link key list to NV
   2746           *
   2747           * @param   none
   2748           *
   2749           * @return  none
   2750           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2751          static void ZDSecMgrWriteNV( void )
   \                     ZDSecMgrWriteNV:
   2752          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2753            uint16 i;
   2754            nvDeviceListHdr_t hdr;
   2755          
   2756            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   12....       LCALL   ?Subroutine10 & 0xFFFF
   2757          
   2758            if (ZDSecMgrEntries != NULL)
   \                     ??CrossCallReturnLabel_93:
   \   000013   6074         JZ      ??ZDSecMgrWriteNV_0
   2759            {
   2760              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000015   7E00         MOV     R6,#0x0
   \   000017   7F00         MOV     R7,#0x0
   2761              {
   2762                // Save off the record
   2763                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2764                              (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   2765                              sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   \                     ??ZDSecMgrWriteNV_1:
   \   000019   8E..         MOV     ?V0,R6
   \   00001B   8F..         MOV     ?V1,R7
   \   00001D   E5..         MOV     A,?V0
   \   00001F   75F005       MOV     B,#0x5
   \   000022   A4           MUL     AB
   \   000023   F5..         MOV     ?V0,A
   \   000025   A8F0         MOV     R0,B
   \   000027   75F005       MOV     B,#0x5
   \   00002A   E5..         MOV     A,?V1
   \   00002C   A4           MUL     AB
   \   00002D   28           ADD     A,R0
   \   00002E   F5..         MOV     ?V1,A
   \   000030                ; Setup parameters for call to function osal_nv_write
   \   000030   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000033   E0           MOVX    A,@DPTR
   \   000034   25..         ADD     A,?V0
   \   000036   F5..         MOV     ?V2,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   35..         ADDC    A,?V1
   \   00003C   F5..         MOV     ?V3,A
   \   00003E   78..         MOV     R0,#?V2
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   75..05       MOV     ?V2,#0x5
   \   000046   75..00       MOV     ?V3,#0x0
   \   000049   78..         MOV     R0,#?V2
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000051   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000054   7404         MOV     A,#0x4
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
   2766          
   2767                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   \   000059   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   25..         ADD     A,?V0
   \   00005F   F8           MOV     R0,A
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   35..         ADDC    A,?V1
   \   000064   8882         MOV     DPL,R0
   \   000066   F583         MOV     DPH,A
   \   000068   E0           MOVX    A,@DPTR
   \   000069   64FE         XRL     A,#0xfe
   \   00006B   7003         JNZ     ??ZDSecMgrWriteNV_2
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F4           CPL     A
   \                     ??ZDSecMgrWriteNV_2:
   \   000070   600A         JZ      ??ZDSecMgrWriteNV_3
   2768                {
   2769                  hdr.numRecs++;
   \   000072   85..82       MOV     DPL,?XSP + 0
   \   000075   85..83       MOV     DPH,?XSP + 1
   \   000078   12....       LCALL   ?Subroutine39 & 0xFFFF
   2770                }
   2771              }
   \                     ??CrossCallReturnLabel_51:
   \   00007B   F0           MOVX    @DPTR,A
   \                     ??ZDSecMgrWriteNV_3:
   \   00007C   0E           INC     R6
   \   00007D   EE           MOV     A,R6
   \   00007E   7001         JNZ     ??ZDSecMgrWriteNV_4
   \   000080   0F           INC     R7
   \                     ??ZDSecMgrWriteNV_4:
   \   000081   C3           CLR     C
   \   000082   9403         SUBB    A,#0x3
   \   000084   EF           MOV     A,R7
   \   000085   9400         SUBB    A,#0x0
   \   000087   4090         JC      ??ZDSecMgrWriteNV_1
   2772            }
   2773          
   2774            // Save off the header
   2775            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \                     ??ZDSecMgrWriteNV_0:
   \   000089                ; Setup parameters for call to function osal_nv_write
   \   000089   A8..         MOV     R0,?XSP + 0
   \   00008B   A9..         MOV     R1,?XSP + 1
   \   00008D   88..         MOV     ?V0,R0
   \   00008F   89..         MOV     ?V1,R1
   \   000091   78..         MOV     R0,#?V0
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   75..02       MOV     ?V0,#0x2
   \   000099   75..00       MOV     ?V1,#0x0
   \   00009C   78..         MOV     R0,#?V0
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A1   7C00         MOV     R4,#0x0
   \   0000A3   7D00         MOV     R5,#0x0
   \   0000A5   7A4C         MOV     R2,#0x4c
   \   0000A7   7B00         MOV     R3,#0x0
   \   0000A9   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000AC   7404         MOV     A,#0x4
   \   0000AE   12....       LCALL   ?DEALLOC_XSTACK8
   2776          }
   \   0000B1   7402         MOV     A,#0x2
   \   0000B3                REQUIRE ?Subroutine3
   \   0000B3                ; // Fall through to label ?Subroutine3

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   EE           MOV     A,R6
   \   000001   F8           MOV     R0,A
   \   000002   EF           MOV     A,R7
   \   000003   F9           MOV     R1,A
   \   000004   E8           MOV     A,R0
   \   000005   75F005       MOV     B,#0x5
   \   000008   A4           MUL     AB
   \   000009   F8           MOV     R0,A
   \   00000A   AAF0         MOV     R2,B
   \   00000C   75F005       MOV     B,#0x5
   \   00000F   E9           MOV     A,R1
   \   000010   A4           MUL     AB
   \   000011   2A           ADD     A,R2
   \   000012   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   F9           MOV     R1,A
   \   000001   E8           MOV     A,R0
   \   000002   2402         ADD     A,#0x2
   \   000004   FC           MOV     R4,A
   \   000005   E4           CLR     A
   \   000006   39           ADDC    A,R1
   \   000007   FD           MOV     R5,A
   \   000008   7A4C         MOV     R2,#0x4c
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   22           RET
   2777          #endif // NV_RESTORE
   2778          
   2779          #if defined ( NV_RESTORE )
   2780          /******************************************************************************
   2781           * @fn          ZDSecMgrRestoreFromNV
   2782           *
   2783           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   2784           *              the key data itself as they remain in NV until they are used.
   2785           *              Only list data is restored.
   2786           *              Restore zgTrustCenterAdress from NV.
   2787           *
   2788           * @param       none
   2789           *
   2790           * @return      None.
   2791           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2792          static void ZDSecMgrRestoreFromNV( void )
   \                     ZDSecMgrRestoreFromNV:
   2793          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2794            nvDeviceListHdr_t hdr;
   2795            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   2796          
   2797            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   2798                ((hdr.numRecs > 0) && (hdr.numRecs <= ZDSECMGR_ENTRY_MAX)))
   \   00000A                ; Setup parameters for call to function osal_nv_read
   \   00000A   A8..         MOV     R0,?XSP + 0
   \   00000C   A9..         MOV     R1,?XSP + 1
   \   00000E   88..         MOV     ?V0,R0
   \   000010   89..         MOV     ?V1,R1
   \   000012   78..         MOV     R0,#?V0
   \   000014   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000017   75..02       MOV     ?V0,#0x2
   \   00001A   75..00       MOV     ?V1,#0x0
   \   00001D   78..         MOV     R0,#?V0
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   7C00         MOV     R4,#0x0
   \   000024   7D00         MOV     R5,#0x0
   \   000026   7A4C         MOV     R2,#0x4c
   \   000028   7B00         MOV     R3,#0x0
   \   00002A   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00002D   7404         MOV     A,#0x4
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000032   E9           MOV     A,R1
   \   000033   6003         JZ      $+5
   \   000035   02....       LJMP    ??ZDSecMgrRestoreFromNV_0 & 0xFFFF
   \   000038   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   00003B   7003         JNZ     $+5
   \   00003D   02....       LJMP    ??ZDSecMgrRestoreFromNV_0 & 0xFFFF
   \   000040   85..82       MOV     DPL,?XSP + 0
   \   000043   85..83       MOV     DPH,?XSP + 1
   \   000046   C3           CLR     C
   \   000047   E0           MOVX    A,@DPTR
   \   000048   9404         SUBB    A,#0x4
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   9400         SUBB    A,#0x0
   \   00004E   4003         JC      $+5
   \   000050   02....       LJMP    ??ZDSecMgrRestoreFromNV_0 & 0xFFFF
   2799            {
   2800              uint8 x;
   2801          
   2802              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000053                ; Setup parameters for call to function osal_mem_alloc
   \   000053   7A18         MOV     R2,#0x18
   \   000055   7B00         MOV     R3,#0x0
   \   000057   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00005A   8A..         MOV     ?V8,R2
   \   00005C   8B..         MOV     ?V9,R3
   2803          
   2804              for (x = 0; x < ZDSECMGR_ENTRY_MAX; x++)
   \   00005E   75..00       MOV     ?V0,#0x0
   \   000061   EA           MOV     A,R2
   \   000062   2410         ADD     A,#0x10
   \   000064   F5..         MOV     ?V2,A
   \   000066   E4           CLR     A
   \   000067   35..         ADDC    A,?V9
   \   000069   F5..         MOV     ?V3,A
   2805              {
   2806                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   2807                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   2808                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   \                     ??ZDSecMgrRestoreFromNV_1:
   \   00006B   E5..         MOV     A,?V0
   \   00006D   75F005       MOV     B,#0x5
   \   000070   A4           MUL     AB
   \   000071   FE           MOV     R6,A
   \   000072   AFF0         MOV     R7,B
   \   000074                ; Setup parameters for call to function osal_nv_read
   \   000074   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000077   E0           MOVX    A,@DPTR
   \   000078   2E           ADD     A,R6
   \   000079   F5..         MOV     ?V4,A
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   3F           ADDC    A,R7
   \   00007E   F5..         MOV     ?V5,A
   \   000080   78..         MOV     R0,#?V4
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000085   75..05       MOV     ?V4,#0x5
   \   000088   75..00       MOV     ?V5,#0x0
   \   00008B   78..         MOV     R0,#?V4
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000090   E5..         MOV     A,?V0
   \   000092   75F005       MOV     B,#0x5
   \   000095   A4           MUL     AB
   \   000096   F8           MOV     R0,A
   \   000097   EF           MOV     A,R7
   \   000098   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   00009B   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00009E   7404         MOV     A,#0x4
   \   0000A0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A3   E9           MOV     A,R1
   \   0000A4   6003         JZ      $+5
   \   0000A6   02....       LJMP    ??ZDSecMgrRestoreFromNV_2 & 0xFFFF
   2809                {
   2810                  // update data only for valid entries
   2811                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   \   0000A9   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   2E           ADD     A,R6
   \   0000AE   F8           MOV     R0,A
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   3F           ADDC    A,R7
   \   0000B2   F9           MOV     R1,A
   \   0000B3   E8           MOV     A,R0
   \   0000B4   FA           MOV     R2,A
   \   0000B5   E9           MOV     A,R1
   \   0000B6   FB           MOV     R3,A
   \   0000B7   8A82         MOV     DPL,R2
   \   0000B9   8B83         MOV     DPH,R3
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   64FE         XRL     A,#0xfe
   \   0000BE   7003         JNZ     ??ZDSecMgrRestoreFromNV_3
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F4           CPL     A
   \                     ??ZDSecMgrRestoreFromNV_3:
   \   0000C3   7003         JNZ     $+5
   \   0000C5   02....       LJMP    ??ZDSecMgrRestoreFromNV_2 & 0xFFFF
   2812                  {
   2813                    if (pApsLinkKey != NULL)
   \   0000C8   E5..         MOV     A,?V8
   \   0000CA   45..         ORL     A,?V9
   \   0000CC   7003         JNZ     $+5
   \   0000CE   02....       LJMP    ??ZDSecMgrRestoreFromNV_2 & 0xFFFF
   2814                    {
   2815                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   2816                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0,
   2817                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   0000D1                ; Setup parameters for call to function osal_nv_read
   \   0000D1   78..         MOV     R0,#?V8
   \   0000D3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D6   75..18       MOV     ?V4,#0x18
   \   0000D9   78..         MOV     R0,#?V4
   \   0000DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DE   7C00         MOV     R4,#0x0
   \   0000E0   7D00         MOV     R5,#0x0
   \   0000E2   8A82         MOV     DPL,R2
   \   0000E4   8B83         MOV     DPH,R3
   \   0000E6   12....       LCALL   ??Subroutine60_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   0000E9   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000EC   7404         MOV     A,#0x4
   \   0000EE   12....       LCALL   ?DEALLOC_XSTACK8
   2818          
   2819                      // set new values for the counter
   2820                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   \   0000F1   90....       MOV     DPTR,#__Constant_3e9
   \   0000F4   78..         MOV     R0,#?V4
   \   0000F6   12....       LCALL   ?L_MOV_X
   \   0000F9   85..82       MOV     DPL,?V2
   \   0000FC   85..83       MOV     DPH,?V3
   \   0000FF   78..         MOV     R0,#?V4
   \   000101   12....       LCALL   ?L_ADD_TO_X
   \   000104   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000107   A3           INC     DPTR
   \   000108   A3           INC     DPTR
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   FE           MOV     R6,A
   \   00010B   A3           INC     DPTR
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   FF           MOV     R7,A
   \   00010E   EE           MOV     A,R6
   \   00010F   F8           MOV     R0,A
   \   000110   EF           MOV     A,R7
   \   000111   F9           MOV     R1,A
   \   000112   E8           MOV     A,R0
   \   000113   75F009       MOV     B,#0x9
   \   000116   A4           MUL     AB
   \   000117   F8           MOV     R0,A
   \   000118   AAF0         MOV     R2,B
   \   00011A   75F009       MOV     B,#0x9
   \   00011D   E9           MOV     A,R1
   \   00011E   A4           MUL     AB
   \   00011F   2A           ADD     A,R2
   \   000120   F9           MOV     R1,A
   \   000121   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   000123   28           ADD     A,R0
   \   000124   FC           MOV     R4,A
   \   000125   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   000127   39           ADDC    A,R1
   \   000128   FD           MOV     R5,A
   \   000129   85..82       MOV     DPL,?V2
   \   00012C   85..83       MOV     DPH,?V3
   \   00012F   12....       LCALL   ?XLOAD_R0123
   \   000132   EC           MOV     A,R4
   \   000133   24F7         ADD     A,#-0x9
   \   000135   F582         MOV     DPL,A
   \   000137   ED           MOV     A,R5
   \   000138   34ED         ADDC    A,#-0x13
   \   00013A   F583         MOV     DPH,A
   \   00013C   12....       LCALL   ?XSTORE_R0123
   2821          
   2822                      // restore values for counters in RAM
   2823                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr =
   2824                                                      pApsLinkKey->txFrmCntr;
   2825          
   2826                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr =
   2827                                                      pApsLinkKey->rxFrmCntr;
   \   00013F   E5..         MOV     A,?V8
   \   000141   2414         ADD     A,#0x14
   \   000143   F582         MOV     DPL,A
   \   000145   E4           CLR     A
   \   000146   35..         ADDC    A,?V9
   \   000148   F583         MOV     DPH,A
   \   00014A   12....       LCALL   ?XLOAD_R0123
   \   00014D   EC           MOV     A,R4
   \   00014E   24FB         ADD     A,#-0x5
   \   000150   F582         MOV     DPL,A
   \   000152   ED           MOV     A,R5
   \   000153   34ED         ADDC    A,#-0x13
   \   000155   F583         MOV     DPH,A
   \   000157   12....       LCALL   ?XSTORE_R0123
   2828          
   2829                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0,
   2830                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   00015A                ; Setup parameters for call to function osal_nv_write
   \   00015A   78..         MOV     R0,#?V8
   \   00015C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015F   75..18       MOV     ?V4,#0x18
   \   000162   75..00       MOV     ?V5,#0x0
   \   000165   78..         MOV     R0,#?V4
   \   000167   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016A   7C00         MOV     R4,#0x0
   \   00016C   7D00         MOV     R5,#0x0
   \   00016E   EE           MOV     A,R6
   \   00016F   FA           MOV     R2,A
   \   000170   EF           MOV     A,R7
   \   000171   FB           MOV     R3,A
   \   000172   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000175   7404         MOV     A,#0x4
   \   000177   12....       LCALL   ?DEALLOC_XSTACK8
   2831          
   2832                      // clear copy of key in RAM
   2833                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   00017A                ; Setup parameters for call to function osal_memset
   \   00017A   7C18         MOV     R4,#0x18
   \   00017C   7D00         MOV     R5,#0x0
   \   00017E   7900         MOV     R1,#0x0
   \   000180   AA..         MOV     R2,?V8
   \   000182   AB..         MOV     R3,?V9
   \   000184   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2834                    }
   2835                  }
   2836                }
   2837              }
   \                     ??ZDSecMgrRestoreFromNV_2:
   \   000187   05..         INC     ?V0
   \   000189   E5..         MOV     A,?V0
   \   00018B   C3           CLR     C
   \   00018C   9403         SUBB    A,#0x3
   \   00018E   5003         JNC     $+5
   \   000190   02....       LJMP    ??ZDSecMgrRestoreFromNV_1 & 0xFFFF
   2838          
   2839              if (pApsLinkKey != NULL)
   \   000193   E5..         MOV     A,?V8
   \   000195   45..         ORL     A,?V9
   \   000197   6007         JZ      ??ZDSecMgrRestoreFromNV_0
   2840              {
   2841                osal_mem_free(pApsLinkKey);
   \   000199                ; Setup parameters for call to function osal_mem_free
   \   000199   AA..         MOV     R2,?V8
   \   00019B   AB..         MOV     R3,?V9
   \   00019D   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2842              }
   2843            }
   2844          
   2845            osal_nv_read( ZCD_NV_TRUSTCENTER_ADDR, 0, Z_EXTADDR_LEN, zgApsTrustCenterAddr );
   \                     ??ZDSecMgrRestoreFromNV_0:
   \   0001A0                ; Setup parameters for call to function osal_nv_read
   \   0001A0   75....       MOV     ?V0,#zgApsTrustCenterAddr & 0xff
   \   0001A3   75....       MOV     ?V1,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   0001A6   78..         MOV     R0,#?V0
   \   0001A8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001AB   75..08       MOV     ?V0,#0x8
   \   0001AE   75..00       MOV     ?V1,#0x0
   \   0001B1   78..         MOV     R0,#?V0
   \   0001B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001B6   7C00         MOV     R4,#0x0
   \   0001B8   7D00         MOV     R5,#0x0
   \   0001BA   7A71         MOV     R2,#0x71
   \   0001BC   7B00         MOV     R3,#0x0
   \   0001BE   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0001C1   7404         MOV     A,#0x4
   \   0001C3   12....       LCALL   ?DEALLOC_XSTACK8
   2846          }
   \   0001C6   7402         MOV     A,#0x2
   \   0001C8   02....       LJMP    ?Subroutine5 & 0xFFFF
   2847          #endif // NV_RESTORE
   2848          
   2849          /*********************************************************************
   2850           * @fn          ZDSecMgrSetDefaultNV
   2851           *
   2852           * @brief       Write the defaults to NV for Entry table and for APS key data table
   2853           *
   2854           * @param       none
   2855           *
   2856           * @return      none
   2857           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2858          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   2859          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2860            uint16 i;
   2861            nvDeviceListHdr_t hdr;
   2862            ZDSecMgrEntry_t secMgrEntry;
   2863            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   2864          
   2865            // Initialize the header
   2866            hdr.numRecs = 0;
   \   00000A   12....       LCALL   ?Subroutine14 & 0xFFFF
   2867          
   2868            // clear the header
   2869            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \                     ??CrossCallReturnLabel_1:
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   75..02       MOV     ?V0,#0x2
   \   000013   75..00       MOV     ?V1,#0x0
   \   000016   78..         MOV     R0,#?V0
   \   000018   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001B   7C00         MOV     R4,#0x0
   \   00001D   7D00         MOV     R5,#0x0
   \   00001F   7A4C         MOV     R2,#0x4c
   \   000021   7B00         MOV     R3,#0x0
   \   000023   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?DEALLOC_XSTACK8
   2870          
   2871            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   00002B                ; Setup parameters for call to function osal_memset
   \   00002B   7C05         MOV     R4,#0x5
   \   00002D   7D00         MOV     R5,#0x0
   \   00002F   7900         MOV     R1,#0x0
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP101_8
   \   000036   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2872          
   2873            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000039   7E00         MOV     R6,#0x0
   \   00003B   7F00         MOV     R7,#0x0
   2874            {
   2875              // Clear the record
   2876              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2877                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   2878                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   00003D                ; Setup parameters for call to function osal_nv_write
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP100_8
   \   000042   88..         MOV     ?V0,R0
   \   000044   89..         MOV     ?V1,R1
   \   000046   78..         MOV     R0,#?V0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   75..05       MOV     ?V0,#0x5
   \   00004E   75..00       MOV     ?V1,#0x0
   \   000051   78..         MOV     R0,#?V0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000056   12....       LCALL   ?Subroutine41 & 0xFFFF
   2879            }
   \                     ??CrossCallReturnLabel_55:
   \   000059   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00005C   7404         MOV     A,#0x4
   \   00005E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000061   0E           INC     R6
   \   000062   EE           MOV     A,R6
   \   000063   7001         JNZ     ??ZDSecMgrSetDefaultNV_1
   \   000065   0F           INC     R7
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   000066   C3           CLR     C
   \   000067   9403         SUBB    A,#0x3
   \   000069   EF           MOV     A,R7
   \   00006A   9400         SUBB    A,#0x0
   \   00006C   40CF         JC      ??ZDSecMgrSetDefaultNV_0
   2880          
   2881            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00006E                ; Setup parameters for call to function osal_mem_alloc
   \   00006E   7A18         MOV     R2,#0x18
   \   000070   7B00         MOV     R3,#0x0
   \   000072   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000075   8A..         MOV     ?V0,R2
   \   000077   8B..         MOV     ?V1,R3
   2882          
   2883            if (pApsLinkKey != NULL)
   \   000079   EA           MOV     A,R2
   \   00007A   45..         ORL     A,?V1
   \   00007C   6045         JZ      ??ZDSecMgrSetDefaultNV_2
   2884            {
   2885              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00007E                ; Setup parameters for call to function osal_memset
   \   00007E   7C18         MOV     R4,#0x18
   \   000080   7D00         MOV     R5,#0x0
   \   000082   7900         MOV     R1,#0x0
   \   000084   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2886          
   2887              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000087   7E00         MOV     R6,#0x0
   \   000089   7F00         MOV     R7,#0x0
   2888              {
   2889                // Clear the record
   2890                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   2891                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \                     ??ZDSecMgrSetDefaultNV_3:
   \   00008B                ; Setup parameters for call to function osal_nv_write
   \   00008B   78..         MOV     R0,#?V0
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000090   75..18       MOV     ?V2,#0x18
   \   000093   75..00       MOV     ?V3,#0x0
   \   000096   78..         MOV     R0,#?V2
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009B   7C00         MOV     R4,#0x0
   \   00009D   7D00         MOV     R5,#0x0
   \   00009F   EE           MOV     A,R6
   \   0000A0   2401         ADD     A,#0x1
   \   0000A2   FA           MOV     R2,A
   \   0000A3   EF           MOV     A,R7
   \   0000A4   3402         ADDC    A,#0x2
   \   0000A6   FB           MOV     R3,A
   \   0000A7   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000AA   7404         MOV     A,#0x4
   \   0000AC   12....       LCALL   ?DEALLOC_XSTACK8
   2892              }
   \   0000AF   0E           INC     R6
   \   0000B0   EE           MOV     A,R6
   \   0000B1   7001         JNZ     ??ZDSecMgrSetDefaultNV_4
   \   0000B3   0F           INC     R7
   \                     ??ZDSecMgrSetDefaultNV_4:
   \   0000B4   C3           CLR     C
   \   0000B5   9403         SUBB    A,#0x3
   \   0000B7   EF           MOV     A,R7
   \   0000B8   9400         SUBB    A,#0x0
   \   0000BA   40CF         JC      ??ZDSecMgrSetDefaultNV_3
   2893          
   2894              osal_mem_free(pApsLinkKey);
   \   0000BC                ; Setup parameters for call to function osal_mem_free
   \   0000BC   AA..         MOV     R2,?V0
   \   0000BE   AB..         MOV     R3,?V1
   \   0000C0   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2895            }
   2896          }
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   0000C3   7407         MOV     A,#0x7
   \   0000C5   02....       LJMP    ?Subroutine3 & 0xFFFF
   2897          
   2898          #if defined ( NV_RESTORE )
   2899          /*********************************************************************
   2900           * @fn      ZDSecMgrUpdateNV()
   2901           *
   2902           * @brief   Updates one entry of the APS link key table to NV
   2903           *
   2904           * @param   index - to the entry in security manager table
   2905           *
   2906           * @return  none
   2907           */
   2908          static void ZDSecMgrUpdateNV( uint16 index )
   2909          {
   2910            nvDeviceListHdr_t hdr;
   2911          
   2912            if (ZDSecMgrEntries != NULL)
   2913            {
   2914              // Save off the record
   2915              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2916                             (uint16)((sizeof(nvDeviceListHdr_t)) + (index * sizeof(ZDSecMgrEntry_t))),
   2917                             sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[index] );
   2918            }
   2919          
   2920            if (osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS)
   2921            {
   2922              if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   2923              {
   2924                if (hdr.numRecs > 0)
   2925                {
   2926                  hdr.numRecs--;
   2927                }
   2928              }
   2929              else
   2930              {
   2931                hdr.numRecs++;
   2932              }
   2933          
   2934              // Save off the header
   2935              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   2936            }
   2937          }
   2938          #endif // NV_RESTORE
   2939          
   2940          /******************************************************************************
   2941           * @fn          ZDSecMgrAPSRemove
   2942           *
   2943           * @brief       Remove device from network.
   2944           *
   2945           * @param       nwkAddr - device's NWK address
   2946           * @param       extAddr - device's Extended address
   2947           * @param       parentAddr - parent's NWK address
   2948           *
   2949           * @return      ZStatus_t
   2950           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2951          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   2952          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2953            ZDSecMgrDevice_t device;
   2954          
   2955            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   2956                 ( extAddr == NULL )              ||
   2957                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000009   74FE         MOV     A,#-0x2
   \   00000B   6A           XRL     A,R2
   \   00000C   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000011   6016         JZ      ??ZDSecMgrAPSRemove_1
   \   000013   EC           MOV     A,R4
   \   000014   4D           ORL     A,R5
   \   000015   6012         JZ      ??ZDSecMgrAPSRemove_1
   \   000017   7408         MOV     A,#0x8
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   00001F   74FE         MOV     A,#-0x2
   \   000021   68           XRL     A,R0
   \   000022   7003         JNZ     ??ZDSecMgrAPSRemove_2
   \   000024   74FF         MOV     A,#-0x1
   \   000026   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000027   7004         JNZ     ??ZDSecMgrAPSRemove_3
   2958            {
   2959              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000029   7901         MOV     R1,#0x1
   \   00002B   801C         SJMP    ??ZDSecMgrAPSRemove_4
   2960            }
   2961          
   2962            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002D   12....       LCALL   ?Subroutine23 & 0xFFFF
   2963            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_184:
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   EC           MOV     A,R4
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   ED           MOV     A,R5
   \   000037   F0           MOVX    @DPTR,A
   2964            device.parentAddr = parentAddr;
   \   000038   7404         MOV     A,#0x4
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E8           MOV     A,R0
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   E9           MOV     A,R1
   \   000041   12....       LCALL   ??Subroutine74_0 & 0xFFFF
   2965          
   2966            // remove device
   2967            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_193:
   \   000044   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2968          
   2969            return ( ZSuccess );
   \   000047   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000049   7408         MOV     A,#0x8
   \   00004B   02....       LJMP    ?Subroutine9 & 0xFFFF
   2970          }
   2971          
   2972          /******************************************************************************
   2973           * @fn          APSME_TCLinkKeyInit
   2974           *
   2975           * @brief       Initialize the NV table for preconfigured TC link key
   2976           *
   2977           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   2978           *              Trust Center Link Key is written to NV. A single tclk is used
   2979           *              by all devices joining the network.
   2980           *
   2981           * @param       setDefault - TRUE to set default values
   2982           *
   2983           * @return      none
   2984           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2985          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   2986          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 19
   \   000005   74ED         MOV     A,#-0x13
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   2987            APSME_TCLKDevEntry_t TCLKDevEntry;
   2988            uint8                rtrn;
   2989            uint8                i;
   2990            
   2991            //Initialize the default key
   2992            //osal_nv_item_init(ZCD_NV_TCLK_DEFAULT, SEC_KEY_LEN,(void*) &defaultTCLinkKey);
   2993          
   2994            // Clear the data for the keys
   2995            osal_memset( &TCLKDevEntry, 0x00, sizeof(APSME_TCLKDevEntry_t) );
   \   00000C                ; Setup parameters for call to function osal_memset
   \   00000C   7C13         MOV     R4,#0x13
   \   00000E   7D00         MOV     R5,#0x0
   \   000010   7900         MOV     R1,#0x0
   \   000012   AA..         MOV     R2,?XSP + 0
   \   000014   AB..         MOV     R3,?XSP + 1
   \   000016   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2996            TCLKDevEntry.keyAttributes = ZG_DEFAULT_KEY;
   \   000019   7410         MOV     A,#0x10
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   74FF         MOV     A,#-0x1
   \   000020   F0           MOVX    @DPTR,A
   2997            
   2998            // Initialize all NV items
   2999            for( i = 0; i < gZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000021   7E00         MOV     R6,#0x0
   3000            {
   3001              // If the item doesn't exist in NV memory, create and initialize
   3002              // it with the default value passed in, either defaultTCLK or 0
   3003              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i),
   3004                                         sizeof(APSME_TCLKDevEntry_t), &TCLKDevEntry);
   3005          
   3006              if (rtrn == SUCCESS)
   \                     ??APSME_TCLinkKeyInit_0:
   \   000023   8E..         MOV     ?V2,R6
   \   000025   E5..         MOV     A,?V2
   \   000027   2411         ADD     A,#0x11
   \   000029   F5..         MOV     ?V0,A
   \   00002B   E4           CLR     A
   \   00002C   3401         ADDC    A,#0x1
   \   00002E   F5..         MOV     ?V1,A
   \   000030                ; Setup parameters for call to function osal_nv_item_init
   \   000030   A8..         MOV     R0,?XSP + 0
   \   000032   A9..         MOV     R1,?XSP + 1
   \   000034   88..         MOV     ?V4,R0
   \   000036   89..         MOV     ?V5,R1
   \   000038   78..         MOV     R0,#?V4
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7C13         MOV     R4,#0x13
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   AA..         MOV     R2,?V0
   \   000043   AB..         MOV     R3,?V1
   \   000045   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004D   E9           MOV     A,R1
   \   00004E   6003         JZ      $+5
   \   000050   02....       LJMP    ??APSME_TCLinkKeyInit_1 & 0xFFFF
   3007              {
   3008                if(setDefault)
   \   000053   E5..         MOV     A,?V2
   \   000055   75F009       MOV     B,#0x9
   \   000058   A4           MUL     AB
   \   000059   F5..         MOV     ?V2,A
   \   00005B   E5F0         MOV     A,B
   \   00005D   F5..         MOV     ?V3,A
   \   00005F   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   000061   25..         ADD     A,?V2
   \   000063   F5..         MOV     ?V2,A
   \   000065   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000067   35..         ADDC    A,?V3
   \   000069   F5..         MOV     ?V3,A
   \   00006B   E5..         MOV     A,?V2
   \   00006D   2404         ADD     A,#0x4
   \   00006F   F5..         MOV     ?V8,A
   \   000071   E4           CLR     A
   \   000072   35..         ADDC    A,?V3
   \   000074   F5..         MOV     ?V9,A
   \   000076   EF           MOV     A,R7
   \   000077   78..         MOV     R0,#?V4
   \   000079   6045         JZ      ??APSME_TCLinkKeyInit_2
   3009                {
   3010                  //Force to initialize the entry
   3011                  osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0, sizeof(APSME_TCLKDevEntry_t), &TCLKDevEntry);
   \   00007B                ; Setup parameters for call to function osal_nv_write
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007E   75..13       MOV     ?V4,#0x13
   \   000081   75..00       MOV     ?V5,#0x0
   \   000084   78..         MOV     R0,#?V4
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000089   7C00         MOV     R4,#0x0
   \   00008B   7D00         MOV     R5,#0x0
   \   00008D   AA..         MOV     R2,?V0
   \   00008F   AB..         MOV     R3,?V1
   \   000091   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000094   7404         MOV     A,#0x4
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   3012                  TCLinkKeyFrmCntr[i].txFrmCntr = 0;
   \   000099   85..82       MOV     DPL,?V2
   \   00009C   85..83       MOV     DPH,?V3
   \   00009F   75..00       MOV     ?V0,#0x0
   \   0000A2   75..00       MOV     ?V1,#0x0
   \   0000A5   75..00       MOV     ?V2,#0x0
   \   0000A8   75..00       MOV     ?V3,#0x0
   \   0000AB   78..         MOV     R0,#?V0
   \   0000AD   12....       LCALL   ?L_MOV_TO_X
   3013                  TCLinkKeyFrmCntr[i].rxFrmCntr = 0;
   \   0000B0   85..82       MOV     DPL,?V8
   \   0000B3   85..83       MOV     DPH,?V9
   \   0000B6   E4           CLR     A
   \   0000B7   F0           MOVX    @DPTR,A
   \   0000B8   A3           INC     DPTR
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   A3           INC     DPTR
   \   0000BD   02....       LJMP    ??APSME_TCLinkKeyInit_3 & 0xFFFF
   3014                }
   3015                else
   3016                {
   3017                  // set the Frame counters to 0 to existing keys in NV
   3018                  osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   3019                                 sizeof(APSME_TCLKDevEntry_t), &TCLKDevEntry );
   \                     ??APSME_TCLinkKeyInit_2:
   \   0000C0                ; Setup parameters for call to function osal_nv_read
   \   0000C0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C3   75..13       MOV     ?V4,#0x13
   \   0000C6   75..00       MOV     ?V5,#0x0
   \   0000C9   78..         MOV     R0,#?V4
   \   0000CB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CE   7C00         MOV     R4,#0x0
   \   0000D0   7D00         MOV     R5,#0x0
   \   0000D2   AA..         MOV     R2,?V0
   \   0000D4   AB..         MOV     R3,?V1
   \   0000D6   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000D9   7404         MOV     A,#0x4
   \   0000DB   12....       LCALL   ?DEALLOC_XSTACK8
   3020          
   3021                  // increase the value stored in NV
   3022                  TCLKDevEntry.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   \   0000DE   90....       MOV     DPTR,#__Constant_b
   \   0000E1   78..         MOV     R0,#?V4
   \   0000E3   12....       LCALL   ?L_MOV_X
   \   0000E6   85..82       MOV     DPL,?XSP + 0
   \   0000E9   85..83       MOV     DPH,?XSP + 1
   \   0000EC   78..         MOV     R0,#?V4
   \   0000EE   12....       LCALL   ?L_ADD_TO_X
   3023          
   3024                  osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   3025                                  sizeof(APSME_TCLKDevEntry_t), &TCLKDevEntry );
   \   0000F1                ; Setup parameters for call to function osal_nv_write
   \   0000F1   A8..         MOV     R0,?XSP + 0
   \   0000F3   A9..         MOV     R1,?XSP + 1
   \   0000F5   88..         MOV     ?V4,R0
   \   0000F7   89..         MOV     ?V5,R1
   \   0000F9   78..         MOV     R0,#?V4
   \   0000FB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FE   75..13       MOV     ?V4,#0x13
   \   000101   75..00       MOV     ?V5,#0x0
   \   000104   78..         MOV     R0,#?V4
   \   000106   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000109   7C00         MOV     R4,#0x0
   \   00010B   7D00         MOV     R5,#0x0
   \   00010D   AA..         MOV     R2,?V0
   \   00010F   AB..         MOV     R3,?V1
   \   000111   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000114   7404         MOV     A,#0x4
   \   000116   12....       LCALL   ?DEALLOC_XSTACK8
   3026          
   3027                  // set initial values for counters in RAM
   3028                  TCLinkKeyFrmCntr[i].txFrmCntr = TCLKDevEntry.txFrmCntr;
   \   000119   85..82       MOV     DPL,?XSP + 0
   \   00011C   85..83       MOV     DPH,?XSP + 1
   \   00011F   12....       LCALL   ?XLOAD_R0123
   \   000122   85..82       MOV     DPL,?V2
   \   000125   85..83       MOV     DPH,?V3
   \   000128   12....       LCALL   ?XSTORE_R0123
   3029                  TCLinkKeyFrmCntr[i].rxFrmCntr = TCLKDevEntry.rxFrmCntr;
   \   00012B   7404         MOV     A,#0x4
   \   00012D   12....       LCALL   ?XSTACK_DISP0_8
   \   000130   12....       LCALL   ?XLOAD_R0123
   \   000133   85..82       MOV     DPL,?V8
   \   000136   85..83       MOV     DPH,?V9
   \   000139   12....       LCALL   ?XSTORE_R0123
   3030                  
   3031                  // Making sure data is cleared and set to default for every key all the time
   3032                  osal_memset( &TCLKDevEntry, 0x00, sizeof(APSME_TCLKDevEntry_t) );
   \   00013C                ; Setup parameters for call to function osal_memset
   \   00013C   7C13         MOV     R4,#0x13
   \   00013E   7D00         MOV     R5,#0x0
   \   000140   7900         MOV     R1,#0x0
   \   000142   AA..         MOV     R2,?XSP + 0
   \   000144   AB..         MOV     R3,?XSP + 1
   \   000146   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3033                  TCLKDevEntry.keyAttributes = ZG_DEFAULT_KEY;
   \   000149   7410         MOV     A,#0x10
   \   00014B   12....       LCALL   ?XSTACK_DISP0_8
   \   00014E   74FF         MOV     A,#-0x1
   \                     ??APSME_TCLinkKeyInit_3:
   \   000150   F0           MOVX    @DPTR,A
   3034                }
   3035              }
   3036            }
   \                     ??APSME_TCLinkKeyInit_1:
   \   000151   0E           INC     R6
   \   000152   EE           MOV     A,R6
   \   000153   C3           CLR     C
   \   000154   9428         SUBB    A,#0x28
   \   000156   5003         JNC     $+5
   \   000158   02....       LJMP    ??APSME_TCLinkKeyInit_0 & 0xFFFF
   3037          
   3038            if(setDefault)
   \   00015B   EF           MOV     A,R7
   \   00015C   6007         JZ      ??APSME_TCLinkKeyInit_4
   3039            {
   3040              //Force to erase all IC
   3041              APSME_EraseICEntry(NULL);
   \   00015E                ; Setup parameters for call to function APSME_EraseICEntry
   \   00015E   7A00         MOV     R2,#0x0
   \   000160   7B00         MOV     R3,#0x0
   \   000162   12....       LCALL   `??APSME_EraseICEntry::?relay`; Banked call to: APSME_EraseICEntry
   3042            }
   3043          }
   \                     ??APSME_TCLinkKeyInit_4:
   \   000165   7413         MOV     A,#0x13
   \   000167   02....       LJMP    ?Subroutine5 & 0xFFFF
   3044          
   3045          
   3046          
   3047          
   3048          
   3049          
   3050          
   3051          
   3052          
   3053          /******************************************************************************
   3054           * @fn          APSME_TCLinkKeySync
   3055           *
   3056           * @brief       Sync Trust Center LINK key data.
   3057           *
   3058           * @param       srcAddr - [in] srcAddr
   3059           * @param       si      - [in, out] SSP_Info_t
   3060           *
   3061           * @return      ZStatus_t
   3062           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3063          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3064          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3065            uint8 selectedId = gZDSECMGR_TC_DEVICE_MAX;
   3066            ZStatus_t status = ZSecNoKey;
   \   000012   75..A1       MOV     ?V0,#-0x5f
   3067            APSME_TCLKDevEntry_t TCLKDevEntry;
   3068            uint32 *tclkRxFrmCntr;
   3069            uint16                entryIndex = 0xFFFF;
   3070            uint8                 entryFound = FALSE;
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   E4           CLR     A
   \   00001C   F0           MOVX    @DPTR,A
   3071            
   3072          #if ZG_BUILD_JOINING_TYPE
   3073            uint8   defaultEntry[Z_EXTADDR_LEN];
   3074          #endif
   3075            
   3076            
   3077            // Look up the IEEE address of the trust center if it's available
   3078            if ( AddrMgrExtAddrValid( si->extAddr ) == FALSE )
   \   00001D   EE           MOV     A,R6
   \   00001E   2406         ADD     A,#0x6
   \   000020   F5..         MOV     ?V2,A
   \   000022   E4           CLR     A
   \   000023   3F           ADDC    A,R7
   \   000024   F5..         MOV     ?V3,A
   \   000026                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000026   AA..         MOV     R2,?V2
   \   000028   FB           MOV     R3,A
   \   000029   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   00002C   E9           MOV     A,R1
   \   00002D   700B         JNZ     ??APSME_TCLinkKeySync_0
   3079            {
   3080              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   00002F                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002F   AC..         MOV     R4,?V2
   \   000031   AD..         MOV     R5,?V3
   \   000033   AA..         MOV     R2,?V4
   \   000035   AB..         MOV     R3,?V5
   \   000037   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   3081            }
   3082          
   3083            entryIndex = APSME_SearchTCLinkKeyEntry(si->extAddr,&entryFound,&TCLKDevEntry);
   \                     ??APSME_TCLinkKeySync_0:
   \   00003A                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   00003A   7401         MOV     A,#0x1
   \   00003C   12....       LCALL   ?XSTACK_DISP100_8
   \   00003F   88..         MOV     ?V4,R0
   \   000041   89..         MOV     ?V5,R1
   \   000043   78..         MOV     R0,#?V4
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?XSTACK_DISP102_8
   \   00004D   AA..         MOV     R2,?V2
   \   00004F   AB..         MOV     R3,?V3
   \   000051   12....       LCALL   `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   000054   7402         MOV     A,#0x2
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
   \   000059   8A..         MOV     ?V2,R2
   \   00005B   A8..         MOV     R0,?V2
   3084            
   3085          #if ZG_BUILD_JOINING_TYPE
   3086            if(ZG_DEVICE_JOINING_TYPE && !entryFound)
   3087            {
   3088              osal_memset(defaultEntry, 0, Z_EXTADDR_LEN);
   3089              entryIndex = APSME_SearchTCLinkKeyEntry(defaultEntry,&entryFound,&TCLKDevEntry);
   3090            }
   3091          #endif
   3092            
   3093            if(entryFound)
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   7003         JNZ     $+5
   \   000066   02....       LJMP    ??APSME_TCLinkKeySync_1 & 0xFFFF
   3094            {
   3095              status = ZSuccess;
   \   000069   75..00       MOV     ?V0,#0x0
   3096              
   3097              selectedId = entryIndex - ZCD_NV_TCLK_TABLE_START;
   3098          
   3099              switch(TCLKDevEntry.keyAttributes)
   \   00006C   EE           MOV     A,R6
   \   00006D   240F         ADD     A,#0xf
   \   00006F   F5..         MOV     ?V2,A
   \   000071   E4           CLR     A
   \   000072   3F           ADDC    A,R7
   \   000073   F5..         MOV     ?V3,A
   \   000075   7411         MOV     A,#0x11
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   6034         JZ      ??APSME_TCLinkKeySync_2
   \   00007D   14           DEC     A
   \   00007E   600A         JZ      ??APSME_TCLinkKeySync_3
   \   000080   14           DEC     A
   \   000081   6044         JZ      ??APSME_TCLinkKeySync_4
   \   000083   2403         ADD     A,#0x3
   \   000085   6003         JZ      $+5
   \   000087   02....       LJMP    ??APSME_TCLinkKeySync_1 & 0xFFFF
   3100              {
   3101                case ZG_UNVERIFIED_KEY:
   3102                  #if ZG_BUILD_JOINING_TYPE
   3103                  if(ZG_DEVICE_JOINING_TYPE)
   3104                  {   
   3105                    si->keyNvId = ZCD_NV_TCLK_JOIN_DEV;
   3106                    break;
   3107                  }
   3108                  #endif
   3109                case ZG_DEFAULT_KEY:
   3110                  if(ZG_DEVICE_JOINING_TYPE)
   \                     ??APSME_TCLinkKeySync_3:
   \   00008A   90....       MOV     DPTR,#zgDeviceLogicalType
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   6401         XRL     A,#0x1
   \   000090   6005         JZ      ??APSME_TCLinkKeySync_5
   \   000092   E0           MOVX    A,@DPTR
   \   000093   6402         XRL     A,#0x2
   \   000095   700C         JNZ     ??APSME_TCLinkKeySync_6
   3111                  { 
   3112                    //If default was found, then it is joining as FN, then try distributed key as well
   3113                    si->distributedKeyTry = TRUE;
   \                     ??APSME_TCLinkKeySync_5:
   \   000097   EE           MOV     A,R6
   \   000098   2420         ADD     A,#0x20
   \   00009A   F582         MOV     DPL,A
   \   00009C   E4           CLR     A
   \   00009D   3F           ADDC    A,R7
   \   00009E   F583         MOV     DPH,A
   \   0000A0   7401         MOV     A,#0x1
   \   0000A2   F0           MOVX    @DPTR,A
   3114                  }
   3115                  si->keyNvId = ZCD_NV_TCLK_DEFAULT;
   \                     ??APSME_TCLinkKeySync_6:
   \   0000A3   85..82       MOV     DPL,?V2
   \   0000A6   85..83       MOV     DPH,?V3
   \   0000A9   7403         MOV     A,#0x3
   \   0000AB   F0           MOVX    @DPTR,A
   \   0000AC   A3           INC     DPTR
   \   0000AD   7401         MOV     A,#0x1
   \   0000AF   8012         SJMP    ??APSME_TCLinkKeySync_7
   3116                break;
   3117                case ZG_PROVISIONAL_KEY:
   3118                  si->keyNvId = ZCD_NV_TCLK_IC_TABLE_START + TCLKDevEntry.SeedShift_IcIndex;
   \                     ??APSME_TCLinkKeySync_2:
   \   0000B1   7413         MOV     A,#0x13
   \   0000B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B6   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0000B9   85..82       MOV     DPL,?V2
   \   0000BC   85..83       MOV     DPH,?V3
   \   0000BF   E8           MOV     A,R0
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   E9           MOV     A,R1
   \                     ??APSME_TCLinkKeySync_7:
   \   0000C3   F0           MOVX    @DPTR,A
   3119                break;
   \   0000C4   02....       LJMP    ??APSME_TCLinkKeySync_1 & 0xFFFF
   3120                case ZG_VERIFIED_KEY:
   3121                  //Only verify the frame counter for Verified keys
   3122                  tclkRxFrmCntr = &TCLinkKeyFrmCntr[selectedId].rxFrmCntr;
   \                     ??APSME_TCLinkKeySync_4:
   \   0000C7   E8           MOV     A,R0
   \   0000C8   24EF         ADD     A,#-0x11
   \   0000CA   75F009       MOV     B,#0x9
   \   0000CD   A4           MUL     AB
   \   0000CE   F8           MOV     R0,A
   \   0000CF   A9F0         MOV     R1,B
   \   0000D1   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   0000D3   28           ADD     A,R0
   \   0000D4   F5..         MOV     ?V8,A
   \   0000D6   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   0000D8   39           ADDC    A,R1
   \   0000D9   F5..         MOV     ?V9,A
   3123          
   3124                  if ( si->frmCntr >= *tclkRxFrmCntr )
   \   0000DB   EE           MOV     A,R6
   \   0000DC   2412         ADD     A,#0x12
   \   0000DE   F582         MOV     DPL,A
   \   0000E0   E4           CLR     A
   \   0000E1   3F           ADDC    A,R7
   \   0000E2   F583         MOV     DPH,A
   \   0000E4   78..         MOV     R0,#?V4
   \   0000E6   12....       LCALL   ?L_MOV_X
   \   0000E9   85..82       MOV     DPL,?V8
   \   0000EC   85..83       MOV     DPH,?V9
   \   0000EF   78..         MOV     R0,#?V4
   \   0000F1   12....       LCALL   ?UL_GE_X
   \   0000F4   5066         JNC     ??APSME_TCLinkKeySync_8
   3125                  {
   3126                    // update the rx frame counter
   3127                    *tclkRxFrmCntr = si->frmCntr + 1;
   \   0000F6   90....       MOV     DPTR,#__Constant_1
   \   0000F9   78..         MOV     R0,#?V4
   \   0000FB   12....       LCALL   ?L_ADD_X
   \   0000FE   85..82       MOV     DPL,?V8
   \   000101   85..83       MOV     DPH,?V9
   \   000104   E5..         MOV     A,?V4
   \   000106   F0           MOVX    @DPTR,A
   \   000107   A3           INC     DPTR
   \   000108   E5..         MOV     A,?V5
   \   00010A   F0           MOVX    @DPTR,A
   \   00010B   A3           INC     DPTR
   \   00010C   E5..         MOV     A,?V6
   \   00010E   F0           MOVX    @DPTR,A
   \   00010F   A3           INC     DPTR
   \   000110   E5..         MOV     A,?V7
   \   000112   F0           MOVX    @DPTR,A
   3128                    status = ZSuccess;
   3129                    
   3130                    #if ZG_BUILD_JOINING_TYPE
   3131                    if(ZG_DEVICE_JOINING_TYPE)
   3132                    {   
   3133                      si->keyNvId = ZCD_NV_TCLK_JOIN_DEV;
   3134                      break;
   3135                    }
   3136                    #endif
   3137                    #if ZG_BUILD_COORDINATOR_TYPE
   3138                    if(ZG_DEVICE_COORDINATOR_TYPE)
   3139                    {
   3140                      si->keyNvId = ZCD_NV_TCLK_SEED;
   \   000113   85..82       MOV     DPL,?V2
   \   000116   85..83       MOV     DPH,?V3
   \   000119   7401         MOV     A,#0x1
   \   00011B   F0           MOVX    @DPTR,A
   \   00011C   A3           INC     DPTR
   \   00011D   F0           MOVX    @DPTR,A
   3141                      si->seedShift = TCLKDevEntry.SeedShift_IcIndex;
   \   00011E   7413         MOV     A,#0x13
   \   000120   12....       LCALL   ?XSTACK_DISP0_8
   \   000123   E0           MOVX    A,@DPTR
   \   000124   C0E0         PUSH    A
   \   000126   EE           MOV     A,R6
   \   000127   2421         ADD     A,#0x21
   \   000129   F582         MOV     DPL,A
   \   00012B   E4           CLR     A
   \   00012C   3F           ADDC    A,R7
   \   00012D   F583         MOV     DPH,A
   \   00012F   D0E0         POP     A
   \   000131   F0           MOVX    @DPTR,A
   3142                    }
   3143                    #endif
   3144                    osal_memcpy(si->dstExtAddr, TCLKDevEntry.extAddr,Z_EXTADDR_LEN);
   \   000132                ; Setup parameters for call to function osal_memcpy
   \   000132   7409         MOV     A,#0x9
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   A982         MOV     R1,DPL
   \   000139   AA83         MOV     R2,DPH
   \   00013B   89..         MOV     ?V4,R1
   \   00013D   8A..         MOV     ?V5,R2
   \   00013F   75..00       MOV     ?V6,#0x0
   \   000142   78..         MOV     R0,#?V4
   \   000144   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000147   7C08         MOV     R4,#0x8
   \   000149   7D00         MOV     R5,#0x0
   \   00014B   EE           MOV     A,R6
   \   00014C   2418         ADD     A,#0x18
   \   00014E   FA           MOV     R2,A
   \   00014F   E4           CLR     A
   \   000150   3F           ADDC    A,R7
   \   000151   FB           MOV     R3,A
   \   000152   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000155   7403         MOV     A,#0x3
   \   000157   12....       LCALL   ?DEALLOC_XSTACK8
   \   00015A   8003         SJMP    ??APSME_TCLinkKeySync_1
   3145                  }
   3146                  else
   3147                  {
   3148                    status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_8:
   \   00015C   75..A2       MOV     ?V0,#-0x5e
   3149                  }
   3150                break;
   3151                default:
   3152                  //This should not happen
   3153                break;
   3154              }
   3155            }
   3156            
   3157            return status;
   \                     ??APSME_TCLinkKeySync_1:
   \   00015F   A9..         MOV     R1,?V0
   \   000161   7414         MOV     A,#0x14
   \   000163                REQUIRE ?Subroutine5
   \   000163                ; // Fall through to label ?Subroutine5
   3158          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2404         ADD     A,#0x4
   \   000003   F8           MOV     R0,A
   \   000004   E4           CLR     A
   \   000005   3401         ADDC    A,#0x1
   \   000007   F9           MOV     R1,A
   \   000008   22           RET
   3159          
   3160          /******************************************************************************
   3161           * @fn          APSME_TCLinkKeyLoad
   3162           *
   3163           * @brief       Load Trust Center LINK key data.
   3164           *
   3165           * @param       dstAddr - [in] dstAddr
   3166           * @param       si      - [in, out] SSP_Info_t
   3167           *
   3168           * @return      ZStatus_t
   3169           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3170          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3171          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 33
   \   000005   74DF         MOV     A,#-0x21
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V2,R4
   \   00000C   8D..         MOV     ?V3,R5
   3172            APSME_TCLKDevEntry_t TCLKDevEntry;
   3173            AddrMgrEntry_t       addrEntry;
   3174            uint16               entryIndex;
   3175            uint8                extAddrFound;
   3176            uint8                found;
   3177            ZStatus_t status =   ZSecNoKey;
   \   00000E   7EA1         MOV     R6,#-0x5f
   3178            
   3179            // Look up the ami of the srcAddr if available
   3180            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   000010   7414         MOV     A,#0x14
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   E4           CLR     A
   \   000016   F0           MOVX    @DPTR,A
   3181            addrEntry.nwkAddr = dstAddr;
   \   000017   7415         MOV     A,#0x15
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine26 & 0xFFFF
   3182          
   3183            extAddrFound = AddrMgrExtAddrValid( si->extAddr );
   3184            
   3185            if(extAddrFound)
   \                     ??CrossCallReturnLabel_27:
   \   00001F   EC           MOV     A,R4
   \   000020   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000023                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000023   AA..         MOV     R2,?V4
   \   000025   FB           MOV     R3,A
   \   000026   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000029   E9           MOV     A,R1
   \   00002A   7003         JNZ     $+5
   \   00002C   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   3186            {
   3187              entryIndex = APSME_SearchTCLinkKeyEntry(si->extAddr,&found,&TCLKDevEntry);
   \   00002F                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   00002F   7401         MOV     A,#0x1
   \   000031   12....       LCALL   ?XSTACK_DISP100_8
   \   000034   88..         MOV     ?V0,R0
   \   000036   89..         MOV     ?V1,R1
   \   000038   78..         MOV     R0,#?V0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP102_8
   \   000042   AA..         MOV     R2,?V4
   \   000044   AB..         MOV     R3,?V5
   \   000046   12....       LCALL   `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004E   8A..         MOV     ?V0,R2
   \   000050   8B..         MOV     ?V1,R3
   \   000052   AE..         MOV     R6,?V0
   \   000054   AF..         MOV     R7,?V1
   3188              if(entryIndex != 0xFFFF)
   \   000056   E5..         MOV     A,?V2
   \   000058   240F         ADD     A,#0xf
   \   00005A   F5..         MOV     ?V0,A
   \   00005C   E4           CLR     A
   \   00005D   35..         ADDC    A,?V3
   \   00005F   F5..         MOV     ?V1,A
   \   000061   74FF         MOV     A,#-0x1
   \   000063   6E           XRL     A,R6
   \   000064   7003         JNZ     ??APSME_TCLinkKeyLoad_1
   \   000066   74FF         MOV     A,#-0x1
   \   000068   6F           XRL     A,R7
   \                     ??APSME_TCLinkKeyLoad_1:
   \   000069   7003         JNZ     $+5
   \   00006B   02....       LJMP    ??APSME_TCLinkKeyLoad_2 & 0xFFFF
   3189              {
   3190                uint8   i = entryIndex - ZCD_NV_TCLK_TABLE_START;
   \   00006E   EE           MOV     A,R6
   \   00006F   12....       LCALL   ?Subroutine46 & 0xFFFF
   3191                
   3192                if(found)
   \                     ??CrossCallReturnLabel_63:
   \   000072   F5..         MOV     ?V8,A
   \   000074   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000076   39           ADDC    A,R1
   \   000077   F5..         MOV     ?V9,A
   \   000079   85..82       MOV     DPL,?XSP + 0
   \   00007C   85..83       MOV     DPH,?XSP + 1
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   607B         JZ      ??APSME_TCLinkKeyLoad_3
   3193                {
   3194                  switch(TCLKDevEntry.keyAttributes)
   \   000082   7411         MOV     A,#0x11
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   E0           MOVX    A,@DPTR
   \   000088   6010         JZ      ??APSME_TCLinkKeyLoad_4
   \   00008A   14           DEC     A
   \   00008B   600A         JZ      ??APSME_TCLinkKeyLoad_5
   \   00008D   14           DEC     A
   \   00008E   601F         JZ      ??APSME_TCLinkKeyLoad_6
   \   000090   2403         ADD     A,#0x3
   \   000092   6003         JZ      $+5
   \   000094   02....       LJMP    ??APSME_TCLinkKeyLoad_7 & 0xFFFF
   3195                  {
   3196                    case ZG_UNVERIFIED_KEY:
   3197                      #if ZG_BUILD_JOINING_TYPE
   3198                      if(ZG_DEVICE_JOINING_TYPE)
   3199                      {   
   3200                        si->keyNvId = ZCD_NV_TCLK_JOIN_DEV;
   3201                        break;
   3202                      }
   3203                      #endif
   3204                    case ZG_DEFAULT_KEY:
   3205                      si->keyNvId = ZCD_NV_TCLK_DEFAULT;
   \                     ??APSME_TCLinkKeyLoad_5:
   \   000097   02....       LJMP    ??APSME_TCLinkKeyLoad_8 & 0xFFFF
   3206                    break;
   3207                    case ZG_PROVISIONAL_KEY:
   3208                      si->keyNvId = ZCD_NV_TCLK_IC_TABLE_START + TCLKDevEntry.SeedShift_IcIndex;
   \                     ??APSME_TCLinkKeyLoad_4:
   \   00009A   7413         MOV     A,#0x13
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0000A2   85..82       MOV     DPL,?V0
   \   0000A5   85..83       MOV     DPH,?V1
   \   0000A8   E8           MOV     A,R0
   \   0000A9   F0           MOVX    @DPTR,A
   \   0000AA   A3           INC     DPTR
   \   0000AB   E9           MOV     A,R1
   \   0000AC   02....       LJMP    ??APSME_TCLinkKeyLoad_9 & 0xFFFF
   3209                    break;
   3210                    case ZG_VERIFIED_KEY:
   3211                      #if ZG_BUILD_JOINING_TYPE
   3212                      if(ZG_DEVICE_JOINING_TYPE)
   3213                      {   
   3214                        si->keyNvId = ZCD_NV_TCLK_JOIN_DEV;
   3215                        break;
   3216                      }
   3217                      #endif
   3218                      #if ZG_BUILD_COORDINATOR_TYPE
   3219                      if(ZG_DEVICE_COORDINATOR_TYPE)
   3220                      {
   3221                        si->keyNvId = ZCD_NV_TCLK_SEED;
   \                     ??APSME_TCLinkKeyLoad_6:
   \   0000AF   85..82       MOV     DPL,?V0
   \   0000B2   85..83       MOV     DPH,?V1
   \   0000B5   7401         MOV     A,#0x1
   \   0000B7   F0           MOVX    @DPTR,A
   \   0000B8   A3           INC     DPTR
   \   0000B9   F0           MOVX    @DPTR,A
   3222                        si->seedShift = TCLKDevEntry.SeedShift_IcIndex;
   \   0000BA   7413         MOV     A,#0x13
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   C0E0         PUSH    A
   \   0000C2   E5..         MOV     A,?V2
   \   0000C4   2421         ADD     A,#0x21
   \   0000C6   F582         MOV     DPL,A
   \   0000C8   E4           CLR     A
   \   0000C9   35..         ADDC    A,?V3
   \   0000CB   F583         MOV     DPH,A
   \   0000CD   D0E0         POP     A
   \   0000CF   F0           MOVX    @DPTR,A
   3223                      }
   3224                      #endif
   3225                      osal_memcpy(si->dstExtAddr, TCLKDevEntry.extAddr,Z_EXTADDR_LEN);
   \   0000D0                ; Setup parameters for call to function osal_memcpy
   \   0000D0   7409         MOV     A,#0x9
   \   0000D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D5   A982         MOV     R1,DPL
   \   0000D7   AA83         MOV     R2,DPH
   \   0000D9   89..         MOV     ?V4,R1
   \   0000DB   8A..         MOV     ?V5,R2
   \   0000DD   75..00       MOV     ?V6,#0x0
   \   0000E0   78..         MOV     R0,#?V4
   \   0000E2   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E5   7C08         MOV     R4,#0x8
   \   0000E7   7D00         MOV     R5,#0x0
   \   0000E9   E5..         MOV     A,?V2
   \   0000EB   2418         ADD     A,#0x18
   \   0000ED   FA           MOV     R2,A
   \   0000EE   E4           CLR     A
   \   0000EF   35..         ADDC    A,?V3
   \   0000F1   FB           MOV     R3,A
   \   0000F2   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000F5   7403         MOV     A,#0x3
   \   0000F7   12....       LCALL   ?DEALLOC_XSTACK8
   3226                    break;
   \   0000FA   02....       LJMP    ??APSME_TCLinkKeyLoad_7 & 0xFFFF
   3227                    default:
   3228                      //This should not happen
   3229                    break;
   3230                  }
   3231                }
   3232                //Not found, then create an entry for it. Adding the device to the TCLKDev Entries for first time
   3233                else
   3234                {
   3235                  //Initialize the entry
   3236                  osal_memcpy(TCLKDevEntry.extAddr, si->extAddr, Z_EXTADDR_LEN);
   \                     ??APSME_TCLinkKeyLoad_3:
   \   0000FD                ; Setup parameters for call to function osal_memcpy
   \   0000FD   75..00       MOV     ?V6,#0x0
   \   000100   78..         MOV     R0,#?V4
   \   000102   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000105   7C08         MOV     R4,#0x8
   \   000107   7D00         MOV     R5,#0x0
   \   000109   740C         MOV     A,#0xc
   \   00010B   12....       LCALL   ?XSTACK_DISP0_8
   \   00010E   AA82         MOV     R2,DPL
   \   000110   AB83         MOV     R3,DPH
   \   000112   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000115   7403         MOV     A,#0x3
   \   000117   12....       LCALL   ?DEALLOC_XSTACK8
   3237                  TCLKDevEntry.keyAttributes = ZG_DEFAULT_KEY;
   \   00011A   7411         MOV     A,#0x11
   \   00011C   12....       LCALL   ?XSTACK_DISP0_8
   \   00011F   74FF         MOV     A,#-0x1
   \   000121   F0           MOVX    @DPTR,A
   3238                  TCLKDevEntry.keyType = ZG_GLOBAL_LINK_KEY;
   \   000122   7412         MOV     A,#0x12
   \   000124   12....       LCALL   ?XSTACK_DISP0_8
   \   000127   7401         MOV     A,#0x1
   \   000129   F0           MOVX    @DPTR,A
   3239                  //Create the entry with a random shift of the seed. Validate the maximum shift of the seed which is 15
   3240                  TCLKDevEntry.SeedShift_IcIndex = osal_rand() & 0x000F;
   \   00012A                ; Setup parameters for call to function osal_rand
   \   00012A   12....       LCALL   `??osal_rand::?relay`; Banked call to: osal_rand
   \   00012D   EA           MOV     A,R2
   \   00012E   540F         ANL     A,#0xf
   \   000130   C0E0         PUSH    A
   \   000132   7413         MOV     A,#0x13
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   D0E0         POP     A
   \   000139   F0           MOVX    @DPTR,A
   3241                  TCLKDevEntry.txFrmCntr = 0;
   \   00013A   7401         MOV     A,#0x1
   \   00013C   12....       LCALL   ?XSTACK_DISP0_8
   \   00013F   12....       LCALL   ?Subroutine24 & 0xFFFF
   3242                  TCLKDevEntry.rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_18:
   \   000142   12....       LCALL   ?XSTACK_DISP0_8
   \   000145   12....       LCALL   ?Subroutine13 & 0xFFFF
   3243                  //save entry in nv
   3244                  osal_nv_write(entryIndex,0,sizeof(APSME_TCLKDevEntry_t),&TCLKDevEntry);
   \                     ??CrossCallReturnLabel_199:
   \   000148   12....       LCALL   ?XSTACK_DISP100_8
   \   00014B   88..         MOV     ?V4,R0
   \   00014D   89..         MOV     ?V5,R1
   \   00014F   78..         MOV     R0,#?V4
   \   000151   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000154   75..13       MOV     ?V4,#0x13
   \   000157   75..00       MOV     ?V5,#0x0
   \   00015A   78..         MOV     R0,#?V4
   \   00015C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015F   7C00         MOV     R4,#0x0
   \   000161   7D00         MOV     R5,#0x0
   \   000163   EE           MOV     A,R6
   \   000164   FA           MOV     R2,A
   \   000165   EF           MOV     A,R7
   \   000166   FB           MOV     R3,A
   \   000167   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00016A   7404         MOV     A,#0x4
   \   00016C   12....       LCALL   ?DEALLOC_XSTACK8
   3245                  //Initialize framecounter
   3246                  osal_memset(&TCLinkKeyFrmCntr[i],0,sizeof(APSME_TCLinkKeyFrmCntr_t));
   \   00016F                ; Setup parameters for call to function osal_memset
   \   00016F   7C09         MOV     R4,#0x9
   \   000171   7D00         MOV     R5,#0x0
   \   000173   7900         MOV     R1,#0x0
   \   000175   AA..         MOV     R2,?V8
   \   000177   AB..         MOV     R3,?V9
   \   000179   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3247                  // set the keyNvId to use
   3248                  si->keyNvId = ZCD_NV_TCLK_DEFAULT;
   \                     ??APSME_TCLinkKeyLoad_8:
   \   00017C   85..82       MOV     DPL,?V0
   \   00017F   85..83       MOV     DPH,?V1
   \   000182   7403         MOV     A,#0x3
   \   000184   F0           MOVX    @DPTR,A
   \   000185   A3           INC     DPTR
   \   000186   7401         MOV     A,#0x1
   \                     ??APSME_TCLinkKeyLoad_9:
   \   000188   F0           MOVX    @DPTR,A
   3249                }
   3250          
   3251                // update link key related fields
   3252                si->keyID   = SEC_KEYID_LINK;
   \                     ??APSME_TCLinkKeyLoad_7:
   \   000189   E5..         MOV     A,?V2
   \   00018B   240E         ADD     A,#0xe
   \   00018D   F582         MOV     DPL,A
   \   00018F   E4           CLR     A
   \   000190   35..         ADDC    A,?V3
   \   000192   F583         MOV     DPH,A
   \   000194   E4           CLR     A
   \   000195   F0           MOVX    @DPTR,A
   3253                si->frmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   000196   85..82       MOV     DPL,?V8
   \   000199   85..83       MOV     DPH,?V9
   \   00019C   12....       LCALL   ?XLOAD_R0123
   \   00019F   E5..         MOV     A,?V2
   \   0001A1   2412         ADD     A,#0x12
   \   0001A3   F582         MOV     DPL,A
   \   0001A5   E4           CLR     A
   \   0001A6   35..         ADDC    A,?V3
   \   0001A8   F583         MOV     DPH,A
   \   0001AA   12....       LCALL   ?XSTORE_R0123
   3254          
   3255                // update outgoing frame counter
   3256                TCLinkKeyFrmCntr[i].txFrmCntr++;
   \   0001AD   90....       MOV     DPTR,#__Constant_1
   \   0001B0   78..         MOV     R0,#?V0
   \   0001B2   12....       LCALL   ?L_MOV_X
   \   0001B5   85..82       MOV     DPL,?V8
   \   0001B8   85..83       MOV     DPH,?V9
   \   0001BB   78..         MOV     R0,#?V0
   \   0001BD   12....       LCALL   ?L_ADD_TO_X
   3257          
   3258            #if defined ( NV_RESTORE )
   3259                // write periodically to NV
   3260                if ( !(TCLinkKeyFrmCntr[i].txFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   \   0001C0   85..82       MOV     DPL,?V8
   \   0001C3   85..83       MOV     DPH,?V9
   \   0001C6   78..         MOV     R0,#?V0
   \   0001C8   12....       LCALL   ?L_MOV_X
   \   0001CB   90....       MOV     DPTR,#__Constant_a
   \   0001CE   78..         MOV     R0,#?V4
   \   0001D0   12....       LCALL   ?L_MOV_X
   \   0001D3   78..         MOV     R0,#?V0
   \   0001D5   79..         MOV     R1,#?V4
   \   0001D7   12....       LCALL   ?UL_DIV_MOD
   \   0001DA   E5..         MOV     A,?V4
   \   0001DC   45..         ORL     A,?V5
   \   0001DE   45..         ORL     A,?V6
   \   0001E0   45..         ORL     A,?V7
   \   0001E2   702C         JNZ     ??APSME_TCLinkKeyLoad_10
   3261                {
   3262                  // set the flag to write key to NV
   3263                  TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   \   0001E4   85..82       MOV     DPL,?V8
   \   0001E7   85..83       MOV     DPH,?V9
   \   0001EA   A3           INC     DPTR
   \   0001EB   A3           INC     DPTR
   \   0001EC   A3           INC     DPTR
   \   0001ED   A3           INC     DPTR
   \   0001EE   A3           INC     DPTR
   \   0001EF   A3           INC     DPTR
   \   0001F0   A3           INC     DPTR
   \   0001F1   A3           INC     DPTR
   \   0001F2   7401         MOV     A,#0x1
   \   0001F4   F0           MOVX    @DPTR,A
   3264          
   3265                  // Notify the ZDApp that the frame counter has changed.
   3266                  osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   \   0001F5                ; Setup parameters for call to function osal_set_event
   \   0001F5   7A00         MOV     R2,#0x0
   \   0001F7   7B04         MOV     R3,#0x4
   \   0001F9   90....       MOV     DPTR,#ZDAppTaskID
   \   0001FC   E0           MOVX    A,@DPTR
   \   0001FD   F9           MOV     R1,A
   \   0001FE   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
   \   000201   800D         SJMP    ??APSME_TCLinkKeyLoad_10
   3267                }
   3268            #endif
   3269              }  
   3270              else
   3271              {
   3272                //If no more TCLK entries, try global so we can try to add legacy devices
   3273                si->keyNvId = ZCD_NV_TCLK_DEFAULT;
   \                     ??APSME_TCLinkKeyLoad_2:
   \   000203   85..82       MOV     DPL,?V0
   \   000206   85..83       MOV     DPH,?V1
   \   000209   7403         MOV     A,#0x3
   \   00020B   F0           MOVX    @DPTR,A
   \   00020C   A3           INC     DPTR
   \   00020D   7401         MOV     A,#0x1
   \   00020F   F0           MOVX    @DPTR,A
   3274              }
   3275              status = ZSuccess;
   \                     ??APSME_TCLinkKeyLoad_10:
   \   000210   7E00         MOV     R6,#0x0
   \   000212   8015         SJMP    ??APSME_TCLinkKeyLoad_11
   \                     ??APSME_TCLinkKeyLoad_0:
   \   000214                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   3276            }
   \   000214   7414         MOV     A,#0x14
   \   000216   12....       LCALL   ?XSTACK_DISP101_8
   \   000219   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00021C   E9           MOV     A,R1
   \   00021D   6401         XRL     A,#0x1
   \   00021F   7008         JNZ     ??APSME_TCLinkKeyLoad_11
   3277            
   3278            // If no TC link key found, remove the device from the address manager
   3279            if ( (status != ZSuccess) && (AddrMgrEntryLookupNwk(&addrEntry) == TRUE) )
   3280            {
   3281              AddrMgrEntryRelease( &addrEntry );
   \   000221                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000221   7414         MOV     A,#0x14
   \   000223   12....       LCALL   ?XSTACK_DISP101_8
   \   000226   12....       LCALL   `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   3282            }
   3283          
   3284            return status;
   \                     ??APSME_TCLinkKeyLoad_11:
   \   000229   EE           MOV     A,R6
   \   00022A   F9           MOV     R1,A
   \   00022B   7421         MOV     A,#0x21
   \   00022D   02....       LJMP    ?Subroutine5 & 0xFFFF
   3285          }
   3286          
   3287          /******************************************************************************
   3288           * @fn          APSME_IsDefaultTCLK
   3289           *
   3290           * @brief       Return TRUE or FALSE based on the extended address.  If the
   3291           *              input ext address is all FFs, it means the trust center link
   3292           *              assoiciated with the address is the default trust center link key
   3293           *
   3294           * @param       extAddr - [in] extended address
   3295           *
   3296           * @return      uint8 TRUE/FALSE
   3297           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3298          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   3299          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3300            return osal_isbufset( extAddr, 0xFF, Z_EXTADDR_LEN );
   \   000004                ; Setup parameters for call to function osal_isbufset
   \   000004   7C08         MOV     R4,#0x8
   \   000006   79FF         MOV     R1,#-0x1
   \   000008   12....       LCALL   `??osal_isbufset::?relay`; Banked call to: osal_isbufset
   \   00000B   02....       LJMP    ??Subroutine63_0 & 0xFFFF
   3301          }
   3302          
   3303          /******************************************************************************
   3304           * @fn          ZDSecMgrNwkKeyInit
   3305           *
   3306           * @brief       Initialize the NV items for
   3307           *                  ZCD_NV_NWKKEY,
   3308           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and
   3309           *                  ZCD_NV_NWK_ALTERN_KEY_INFO
   3310           *
   3311           * @param       setDefault
   3312           *
   3313           * @return      none
   3314           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3315          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   3316          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 50
   \   000005   74CE         MOV     A,#-0x32
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0,R1
   3317            uint8 status;
   3318            nwkKeyDesc nwkKey;
   3319            // Initialize NV items for NWK key, this structure contains the frame counter
   3320            // and is only used when NV_RESTORE is enabled
   3321            nwkActiveKeyItems keyItems;
   3322            
   3323          
   3324            uint8 i,nwkFrameCounterReset = FALSE;
   \   00000C   C2..         CLR     ?VB.0
   3325            nwkSecMaterialDesc_t nwkSecMaterialDesc;
   3326            
   3327            //NwkSecMaterial entry is empty if set to 0s
   3328            osal_memset(&nwkSecMaterialDesc,0,sizeof(nwkSecMaterialDesc_t));
   \   00000E                ; Setup parameters for call to function osal_memset
   \   00000E   7C0C         MOV     R4,#0xc
   \   000010   7D00         MOV     R5,#0x0
   \   000012   7900         MOV     R1,#0x0
   \   000014   AA..         MOV     R2,?XSP + 0
   \   000016   AB..         MOV     R3,?XSP + 1
   \   000018   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3329            
   3330            // Has been set to reset the nwk security material?
   3331            if ( zgReadStartupOptions() & ZCD_STARTOPT_CLEAR_NWK_FRAME_COUNTER )
   \   00001B                ; Setup parameters for call to function zgReadStartupOptions
   \   00001B   12....       LCALL   `??zgReadStartupOptions::?relay`; Banked call to: zgReadStartupOptions
   \   00001E   E9           MOV     A,R1
   \   00001F   F8           MOV     R0,A
   \   000020   A2E7         MOV     C,0xE0 /* A   */.7
   \   000022   5002         JNC     ??ZDSecMgrNwkKeyInit_0
   3332            {
   3333              nwkFrameCounterReset = TRUE;
   \   000024   D2..         SETB    ?VB.0
   3334            }
   3335            
   3336            //Initialize the nwk security material
   3337            for( i = 0; i < gMAX_NWK_SEC_MATERIAL_TABLE_ENTRIES; i++)
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   000026   75..00       MOV     ?V1,#0x0
   \   000029   804D         SJMP    ??ZDSecMgrNwkKeyInit_1
   3338            {
   3339              if((osal_nv_item_init(ZCD_NV_NWK_SEC_MATERIAL_TABLE_START + i,sizeof(nwkSecMaterialDesc_t),&nwkSecMaterialDesc) == SUCCESS) && (nwkFrameCounterReset))
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   00002B   EE           MOV     A,R6
   \   00002C   2475         ADD     A,#0x75
   \   00002E   FE           MOV     R6,A
   \   00002F   5001         JNC     ??ZDSecMgrNwkKeyInit_3
   \   000031   0F           INC     R7
   \                     ??ZDSecMgrNwkKeyInit_3:
   \   000032                ; Setup parameters for call to function osal_nv_item_init
   \   000032   A8..         MOV     R0,?XSP + 0
   \   000034   A9..         MOV     R1,?XSP + 1
   \   000036   88..         MOV     ?V2,R0
   \   000038   89..         MOV     ?V3,R1
   \   00003A   78..         MOV     R0,#?V2
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   7C0C         MOV     R4,#0xc
   \   000041   7D00         MOV     R5,#0x0
   \   000043   EE           MOV     A,R6
   \   000044   FA           MOV     R2,A
   \   000045   EF           MOV     A,R7
   \   000046   FB           MOV     R3,A
   \   000047   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00004A   7402         MOV     A,#0x2
   \   00004C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004F   E9           MOV     A,R1
   \   000050   7024         JNZ     ??ZDSecMgrNwkKeyInit_4
   \   000052   A2..         MOV     C,?VB.0
   \   000054   5020         JNC     ??ZDSecMgrNwkKeyInit_4
   3340              {
   3341                osal_nv_write(ZCD_NV_NWK_SEC_MATERIAL_TABLE_START + i,0,sizeof(nwkSecMaterialDesc_t),&nwkSecMaterialDesc);
   \   000056                ; Setup parameters for call to function osal_nv_write
   \   000056   78..         MOV     R0,#?V2
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   75..0C       MOV     ?V2,#0xc
   \   00005E   75..00       MOV     ?V3,#0x0
   \   000061   78..         MOV     R0,#?V2
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C00         MOV     R4,#0x0
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   EE           MOV     A,R6
   \   00006B   FA           MOV     R2,A
   \   00006C   EF           MOV     A,R7
   \   00006D   FB           MOV     R3,A
   \   00006E   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000071   7404         MOV     A,#0x4
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   3342              }
   3343            }
   \                     ??ZDSecMgrNwkKeyInit_4:
   \   000076   05..         INC     ?V1
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   000078   AE..         MOV     R6,?V1
   \   00007A   7F00         MOV     R7,#0x0
   \   00007C   90....       MOV     DPTR,#gMAX_NWK_SEC_MATERIAL_TABLE_ENTRIES
   \   00007F   E4           CLR     A
   \   000080   93           MOVC    A,@A+DPTR
   \   000081   F8           MOV     R0,A
   \   000082   EE           MOV     A,R6
   \   000083   C3           CLR     C
   \   000084   98           SUBB    A,R0
   \   000085   40A4         JC      ??ZDSecMgrNwkKeyInit_2
   3344            //Set the last item to the generic nwk security material by setting extPanId to 0xFFs
   3345            osal_memset(nwkSecMaterialDesc.extendedPanID,0xFF,Z_EXTADDR_LEN);
   \   000087                ; Setup parameters for call to function osal_memset
   \   000087   7C08         MOV     R4,#0x8
   \   000089   7D00         MOV     R5,#0x0
   \   00008B   79FF         MOV     R1,#-0x1
   \   00008D   7404         MOV     A,#0x4
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   AA82         MOV     R2,DPL
   \   000094   AB83         MOV     R3,DPH
   \   000096   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3346            
   3347            if((osal_nv_item_init(ZCD_NV_NWK_SEC_MATERIAL_TABLE_START + i - 1,sizeof(nwkSecMaterialDesc_t),&nwkSecMaterialDesc) == SUCCESS) && (nwkFrameCounterReset))
   \   000099   EE           MOV     A,R6
   \   00009A   2474         ADD     A,#0x74
   \   00009C   FE           MOV     R6,A
   \   00009D   5001         JNC     ??ZDSecMgrNwkKeyInit_5
   \   00009F   0F           INC     R7
   \                     ??ZDSecMgrNwkKeyInit_5:
   \   0000A0                ; Setup parameters for call to function osal_nv_item_init
   \   0000A0   A8..         MOV     R0,?XSP + 0
   \   0000A2   A9..         MOV     R1,?XSP + 1
   \   0000A4   88..         MOV     ?V2,R0
   \   0000A6   89..         MOV     ?V3,R1
   \   0000A8   78..         MOV     R0,#?V2
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AD   7C0C         MOV     R4,#0xc
   \   0000AF   7D00         MOV     R5,#0x0
   \   0000B1   EE           MOV     A,R6
   \   0000B2   FA           MOV     R2,A
   \   0000B3   EF           MOV     A,R7
   \   0000B4   FB           MOV     R3,A
   \   0000B5   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   0000B8   7402         MOV     A,#0x2
   \   0000BA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BD   E9           MOV     A,R1
   \   0000BE   7024         JNZ     ??ZDSecMgrNwkKeyInit_6
   \   0000C0   A2..         MOV     C,?VB.0
   \   0000C2   5020         JNC     ??ZDSecMgrNwkKeyInit_6
   3348            {
   3349              osal_nv_write(ZCD_NV_NWK_SEC_MATERIAL_TABLE_START + i - 1,0,sizeof(nwkSecMaterialDesc_t),&nwkSecMaterialDesc);
   \   0000C4                ; Setup parameters for call to function osal_nv_write
   \   0000C4   78..         MOV     R0,#?V2
   \   0000C6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C9   75..0C       MOV     ?V2,#0xc
   \   0000CC   75..00       MOV     ?V3,#0x0
   \   0000CF   78..         MOV     R0,#?V2
   \   0000D1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D4   7C00         MOV     R4,#0x0
   \   0000D6   7D00         MOV     R5,#0x0
   \   0000D8   EE           MOV     A,R6
   \   0000D9   FA           MOV     R2,A
   \   0000DA   EF           MOV     A,R7
   \   0000DB   FB           MOV     R3,A
   \   0000DC   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000DF   7404         MOV     A,#0x4
   \   0000E1   12....       LCALL   ?DEALLOC_XSTACK8
   3350            }
   3351          
   3352          
   3353            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \                     ??ZDSecMgrNwkKeyInit_6:
   \   0000E4                ; Setup parameters for call to function osal_memset
   \   0000E4   7C15         MOV     R4,#0x15
   \   0000E6   7D00         MOV     R5,#0x0
   \   0000E8   7900         MOV     R1,#0x0
   \   0000EA   741D         MOV     A,#0x1d
   \   0000EC   12....       LCALL   ?XSTACK_DISP101_8
   \   0000EF   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3354          
   3355            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   3356          
   3357          #if defined ( NV_RESTORE )
   3358            // reset the values of NV items if NV_RESTORE is not enabled
   3359            if ((status == SUCCESS) && (setDefault == TRUE))
   \   0000F2                ; Setup parameters for call to function osal_nv_item_init
   \   0000F2   741D         MOV     A,#0x1d
   \   0000F4   12....       LCALL   ?XSTACK_DISP100_8
   \   0000F7   88..         MOV     ?V2,R0
   \   0000F9   89..         MOV     ?V3,R1
   \   0000FB   78..         MOV     R0,#?V2
   \   0000FD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000100   7C15         MOV     R4,#0x15
   \   000102   7D00         MOV     R5,#0x0
   \   000104   7A82         MOV     R2,#-0x7e
   \   000106   7B00         MOV     R3,#0x0
   \   000108   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00010B   7402         MOV     A,#0x2
   \   00010D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000110   E9           MOV     A,R1
   \   000111   7026         JNZ     ??ZDSecMgrNwkKeyInit_7
   \   000113   7401         MOV     A,#0x1
   \   000115   65..         XRL     A,?V0
   \   000117   7020         JNZ     ??ZDSecMgrNwkKeyInit_7
   3360            {
   3361              // clear NV data to default values
   3362              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   000119                ; Setup parameters for call to function osal_nv_write
   \   000119   78..         MOV     R0,#?V2
   \   00011B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00011E   75..15       MOV     ?V2,#0x15
   \   000121   75..00       MOV     ?V3,#0x0
   \   000124   78..         MOV     R0,#?V2
   \   000126   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000129   7C00         MOV     R4,#0x0
   \   00012B   7D00         MOV     R5,#0x0
   \   00012D   7A82         MOV     R2,#-0x7e
   \   00012F   7B00         MOV     R3,#0x0
   \   000131   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000134   7404         MOV     A,#0x4
   \   000136   12....       LCALL   ?DEALLOC_XSTACK8
   3363            }
   3364          #else
   3365            (void)setDefault;   // to eliminate compiler warning
   3366          
   3367            // reset the values of NV items if NV_RESTORE is not enabled
   3368            if (status == SUCCESS)
   3369            {
   3370              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   3371            }
   3372          #endif // defined (NV_RESTORE)
   3373          
   3374            // Initialize NV items for NWK Active and Alternate keys. These items are used
   3375            // all the time, independently of NV_RESTORE being set or not
   3376            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_7:
   \   000139                ; Setup parameters for call to function osal_memset
   \   000139   7C11         MOV     R4,#0x11
   \   00013B   7D00         MOV     R5,#0x0
   \   00013D   7900         MOV     R1,#0x0
   \   00013F   740C         MOV     A,#0xc
   \   000141   12....       LCALL   ?XSTACK_DISP101_8
   \   000144   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3377          
   3378            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   3379          
   3380          #if defined ( NV_RESTORE )
   3381            // reset the values of NV items if NV_RESTORE is not enabled
   3382            if ((status == SUCCESS) && (setDefault == TRUE))
   \   000147                ; Setup parameters for call to function osal_nv_item_init
   \   000147   740C         MOV     A,#0xc
   \   000149   12....       LCALL   ?XSTACK_DISP100_8
   \   00014C   88..         MOV     ?V2,R0
   \   00014E   89..         MOV     ?V3,R1
   \   000150   78..         MOV     R0,#?V2
   \   000152   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000155   7C11         MOV     R4,#0x11
   \   000157   7D00         MOV     R5,#0x0
   \   000159   7A3A         MOV     R2,#0x3a
   \   00015B   7B00         MOV     R3,#0x0
   \   00015D   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000160   7402         MOV     A,#0x2
   \   000162   12....       LCALL   ?DEALLOC_XSTACK8
   \   000165   E9           MOV     A,R1
   \   000166   7026         JNZ     ??ZDSecMgrNwkKeyInit_8
   \   000168   7401         MOV     A,#0x1
   \   00016A   65..         XRL     A,?V0
   \   00016C   7020         JNZ     ??ZDSecMgrNwkKeyInit_8
   3383            {
   3384              // clear NV data to default values
   3385              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   00016E                ; Setup parameters for call to function osal_nv_write
   \   00016E   78..         MOV     R0,#?V2
   \   000170   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000173   75..11       MOV     ?V2,#0x11
   \   000176   75..00       MOV     ?V3,#0x0
   \   000179   78..         MOV     R0,#?V2
   \   00017B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017E   7C00         MOV     R4,#0x0
   \   000180   7D00         MOV     R5,#0x0
   \   000182   7A3A         MOV     R2,#0x3a
   \   000184   7B00         MOV     R3,#0x0
   \   000186   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000189   7404         MOV     A,#0x4
   \   00018B   12....       LCALL   ?DEALLOC_XSTACK8
   3386            }
   3387          #else
   3388            // reset the values of NV items if NV_RESTORE is not enabled
   3389            if (status == SUCCESS)
   3390            {
   3391              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   3392            }
   3393          #endif // defined (NV_RESTORE)
   3394          
   3395            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   3396          
   3397          #if defined ( NV_RESTORE )
   3398            // reset the values of NV items if NV_RESTORE is not enabled
   3399            if ((status == SUCCESS) && (setDefault == TRUE))
   \                     ??ZDSecMgrNwkKeyInit_8:
   \   00018E                ; Setup parameters for call to function osal_nv_item_init
   \   00018E   740C         MOV     A,#0xc
   \   000190   12....       LCALL   ?XSTACK_DISP100_8
   \   000193   88..         MOV     ?V2,R0
   \   000195   89..         MOV     ?V3,R1
   \   000197   78..         MOV     R0,#?V2
   \   000199   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00019C   7C11         MOV     R4,#0x11
   \   00019E   7D00         MOV     R5,#0x0
   \   0001A0   7A3B         MOV     R2,#0x3b
   \   0001A2   7B00         MOV     R3,#0x0
   \   0001A4   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   0001A7   7402         MOV     A,#0x2
   \   0001A9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001AC   E9           MOV     A,R1
   \   0001AD   7026         JNZ     ??ZDSecMgrNwkKeyInit_9
   \   0001AF   7401         MOV     A,#0x1
   \   0001B1   65..         XRL     A,?V0
   \   0001B3   7020         JNZ     ??ZDSecMgrNwkKeyInit_9
   3400            {
   3401              // clear NV data to default values
   3402              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0001B5                ; Setup parameters for call to function osal_nv_write
   \   0001B5   78..         MOV     R0,#?V2
   \   0001B7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001BA   75..11       MOV     ?V2,#0x11
   \   0001BD   75..00       MOV     ?V3,#0x0
   \   0001C0   78..         MOV     R0,#?V2
   \   0001C2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001C5   7C00         MOV     R4,#0x0
   \   0001C7   7D00         MOV     R5,#0x0
   \   0001C9   7A3B         MOV     R2,#0x3b
   \   0001CB   7B00         MOV     R3,#0x0
   \   0001CD   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0001D0   7404         MOV     A,#0x4
   \   0001D2   12....       LCALL   ?DEALLOC_XSTACK8
   3403            }
   3404          #else
   3405            // reset the values of NV items if NV_RESTORE is not enabled
   3406            if (status == SUCCESS)
   3407            {
   3408              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   3409            }
   3410          #endif // defined (NV_RESTORE)
   3411          
   3412          }
   \                     ??ZDSecMgrNwkKeyInit_9:
   \   0001D5   7432         MOV     A,#0x32
   \   0001D7   02....       LJMP    ?Subroutine3 & 0xFFFF
   3413          
   3414          
   3415          
   3416          /*********************************************************************
   3417           * @fn          ZDSecMgrReadKeyFromNv
   3418           *
   3419           * @brief       Looks for a specific key in NV based on Index value
   3420           *
   3421           * @param   keyNvId - Index of key to look in NV
   3422           *                    valid values are:
   3423           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO
   3424           *                    ZCD_NV_NWK_ALTERN_KEY_INFO
   3425           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   3426           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   3427           *                    ZCD_NV_PRECFGKEY
   3428           *
   3429           * @param  *keyinfo - Data is read into this buffer.
   3430           *
   3431           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   3432           *          Otherwise, NV_OPER_FAILED for failure.
   3433           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3434          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   3435          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8C..         MOV     ?V0,R4
   \   000007   8D..         MOV     ?V1,R5
   3436            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   3437                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   000009   743A         MOV     A,#0x3a
   \   00000B   6A           XRL     A,R2
   \   00000C   7001         JNZ     ??ZDSecMgrReadKeyFromNv_0
   \   00000E   EB           MOV     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   00000F   6006         JZ      ??ZDSecMgrReadKeyFromNv_1
   \   000011   743B         MOV     A,#0x3b
   \   000013   6A           XRL     A,R2
   \   000014   4B           ORL     A,R3
   \   000015   7014         JNZ     ??ZDSecMgrReadKeyFromNv_2
   3438            {
   3439              // get NWK active or alternate key from NV
   3440              return (osal_nv_read(keyNvId,
   3441                                   osal_offsetof(nwkKeyDesc, key),
   3442                                   SEC_KEY_LEN,
   3443                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000017                ; Setup parameters for call to function osal_nv_read
   \   000017   78..         MOV     R0,#?V0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   75..10       MOV     ?V0,#0x10
   \   00001F   75..00       MOV     ?V1,#0x0
   \   000022   78..         MOV     R0,#?V0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000027   7C01         MOV     R4,#0x1
   \   000029   806E         SJMP    ??ZDSecMgrReadKeyFromNv_3
   3444            }
   3445            
   3446            else if(keyNvId == ZCD_NV_TCLK_DEFAULT)
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   00002B   7403         MOV     A,#0x3
   \   00002D   6A           XRL     A,R2
   \   00002E   7003         JNZ     ??ZDSecMgrReadKeyFromNv_4
   \   000030   7401         MOV     A,#0x1
   \   000032   6B           XRL     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   000033   7022         JNZ     ??ZDSecMgrReadKeyFromNv_5
   3447            {
   3448              osal_memcpy(keyinfo,defaultTCLinkKey,SEC_KEY_LEN);
   \   000035                ; Setup parameters for call to function osal_memcpy
   \   000035   75....       MOV     ?V4,#defaultTCLinkKey & 0xff
   \   000038   75....       MOV     ?V5,#(defaultTCLinkKey >> 8) & 0xff
   \   00003B   75..80       MOV     ?V6,#-0x80
   \   00003E   78..         MOV     R0,#?V4
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000043   7C10         MOV     R4,#0x10
   \   000045   7D00         MOV     R5,#0x0
   \   000047   AA..         MOV     R2,?V0
   \   000049   AB..         MOV     R3,?V1
   \   00004B   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00004E   7403         MOV     A,#0x3
   \   000050   12....       LCALL   ?DEALLOC_XSTACK8
   3449              return ZSuccess;
   \   000053   7900         MOV     R1,#0x0
   \   000055   8050         SJMP    ??ZDSecMgrReadKeyFromNv_6
   3450            }
   3451            
   3452          #if (ZG_BUILD_JOINING_TYPE) 
   3453            else if(keyNvId == ZCD_NV_DISTRIBUTED_KEY)
   3454            {
   3455              if(ZG_DEVICE_JOINING_TYPE)
   3456              {
   3457                osal_memcpy(keyinfo,distributedDefaultKey,SEC_KEY_LEN);
   3458                return ZSuccess;
   3459              }
   3460            }
   3461          #endif
   3462            
   3463            else if((keyNvId == ZCD_NV_TCLK_JOIN_DEV) || (keyNvId == ZCD_NV_PRECFGKEY)) 
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   000057   7402         MOV     A,#0x2
   \   000059   6A           XRL     A,R2
   \   00005A   7003         JNZ     ??ZDSecMgrReadKeyFromNv_7
   \   00005C   7401         MOV     A,#0x1
   \   00005E   6B           XRL     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   00005F   6026         JZ      ??ZDSecMgrReadKeyFromNv_8
   \   000061   7462         MOV     A,#0x62
   \   000063   6A           XRL     A,R2
   \   000064   4B           ORL     A,R3
   \   000065   6020         JZ      ??ZDSecMgrReadKeyFromNv_8
   3464            {
   3465              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   3466              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   3467              return (osal_nv_read(keyNvId,
   3468                                   0,
   3469                                   SEC_KEY_LEN,
   3470                                   keyinfo));
   \   000067                ; Setup parameters for call to function osal_nv_read
   3471            }
   3472              else if (keyNvId == ZCD_NV_PRECFGKEY)
   3473            {
   3474              // Read entry keyNvId of the Preconfig key from NV.
   3475              return (osal_nv_read(keyNvId,
   3476                                   0,
   3477                                   SEC_KEY_LEN,
   3478                                   keyinfo));
   3479            }
   3480          
   3481            else if((keyNvId >= ZCD_NV_TCLK_IC_TABLE_START) &&
   3482                     (keyNvId < (ZCD_NV_TCLK_IC_TABLE_START + gZDSECMGR_TC_DEVICE_IC_MAX)))
   \   000067   EA           MOV     A,R2
   \   000068   24FC         ADD     A,#-0x4
   \   00006A   F8           MOV     R0,A
   \   00006B   EB           MOV     A,R3
   \   00006C   34FE         ADDC    A,#-0x2
   \   00006E   F9           MOV     R1,A
   \   00006F   C3           CLR     C
   \   000070   E8           MOV     A,R0
   \   000071   940C         SUBB    A,#0xc
   \   000073   E9           MOV     A,R1
   \   000074   9400         SUBB    A,#0x0
   \   000076   400F         JC      ??ZDSecMgrReadKeyFromNv_8
   3483            {
   3484              //Read the key derived from the IC
   3485              return (osal_nv_read(keyNvId,
   3486                                   0,
   3487                                   SEC_KEY_LEN,
   3488                                   keyinfo));
   \   000078                ; Setup parameters for call to function osal_nv_read
   3489            
   3490            }
   3491            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   3492                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \   000078   EA           MOV     A,R2
   \   000079   24FF         ADD     A,#-0x1
   \   00007B   F8           MOV     R0,A
   \   00007C   EB           MOV     A,R3
   \   00007D   34FD         ADDC    A,#-0x3
   \   00007F   F9           MOV     R1,A
   \   000080   C3           CLR     C
   \   000081   E8           MOV     A,R0
   \   000082   12....       LCALL   ??Subroutine57_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000085   501E         JNC     ??ZDSecMgrReadKeyFromNv_9
   3493            {
   3494              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   3495              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   3496              return (osal_nv_read(keyNvId,
   3497                                   osal_offsetof(APSME_LinkKeyData_t, key),
   3498                                   SEC_KEY_LEN,
   3499                                   keyinfo));
   \   000087                ; Setup parameters for call to function osal_nv_read
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   000087   78..         MOV     R0,#?V0
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008C   75..10       MOV     ?V0,#0x10
   \   00008F   75..00       MOV     ?V1,#0x0
   \   000092   78..         MOV     R0,#?V0
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000097   7C00         MOV     R4,#0x0
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   000099   7D00         MOV     R5,#0x0
   \   00009B   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00009E   7404         MOV     A,#0x4
   \   0000A0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A3   8002         SJMP    ??ZDSecMgrReadKeyFromNv_6
   3500            }
   3501          
   3502            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_9:
   \   0000A5   790A         MOV     R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   0000A7   02....       LJMP    ??Subroutine75_0 & 0xFFFF
   3503          }
   3504          
   3505          /******************************************************************************
   3506           * @fn          ZDSecMgrApsLinkKeyInit
   3507           *
   3508           * @brief       Initialize the NV table for Application link keys
   3509           *
   3510           * @param       setDefault - TRUE to set default values
   3511           *
   3512           * @return      none
   3513           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3514          void ZDSecMgrApsLinkKeyInit(uint8 setDefault)
   \                     ZDSecMgrApsLinkKeyInit:
   3515          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V1,R1
   3516            APSME_LinkKeyData_t pApsLinkKey;
   3517            uint8 i;
   3518            uint8 status;
   3519          
   3520            // Initialize all NV items for APS link key, if not exist already.
   3521            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000C                ; Setup parameters for call to function osal_memset
   \   00000C   7C18         MOV     R4,#0x18
   \   00000E   7D00         MOV     R5,#0x0
   \   000010   7900         MOV     R1,#0x0
   \   000012   AA..         MOV     R2,?XSP + 0
   \   000014   AB..         MOV     R3,?XSP + 1
   \   000016   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3522          
   3523            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000019   75..00       MOV     ?V0,#0x0
   3524            {
   3525              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i),
   3526                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   3527          
   3528          #if defined ( NV_RESTORE )
   3529            // If the set default is requested, the APS Link key needs to be erased, regardless of the NV_RESTORE enabled
   3530                if ((status == SUCCESS) && (setDefault == TRUE ))
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   00001C   E5..         MOV     A,?V0
   \   00001E   2401         ADD     A,#0x1
   \   000020   FE           MOV     R6,A
   \   000021   E4           CLR     A
   \   000022   3402         ADDC    A,#0x2
   \   000024   FF           MOV     R7,A
   \   000025                ; Setup parameters for call to function osal_nv_item_init
   \   000025   A8..         MOV     R0,?XSP + 0
   \   000027   A9..         MOV     R1,?XSP + 1
   \   000029   88..         MOV     ?V2,R0
   \   00002B   89..         MOV     ?V3,R1
   \   00002D   78..         MOV     R0,#?V2
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   7C18         MOV     R4,#0x18
   \   000034   7D00         MOV     R5,#0x0
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   EF           MOV     A,R7
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000042   E9           MOV     A,R1
   \   000043   7026         JNZ     ??ZDSecMgrApsLinkKeyInit_1
   \   000045   7401         MOV     A,#0x1
   \   000047   65..         XRL     A,?V1
   \   000049   7020         JNZ     ??ZDSecMgrApsLinkKeyInit_1
   3531                {
   3532                  osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3533                                sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   00004B                ; Setup parameters for call to function osal_nv_write
   \   00004B   78..         MOV     R0,#?V2
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   75..18       MOV     ?V2,#0x18
   \   000053   75..00       MOV     ?V3,#0x0
   \   000056   78..         MOV     R0,#?V2
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   7C00         MOV     R4,#0x0
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   EE           MOV     A,R6
   \   000060   FA           MOV     R2,A
   \   000061   EF           MOV     A,R7
   \   000062   FB           MOV     R3,A
   \   000063   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000066   7404         MOV     A,#0x4
   \   000068   12....       LCALL   ?DEALLOC_XSTACK8
   3534          
   3535                }
   3536          #else
   3537              // reset the values of NV items if NV_RESTORE is not enabled
   3538              if (status == SUCCESS)
   3539              {
   3540                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3541                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   3542          
   3543              }
   3544          #endif // defined (NV_RESTORE)
   3545            }
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   00006B   05..         INC     ?V0
   \   00006D   EE           MOV     A,R6
   \   00006E   C3           CLR     C
   \   00006F   9403         SUBB    A,#0x3
   \   000071   40A9         JC      ??ZDSecMgrApsLinkKeyInit_0
   3546          }
   \   000073   7418         MOV     A,#0x18
   \   000075   02....       LJMP    ?Subroutine3 & 0xFFFF
   3547          
   3548          
   3549          /******************************************************************************
   3550           * @fn          ZDSecMgrInitNVKeyTables
   3551           *
   3552           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   3553           *
   3554           * @param       setDefault - TRUE to set default values
   3555           *
   3556           * @return      none
   3557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3558          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   3559          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   3560            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   12....       LCALL   `??ZDSecMgrNwkKeyInit::?relay`; Banked call to: ZDSecMgrNwkKeyInit
   3561            ZDSecMgrApsLinkKeyInit(setDefault); 
   \   00000A                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000A   EE           MOV     A,R6
   \   00000B   F9           MOV     R1,A
   \   00000C   12....       LCALL   `??ZDSecMgrApsLinkKeyInit::?relay`; Banked call to: ZDSecMgrApsLinkKeyInit
   3562            APSME_TCLinkKeyInit(setDefault);
   \   00000F                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   00000F   EE           MOV     A,R6
   \   000010   F9           MOV     R1,A
   \   000011   12....       LCALL   `??APSME_TCLinkKeyInit::?relay`; Banked call to: APSME_TCLinkKeyInit
   3563            
   3564          #if ZG_BUILD_COORDINATOR_TYPE
   3565            if(ZG_DEVICE_COORDINATOR_TYPE)
   3566            {
   3567              ZDSecMgrGenerateSeed(setDefault);
   \   000014                ; Setup parameters for call to function ZDSecMgrGenerateSeed
   \   000014   EE           MOV     A,R6
   \   000015   F9           MOV     R1,A
   \   000016   12....       LCALL   `??ZDSecMgrGenerateSeed::?relay`; Banked call to: ZDSecMgrGenerateSeed
   3568              
   3569            }
   3570          #endif
   3571          }
   \   000019   02....       LJMP    ??Subroutine66_0 & 0xFFFF
   3572          
   3573          
   3574          /******************************************************************************
   3575           * @fn          ZDSecMgrSaveApsLinkKey
   3576           *
   3577           * @brief       Save APS Link Key to NV. It will loop through all the keys
   3578           *              to see which one to save.
   3579           *
   3580           * @param       none
   3581           *
   3582           * @return      none
   3583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3584          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   3585          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   3586            APSME_LinkKeyData_t *pKeyData = NULL;
   3587            int i;
   3588          
   3589            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A18         MOV     R2,#0x18
   \   000007   7B00         MOV     R3,#0x0
   \   000009   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000C   8A..         MOV     ?V6,R2
   \   00000E   8B..         MOV     ?V7,R3
   3590          
   3591            if (pKeyData != NULL)
   \   000010   EA           MOV     A,R2
   \   000011   45..         ORL     A,?V7
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_0 & 0xFFFF
   3592            {
   3593              // checks all pending flags to know which one to save
   3594              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   000018   75..00       MOV     ?V0,#0x0
   \   00001B   75..00       MOV     ?V1,#0x0
   3595              {
   3596                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   00001E   E5..         MOV     A,?V0
   \   000020   75F009       MOV     B,#0x9
   \   000023   A4           MUL     AB
   \   000024   F8           MOV     R0,A
   \   000025   AAF0         MOV     R2,B
   \   000027   75F009       MOV     B,#0x9
   \   00002A   E5..         MOV     A,?V1
   \   00002C   A4           MUL     AB
   \   00002D   2A           ADD     A,R2
   \   00002E   F9           MOV     R1,A
   \   00002F   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   000031   28           ADD     A,R0
   \   000032   F5..         MOV     ?V2,A
   \   000034   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   000036   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000039   6003         JZ      $+5
   \   00003B   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_2 & 0xFFFF
   \   00003E   E5..         MOV     A,?V0
   \   000040   2401         ADD     A,#0x1
   \   000042   FE           MOV     R6,A
   \   000043   E5..         MOV     A,?V1
   \   000045   3402         ADDC    A,#0x2
   \   000047   FF           MOV     R7,A
   \   000048                ; Setup parameters for call to function osal_nv_read
   \   000048   78..         MOV     R0,#?V6
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004D   75..18       MOV     ?V8,#0x18
   \   000050   75..00       MOV     ?V9,#0x0
   \   000053   78..         MOV     R0,#?V8
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   7C00         MOV     R4,#0x0
   \   00005A   7D00         MOV     R5,#0x0
   \   00005C   EE           MOV     A,R6
   \   00005D   FA           MOV     R2,A
   \   00005E   EF           MOV     A,R7
   \   00005F   FB           MOV     R3,A
   3597                {
   3598                  // retrieve key from NV
   3599                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   3600                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   000060   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000063   7404         MOV     A,#0x4
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   E9           MOV     A,R1
   \   000069   705A         JNZ     ??ZDSecMgrSaveApsLinkKey_2
   3601                  {
   3602                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   00006B   85..82       MOV     DPL,?V2
   \   00006E   85..83       MOV     DPH,?V3
   \   000071   12....       LCALL   ?XLOAD_R0123
   \   000074   E5..         MOV     A,?V6
   \   000076   2410         ADD     A,#0x10
   \   000078   F582         MOV     DPL,A
   \   00007A   E4           CLR     A
   \   00007B   35..         ADDC    A,?V7
   \   00007D   F583         MOV     DPH,A
   \   00007F   12....       LCALL   ?XSTORE_R0123
   3603                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   000082   85..82       MOV     DPL,?V2
   \   000085   85..83       MOV     DPH,?V3
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   12....       LCALL   ?XLOAD_R0123
   \   00008F   E5..         MOV     A,?V6
   \   000091   2414         ADD     A,#0x14
   \   000093   F582         MOV     DPL,A
   \   000095   E4           CLR     A
   \   000096   35..         ADDC    A,?V7
   \   000098   F583         MOV     DPH,A
   \   00009A   12....       LCALL   ?XSTORE_R0123
   3604          
   3605                    // Write the APS link key back to the NV
   3606                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   3607                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   00009D                ; Setup parameters for call to function osal_nv_write
   \   00009D   78..         MOV     R0,#?V6
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A2   75..18       MOV     ?V2,#0x18
   \   0000A5   75..00       MOV     ?V3,#0x0
   \   0000A8   78..         MOV     R0,#?V2
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AD   7C00         MOV     R4,#0x0
   \   0000AF   7D00         MOV     R5,#0x0
   \   0000B1   EE           MOV     A,R6
   \   0000B2   FA           MOV     R2,A
   \   0000B3   EF           MOV     A,R7
   \   0000B4   FB           MOV     R3,A
   \   0000B5   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000B8   7404         MOV     A,#0x4
   \   0000BA   12....       LCALL   ?DEALLOC_XSTACK8
   3608          
   3609                    // clear the pending write flag
   3610                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   0000BD   85..82       MOV     DPL,?V4
   \   0000C0   85..83       MOV     DPH,?V5
   \   0000C3   E4           CLR     A
   \   0000C4   F0           MOVX    @DPTR,A
   3611                  }
   3612                }
   3613              }
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   0000C5   05..         INC     ?V0
   \   0000C7   E5..         MOV     A,?V0
   \   0000C9   7002         JNZ     ??ZDSecMgrSaveApsLinkKey_3
   \   0000CB   05..         INC     ?V1
   \                     ??ZDSecMgrSaveApsLinkKey_3:
   \   0000CD   C3           CLR     C
   \   0000CE   9403         SUBB    A,#0x3
   \   0000D0   E5..         MOV     A,?V1
   \   0000D2   9400         SUBB    A,#0x0
   \   0000D4   A2D2         MOV     C,0xD0 /* PSW */.2
   \   0000D6   65D0         XRL     A,PSW
   \   0000D8   33           RLC     A
   \   0000D9   5003         JNC     $+5
   \   0000DB   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_1 & 0xFFFF
   3614          
   3615              // clear copy of key in RAM
   3616              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000DE                ; Setup parameters for call to function osal_memset
   \   0000DE   7C18         MOV     R4,#0x18
   \   0000E0   7D00         MOV     R5,#0x0
   \   0000E2   7900         MOV     R1,#0x0
   \   0000E4   AA..         MOV     R2,?V6
   \   0000E6   AB..         MOV     R3,?V7
   \   0000E8   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3617          
   3618              osal_mem_free(pKeyData);
   \   0000EB                ; Setup parameters for call to function osal_mem_free
   \   0000EB   AA..         MOV     R2,?V6
   \   0000ED   AB..         MOV     R3,?V7
   \   0000EF   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   3619            }
   3620          }
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   0000F2   02....       LJMP    ??Subroutine78_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   39           ADDC    A,R1
   \   000001   F5..         MOV     ?V3,A
   \   000003   E5..         MOV     A,?V2
   \   000005   2408         ADD     A,#0x8
   \   000007   F5..         MOV     ?V4,A
   \   000009   E4           CLR     A
   \   00000A   35..         ADDC    A,?V3
   \   00000C   F5..         MOV     ?V5,A
   \   00000E   85..82       MOV     DPL,?V4
   \   000011   F583         MOV     DPH,A
   \   000013   E0           MOVX    A,@DPTR
   \   000014   6401         XRL     A,#0x1
   \   000016   22           RET
   3621          
   3622          /******************************************************************************
   3623           * @fn          ZDSecMgrSaveTCLinkKey
   3624           *
   3625           * @brief       Save TC Link Key to NV. It will loop through all the keys
   3626           *              to see which one to save.
   3627           *
   3628           * @param       none
   3629           *
   3630           * @return      none
   3631           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3632          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   3633          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   3634            APSME_TCLKDevEntry_t *pKeyData = NULL;
   3635            uint16 i;
   3636          
   3637            pKeyData = (APSME_TCLKDevEntry_t *)osal_mem_alloc(sizeof(APSME_TCLKDevEntry_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A13         MOV     R2,#0x13
   \   000007   7B00         MOV     R3,#0x0
   \   000009   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000C   8A..         MOV     ?V6,R2
   \   00000E   8B..         MOV     ?V7,R3
   3638          
   3639            if (pKeyData != NULL)
   \   000010   EA           MOV     A,R2
   \   000011   45..         ORL     A,?V7
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_0 & 0xFFFF
   3640            {
   3641              for( i = 0; i < gZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000018   75..00       MOV     ?V0,#0x0
   \   00001B   75..00       MOV     ?V1,#0x0
   3642              {
   3643                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   00001E   E5..         MOV     A,?V0
   \   000020   75F009       MOV     B,#0x9
   \   000023   A4           MUL     AB
   \   000024   F8           MOV     R0,A
   \   000025   AAF0         MOV     R2,B
   \   000027   75F009       MOV     B,#0x9
   \   00002A   E5..         MOV     A,?V1
   \   00002C   A4           MUL     AB
   \   00002D   2A           ADD     A,R2
   \   00002E   F9           MOV     R1,A
   \   00002F   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   000031   28           ADD     A,R0
   \   000032   F5..         MOV     ?V2,A
   \   000034   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000036   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000039   6003         JZ      $+5
   \   00003B   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_2 & 0xFFFF
   3644                {
   3645                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0,
   3646                                   sizeof(APSME_TCLKDevEntry_t), pKeyData) == SUCCESS)
   \   00003E   E5..         MOV     A,?V0
   \   000040   2411         ADD     A,#0x11
   \   000042   FE           MOV     R6,A
   \   000043   E5..         MOV     A,?V1
   \   000045   3401         ADDC    A,#0x1
   \   000047   FF           MOV     R7,A
   \   000048                ; Setup parameters for call to function osal_nv_read
   \   000048   78..         MOV     R0,#?V6
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004D   75..13       MOV     ?V8,#0x13
   \   000050   75..00       MOV     ?V9,#0x0
   \   000053   78..         MOV     R0,#?V8
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   7C00         MOV     R4,#0x0
   \   00005A   7D00         MOV     R5,#0x0
   \   00005C   EE           MOV     A,R6
   \   00005D   FA           MOV     R2,A
   \   00005E   EF           MOV     A,R7
   \   00005F   FB           MOV     R3,A
   \   000060   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000063   7404         MOV     A,#0x4
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   E9           MOV     A,R1
   \   000069   7054         JNZ     ??ZDSecMgrSaveTCLinkKey_2
   3647                  {
   3648                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   00006B   85..82       MOV     DPL,?V2
   \   00006E   85..83       MOV     DPH,?V3
   \   000071   12....       LCALL   ?XLOAD_R0123
   \   000074   85..82       MOV     DPL,?V6
   \   000077   85..83       MOV     DPH,?V7
   \   00007A   12....       LCALL   ?XSTORE_R0123
   3649                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   00007D   85..82       MOV     DPL,?V2
   \   000080   85..83       MOV     DPH,?V3
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   12....       LCALL   ?XLOAD_R0123
   \   00008A   85..82       MOV     DPL,?V6
   \   00008D   85..83       MOV     DPH,?V7
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   12....       LCALL   ?XSTORE_R0123
   3650          
   3651                    // Write the TC link key back to the NV
   3652                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0,
   3653                                  sizeof(APSME_TCLKDevEntry_t), pKeyData);
   \   000097                ; Setup parameters for call to function osal_nv_write
   \   000097   78..         MOV     R0,#?V6
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   75..13       MOV     ?V2,#0x13
   \   00009F   75..00       MOV     ?V3,#0x0
   \   0000A2   78..         MOV     R0,#?V2
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A7   7C00         MOV     R4,#0x0
   \   0000A9   7D00         MOV     R5,#0x0
   \   0000AB   EE           MOV     A,R6
   \   0000AC   FA           MOV     R2,A
   \   0000AD   EF           MOV     A,R7
   \   0000AE   FB           MOV     R3,A
   \   0000AF   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000B2   7404         MOV     A,#0x4
   \   0000B4   12....       LCALL   ?DEALLOC_XSTACK8
   3654          
   3655                    // clear the pending write flag
   3656                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   0000B7   85..82       MOV     DPL,?V4
   \   0000BA   85..83       MOV     DPH,?V5
   \   0000BD   E4           CLR     A
   \   0000BE   F0           MOVX    @DPTR,A
   3657                  }
   3658                }
   3659              }
   \                     ??ZDSecMgrSaveTCLinkKey_2:
   \   0000BF   05..         INC     ?V0
   \   0000C1   E5..         MOV     A,?V0
   \   0000C3   7002         JNZ     ??ZDSecMgrSaveTCLinkKey_3
   \   0000C5   05..         INC     ?V1
   \                     ??ZDSecMgrSaveTCLinkKey_3:
   \   0000C7   C3           CLR     C
   \   0000C8   9428         SUBB    A,#0x28
   \   0000CA   E5..         MOV     A,?V1
   \   0000CC   9400         SUBB    A,#0x0
   \   0000CE   5003         JNC     $+5
   \   0000D0   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_1 & 0xFFFF
   3660          
   3661              osal_mem_free(pKeyData);
   \   0000D3                ; Setup parameters for call to function osal_mem_free
   \   0000D3   AA..         MOV     R2,?V6
   \   0000D5   AB..         MOV     R3,?V7
   \   0000D7   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   3662            }
   3663          }
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   0000DA   02....       LJMP    ??Subroutine78_0 & 0xFFFF
   3664          
   3665          /******************************************************************************
   3666           * @fn          ZDSecMgrUpdateTCAddress
   3667           *
   3668           * @brief       Update Trust Center address and save to NV.
   3669           *
   3670           * @param       extAddr - [in] extended address or NULL if no TC protected
   3671           *
   3672           * @return      none
   3673           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3674          void ZDSecMgrUpdateTCAddress( uint8 *extAddr )
   \                     ZDSecMgrUpdateTCAddress:
   3675          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3676            uint8 noTCAddress[Z_EXTADDR_LEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
   \   00000A   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
   \   00000D   AC..         MOV     R4,?XSP + 0
   \   00000F   AD..         MOV     R5,?XSP + 1
   \   000011   7408         MOV     A,#0x8
   \   000013   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3677            APSME_SetRequest( apsTrustCenterAddress, 0, ( extAddr != NULL) ? extAddr : noTCAddress );
   \   000016   EA           MOV     A,R2
   \   000017   4B           ORL     A,R3
   \   000018   6006         JZ      ??ZDSecMgrUpdateTCAddress_0
   \   00001A   EA           MOV     A,R2
   \   00001B   FE           MOV     R6,A
   \   00001C   EB           MOV     A,R3
   \   00001D   FF           MOV     R7,A
   \   00001E   800C         SJMP    ??ZDSecMgrUpdateTCAddress_1
   \                     ??ZDSecMgrUpdateTCAddress_0:
   \   000020   A8..         MOV     R0,?XSP + 0
   \   000022   A9..         MOV     R1,?XSP + 1
   \   000024   88..         MOV     ?V0,R0
   \   000026   89..         MOV     ?V1,R1
   \   000028   AE..         MOV     R6,?V0
   \   00002A   AF..         MOV     R7,?V1
   \                     ??ZDSecMgrUpdateTCAddress_1:
   \   00002C                ; Setup parameters for call to function APSME_SetRequest
   \   00002C   EE           MOV     A,R6
   \   00002D   FC           MOV     R4,A
   \   00002E   EF           MOV     A,R7
   \   00002F   FD           MOV     R5,A
   \   000030   7A00         MOV     R2,#0x0
   \   000032   7B00         MOV     R3,#0x0
   \   000034   79AB         MOV     R1,#-0x55
   \   000036   12....       LCALL   `??APSME_SetRequest::?relay`; Banked call to: APSME_SetRequest
   3678            osal_cpyExtAddr( zgApsTrustCenterAddr, ( extAddr != NULL) ? extAddr : noTCAddress );
   \   000039   EE           MOV     A,R6
   \   00003A   FC           MOV     R4,A
   \   00003B   EF           MOV     A,R7
   \   00003C   FD           MOV     R5,A
   \   00003D                ; Setup parameters for call to function sAddrExtCpy
   \   00003D   7A..         MOV     R2,#zgApsTrustCenterAddr & 0xff
   \   00003F   7B..         MOV     R3,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   000041   12....       LCALL   `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
   3679            
   3680          #if defined ( NV_RESTORE )
   3681            osal_nv_write( ZCD_NV_TRUSTCENTER_ADDR, 0, Z_EXTADDR_LEN, zgApsTrustCenterAddr );
   \   000044                ; Setup parameters for call to function osal_nv_write
   \   000044   75....       MOV     ?V0,#zgApsTrustCenterAddr & 0xff
   \   000047   75....       MOV     ?V1,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   00004A   78..         MOV     R0,#?V0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   75..08       MOV     ?V0,#0x8
   \   000052   75..00       MOV     ?V1,#0x0
   \   000055   78..         MOV     R0,#?V0
   \   000057   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005A   7C00         MOV     R4,#0x0
   \   00005C   7D00         MOV     R5,#0x0
   \   00005E   7A71         MOV     R2,#0x71
   \   000060   7B00         MOV     R3,#0x0
   \   000062   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000065   7404         MOV     A,#0x4
   \   000067   12....       LCALL   ?DEALLOC_XSTACK8
   3682          #endif
   3683          }
   \   00006A   7408         MOV     A,#0x8
   \   00006C   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   3684          
   3685          #if defined ( ZBA_FALLBACK_NWKKEY )
   3686          /******************************************************************************
   3687           * @fn          ZDSecMgrFallbackNwkKey
   3688           *
   3689           * @brief       Use the ZBA fallback network key.
   3690           *
   3691           * @param       none
   3692           *
   3693           * @return      none
   3694           */
   3695          void ZDSecMgrFallbackNwkKey( void )
   3696          {
   3697            if ( !_NIB.nwkKeyLoaded )
   3698            {
   3699              uint8 fallbackKey[SEC_KEY_LEN];
   3700          
   3701              ZDSecMgrReadKeyFromNv( ZCD_NV_PRECFGKEY, fallbackKey );
   3702              SSP_UpdateNwkKey( fallbackKey, 0);
   3703              SSP_SwitchNwkKey( 0 );
   3704          
   3705              // clear local copy of key
   3706              osal_memset( fallbackKey, 0x00, SEC_KEY_LEN );
   3707          
   3708              // handle next step in authentication process
   3709              ZDSecMgrAuthNwkKey();
   3710            }
   3711          }
   3712          #endif // defined ( ZBA_FALLBACK_NWKKEY )
   3713          
   3714          #if defined ( NV_RESTORE )
   3715          /******************************************************************************
   3716           * @fn          ZDSecMgrClearNVKeyValues
   3717           *
   3718           * @brief       If NV_RESTORE is enabled and the status of the network needs
   3719           *              default values this fuction clears ZCD_NV_NWKKEY,
   3720           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link
   3721           *
   3722           * @param       none
   3723           *
   3724           * @return      none
   3725           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3726          void ZDSecMgrClearNVKeyValues(void)
   \                     ZDSecMgrClearNVKeyValues:
   3727          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3728            nwkActiveKeyItems keyItems;
   3729            nwkKeyDesc nwkKey;
   3730          
   3731            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C15         MOV     R4,#0x15
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   7411         MOV     A,#0x11
   \   000012   12....       LCALL   ?XSTACK_DISP101_8
   \   000015   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3732          
   3733            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   \   000018                ; Setup parameters for call to function osal_nv_write
   \   000018   7411         MOV     A,#0x11
   \   00001A   12....       LCALL   ?XSTACK_DISP100_8
   \   00001D   88..         MOV     ?V0,R0
   \   00001F   89..         MOV     ?V1,R1
   \   000021   78..         MOV     R0,#?V0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   75..15       MOV     ?V0,#0x15
   \   000029   75..00       MOV     ?V1,#0x0
   \   00002C   78..         MOV     R0,#?V0
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7C00         MOV     R4,#0x0
   \   000033   7D00         MOV     R5,#0x0
   \   000035   7A82         MOV     R2,#-0x7e
   \   000037   7B00         MOV     R3,#0x0
   \   000039   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?DEALLOC_XSTACK8
   3734          
   3735            // Initialize NV items for NWK Active and Alternate keys.
   3736            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   \   000041                ; Setup parameters for call to function osal_memset
   \   000041   7C11         MOV     R4,#0x11
   \   000043   7D00         MOV     R5,#0x0
   \   000045   7900         MOV     R1,#0x0
   \   000047   AA..         MOV     R2,?XSP + 0
   \   000049   AB..         MOV     R3,?XSP + 1
   \   00004B   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3737          
   3738            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   \   00004E                ; Setup parameters for call to function osal_nv_write
   \   00004E   A8..         MOV     R0,?XSP + 0
   \   000050   A9..         MOV     R1,?XSP + 1
   \   000052   88..         MOV     ?V0,R0
   \   000054   89..         MOV     ?V1,R1
   \   000056   78..         MOV     R0,#?V0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   75..11       MOV     ?V0,#0x11
   \   00005E   75..00       MOV     ?V1,#0x0
   \   000061   78..         MOV     R0,#?V0
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C00         MOV     R4,#0x0
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   7A3A         MOV     R2,#0x3a
   \   00006C   7B00         MOV     R3,#0x0
   \   00006E   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000071   7404         MOV     A,#0x4
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   3739          
   3740            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   \   000076                ; Setup parameters for call to function osal_nv_write
   \   000076   A8..         MOV     R0,?XSP + 0
   \   000078   A9..         MOV     R1,?XSP + 1
   \   00007A   88..         MOV     ?V0,R0
   \   00007C   89..         MOV     ?V1,R1
   \   00007E   78..         MOV     R0,#?V0
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000083   75..11       MOV     ?V0,#0x11
   \   000086   75..00       MOV     ?V1,#0x0
   \   000089   78..         MOV     R0,#?V0
   \   00008B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008E   7C00         MOV     R4,#0x0
   \   000090   7D00         MOV     R5,#0x0
   \   000092   7A3B         MOV     R2,#0x3b
   \   000094   7B00         MOV     R3,#0x0
   \   000096   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000099   7404         MOV     A,#0x4
   \   00009B   12....       LCALL   ?DEALLOC_XSTACK8
   3741          }
   \   00009E   7426         MOV     A,#0x26
   \   0000A0   02....       LJMP    ??Subroutine71_0 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for requestNewTrustCenterLinkKey`:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for requestLinkKeyTimeout>`:
   \   000000   88130000     DD 5000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrClear::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrClear

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMI::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExtGetIndex::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExtGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMIGetIndex::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMIGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryFree::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTclkReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTclkReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppConfKeyReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppConfKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemoveByExtAddr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateRM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinDirect::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinFwd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAssocDeviceAuth::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrConfig::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoining::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoiningTimeout::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNewDeviceEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCExtAddrCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCDataLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTransportKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRemoveDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrVerifyKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrVerifyKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrGenerateSeed::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrGenerateSeed

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrGenerateKeyFromSeed::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrGenerateKeyFromSeed

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrGenerateRndKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrGenerateRndKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestAppKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyTypeSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyTypeSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeySet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeyNVIdGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyNVIdGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsLinkKeyValid::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsLinkKeyValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_KeyFwdToChild::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInitNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrWriteNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrWriteNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRestoreFromNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRestoreFromNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetDefaultNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAPSRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeySync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsDefaultTCLK::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNwkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNwkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrReadKeyFromNv::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrReadKeyFromNv

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrApsLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrApsLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInitNVKeyTables::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNVKeyTables

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveApsLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveApsLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveTCLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveTCLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateTCAddress::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateTCAddress

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrClearNVKeyValues::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrClearNVKeyValues

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255, 255, 255, 255,`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e9:
   \   000000   E9030000     DD 1001

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_b:
   \   000000   0B000000     DD 11

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_a:
   \   000000   0A000000     DD 10
   3742          #endif // defined ( NV_RESTORE )
   3743          
   3744          /******************************************************************************
   3745          ******************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   APSME_IsDefaultTCLK
        2      0   -> osal_isbufset
      0     37   APSME_IsLinkKeyValid
        0     33   -> APSME_LinkKeyNVIdGet
        0     33   -> osal_mem_alloc
        0     33   -> osal_mem_free
        0     36   -> osal_memcmp
        0     33   -> osal_memset
        0     37   -> osal_nv_read
      0     10   APSME_KeyFwdToChild
        0     10   -> AssocGetWithExt
        0     10   -> ZDSecMgrAssocDeviceAuth
      0     44   APSME_LinkKeyNVIdGet
        0     11   -> ZDSecMgrEntryLookupExt
      0     75   APSME_LinkKeySet
        0     21   -> ZDSecMgrEntryLookupExtGetIndex
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     22   -> osal_memcpy
        0     19   -> osal_memset
        0     23   -> osal_nv_read
        0     23   -> osal_nv_write
      0     50   APSME_TCLinkKeyInit
        0     37   -> APSME_EraseICEntry
        0     37   -> osal_memset
        0     39   -> osal_nv_item_init
        0     41   -> osal_nv_read
        0     41   -> osal_nv_write
      1     55   APSME_TCLinkKeyLoad
        0     53   -> APSME_SearchTCLinkKeyEntry
        0     51   -> AddrMgrEntryLookupNwk
        0     51   -> AddrMgrEntryRelease
        0     51   -> AddrMgrExtAddrValid
        0     54   -> osal_memcpy
        0     51   -> osal_memset
        0     55   -> osal_nv_write
        0     51   -> osal_rand
        0     51   -> osal_set_event
      1     41   APSME_TCLinkKeySync
        0     38   -> APSME_LookupExtAddr
        0     40   -> APSME_SearchTCLinkKeyEntry
        0     38   -> AddrMgrExtAddrValid
        0     41   -> osal_memcpy
      2     10   ZDSecMgrAPSRemove
        2      8   -> ZDSecMgrDeviceRemove
      0     18   ZDSecMgrAddLinkKey
        0     14   -> APSME_LinkKeySet
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrAuthenticationSet
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
        0     14   -> ZDSecMgrWriteNV
      0     57   ZDSecMgrAddrClear
        0     24   -> AddrMgrEntryRelease
        0     24   -> ZDSecMgrExtAddrLookup
      0     76   ZDSecMgrAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      3      6   ZDSecMgrAppConfKeyReq
        2      6   -> APSME_ConfirmKeyReq
      3     59   ZDSecMgrAppKeyGet
        2      0   -> SSP_GetTrueRand
      0     59   ZDSecMgrAppKeyReq
        0     51   -> APSME_LookupExtAddr
        0     51   -> APSME_LookupNwkAddr
        0     51   -> APSME_TransportKeyReq
        0     59   -> ZDSecMgrAppKeyGet
        0     51   -> osal_memset
      2      0   ZDSecMgrAppKeyTypeSet
      0     49   ZDSecMgrApsLinkKeyInit
        0     36   -> osal_memset
        0     38   -> osal_nv_item_init
        0     40   -> osal_nv_write
      2     36   ZDSecMgrAssocDeviceAuth
      2     52   ZDSecMgrAuthNwkKey
        2      0   -> osal_set_event
      0     22   ZDSecMgrAuthenticationCheck
        0     22   -> APSME_GetRequest
        0     22   -> AddrMgrExtAddrLookup
        0     22   -> NLME_GetExtAddr
        0     22   -> ZDSecMgrEntryLookupExt
        0     22   -> ZDSecMgrExtAddrLookup
        0     22   -> sAddrExtCmp
      1     25   ZDSecMgrAuthenticationSet
        0     11   -> ZDSecMgrEntryLookupExt
      0     52   ZDSecMgrClearNVKeyValues
        0     48   -> osal_memset
        0     52   -> osal_nv_write
      2      0   ZDSecMgrConfig
        2      0   -> APSME_SecurityCM_CD
        2      0   -> SSP_Init
      0     71   ZDSecMgrDeviceJoin
        0     30   -> ZDSecMgrAddrClear
        0     32   -> ZDSecMgrAddrStore
        0     30   -> ZDSecMgrDeviceRemove
        0     30   -> ZDSecMgrDeviceValidate
        0     30   -> ZDSecMgrSendNwkKey
        0     33   -> osal_memcpy
      0     40   ZDSecMgrDeviceJoinDirect
        0     38   -> APSME_SearchTCLinkKeyEntry
        0     36   -> AssocGetWithShort
        0     36   -> NLME_GetShortAddr
        0     36   -> ZDSecMgrAssocDeviceAuth
        0     36   -> ZDSecMgrDeviceJoin
        0     36   -> bdb_TCAddJoiningDevice
        0     40   -> osal_nv_write
      0     29   ZDSecMgrDeviceJoinFwd
        0     27   -> APSME_GetRequest
        0     29   -> APSME_SearchTCLinkKeyEntry
        0     27   -> APSME_UpdateDeviceReq
        0     27   -> AssocGetWithShort
        0     27   -> ZDSecMgrAssocDeviceAuth
      2     33   ZDSecMgrDeviceNew
        2      0   -> ZDSecMgrDeviceJoinDirect
      0     61   ZDSecMgrDeviceRemove
        0     29   -> APSME_GetRequest
        0     29   -> APSME_RemoveDeviceReq
        0     31   -> APSME_SearchTCLinkKeyEntry
        0     29   -> AssocGetWithExt
        0     29   -> NLME_GetShortAddr
        0     29   -> NLME_LeaveReq
      0     11   ZDSecMgrDeviceRemoveByExtAddr
        0     11   -> ZDSecMgrEntryFree
        0     11   -> ZDSecMgrEntryLookupExt
      2     30   ZDSecMgrDeviceValidate
        2      0   -> ZDSecMgrDeviceValidateRM
      2      0   ZDSecMgrDeviceValidateRM
      0     35   ZDSecMgrEntryFree
        0     20   -> ZDSecMgrEntryLookupAMIGetIndex
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> osal_memset
        0     24   -> osal_nv_read
        0     24   -> osal_nv_write
      0     19   ZDSecMgrEntryInit
        0      9   -> ZDSecMgrRestoreFromNV
        0      9   -> osal_mem_alloc
      0     22   ZDSecMgrEntryLookup
        0     22   -> AddrMgrEntryLookupNwk
      0     61   ZDSecMgrEntryLookupAMI
      0     29   ZDSecMgrEntryLookupAMIGetIndex
      0     33   ZDSecMgrEntryLookupExt
        0     11   -> ZDSecMgrEntryLookupAMI
        0     11   -> ZDSecMgrExtAddrLookup
      0     32   ZDSecMgrEntryLookupExtGetIndex
        0     11   -> ZDSecMgrExtAddrLookup
      0     61   ZDSecMgrEntryNew
      0     74   ZDSecMgrExtAddrLookup
        0     22   -> AddrMgrEntryLookupExt
        0     22   -> AddrMgrExtAddrSet
      0     24   ZDSecMgrExtAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      0    107   ZDSecMgrGenerateKeyFromSeed
        0     37   -> osal_memcpy
        0     38   -> osal_nv_read
      1     38   ZDSecMgrGenerateRndKey
        0     12   -> osal_rand
      0     39   ZDSecMgrGenerateSeed
        0     26   -> ZDSecMgrGenerateRndKey
        0     26   -> osal_memset
        0     28   -> osal_nv_item_init
        0     30   -> osal_nv_write
      0     10   ZDSecMgrInit
        0     10   -> APSME_SecurityCM_CD
        0     10   -> APSME_SetRequest
        0     10   -> NLME_GetExtAddr
        0     10   -> SSP_Init
        0     10   -> ZDSecMgrEntryInit
      0     16   ZDSecMgrInitNV
        0     14   -> osal_nv_item_init
        0     16   -> osal_nv_write
      0      9   ZDSecMgrInitNVKeyTables
        0      9   -> APSME_TCLinkKeyInit
        0      9   -> ZDSecMgrApsLinkKeyInit
        0      9   -> ZDSecMgrGenerateSeed
        0      9   -> ZDSecMgrNwkKeyInit
      1     33   ZDSecMgrNewDeviceEvent
        0     33   -> AddrMgrEntryGet
        0     33   -> AssocGetWithShort
        0     33   -> AssocRemove
        0     33   -> NLME_GetShortAddr
        0     33   -> ZDSecMgrAddrClear
        0     33   -> ZDSecMgrAssocDeviceAuth
        0     33   -> ZDSecMgrDeviceNew
      0     75   ZDSecMgrNwkKeyInit
        0     62   -> osal_memset
        0     64   -> osal_nv_item_init
        0     66   -> osal_nv_write
        0     62   -> zgReadStartupOptions
      2      0   ZDSecMgrPermitJoining
      2      0   ZDSecMgrPermitJoiningTimeout
      0     71   ZDSecMgrReadKeyFromNv
        0     18   -> osal_memcpy
        0     19   -> osal_nv_read
      0     17   ZDSecMgrRemoveDeviceInd
        0     17   -> APSME_LookupNwkAddr
        0     17   -> NLME_GetShortAddr
        0     17   -> ZDSecMgrDeviceRemove
      2      4   ZDSecMgrRequestAppKey
        2      4   -> APSME_RequestKeyReq
      2      0   ZDSecMgrRequestKeyInd
        2      0   -> ZDSecMgrAppKeyReq
        2      0   -> ZDSecMgrTclkReq
      0     33   ZDSecMgrRestoreFromNV
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> osal_memset
        0     24   -> osal_nv_read
        0     24   -> osal_nv_write
      0     22   ZDSecMgrSaveApsLinkKey
        0     18   -> osal_mem_alloc
        0     18   -> osal_mem_free
        0     18   -> osal_memset
        0     22   -> osal_nv_read
        0     22   -> osal_nv_write
      0     22   ZDSecMgrSaveTCLinkKey
        0     18   -> osal_mem_alloc
        0     18   -> osal_mem_free
        0     22   -> osal_nv_read
        0     22   -> osal_nv_write
      1     80   ZDSecMgrSendNwkKey
        0     46   -> APSME_TransportKeyReq
        0     46   -> NLME_GetShortAddr
        0     50   -> NLME_ReadNwkKeyInfo
        0     46   -> osal_memset
      0     23   ZDSecMgrSetDefaultNV
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     19   -> osal_memset
        0     23   -> osal_nv_write
      2      0   ZDSecMgrSwitchKeyInd
        2      0   -> SSP_SwitchNwkKey
        2      0   -> ZDApp_NVUpdate
      1     27   ZDSecMgrSwitchNwkKey
        0     27   -> APSME_SwitchKeyReq
        0     27   -> AddrMgrEntryLookupNwk
        0     27   -> ZDApp_NVUpdate
      0     79   ZDSecMgrTCDataLoad
        0     25   -> APSME_IsDistributedSecurity
        0     25   -> AddrMgrEntryLookupExt
        0     27   -> ZDSecMgrAddrStore
        0     25   -> sAddrExtCpy
      0     17   ZDSecMgrTCExtAddrCheck
        0     17   -> APSME_GetRequest
        0     17   -> sAddrExtCmp
      0     71   ZDSecMgrTclkReq
        0     69   -> APSME_LookupExtAddr
        0     69   -> APSME_LookupNwkAddr
        0     71   -> APSME_SearchTCLinkKeyEntry
        0     69   -> APSME_TransportKeyReq
        0     69   -> ZDSecMgrGenerateKeyFromSeed
        0     69   -> osal_memset
      0     56   ZDSecMgrTransportKeyInd
        0     52   -> APSME_EraseICEntry
        0     52   -> APSME_LinkKeySet
        0     54   -> APSME_SearchTCLinkKeyEntry
        0     52   -> SSP_SwitchNwkKey
        0     52   -> SSP_UpdateNwkKey
        0     52   -> ZDP_NwkAddrReq
        0     54   -> ZDSecMgrAddrStore
        0     52   -> ZDSecMgrAuthNwkKey
        0     52   -> ZDSecMgrEntryLookupAMI
        0     52   -> ZDSecMgrEntryNew
        0     52   -> ZDSecMgrExtAddrLookup
        0     52   -> ZDSecMgrReadKeyFromNv
        0     52   -> ZDSecMgrTCDataLoad
        0     52   -> ZDSecMgrUpdateTCAddress
        0     52   -> ZDSecMgrWriteNV
        0     52   -> bdb_tcLinkKeyExchangeAttempt
        0     52   -> osal_isbufset
        0     52   -> osal_memset
        0     54   -> osal_nv_item_init
        0     56   -> osal_nv_write
      0     42   ZDSecMgrUpdateDeviceInd
        0     40   -> APSME_SearchTCLinkKeyEntry
        0     38   -> ZDSecMgrDeviceJoin
        0     38   -> bdb_TCAddJoiningDevice
        0     42   -> osal_nv_write
      1     36   ZDSecMgrUpdateNwkKey
        0     36   -> APSME_TransportKeyReq
        0     36   -> AddrMgrEntryLookupNwk
        0     36   -> SSP_UpdateNwkKey
        0     36   -> ZDApp_NVUpdate
      0     74   ZDSecMgrUpdateTCAddress
        0     18   -> APSME_SetRequest
        0     22   -> osal_nv_write
        0     18   -> sAddrExtCpy
      2      0   ZDSecMgrVerifyKeyInd
        2      0   -> ZDSecMgrAppConfKeyReq
      0     70   ZDSecMgrWriteNV
        0     18   -> osal_nv_write


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {255, 255, 255, 255, 255, 255, 255,
       1  ?<Initializer for ZDSecMgrAppKeyType>
       4  ?<Initializer for requestLinkKeyTimeout>
       1  ?<Initializer for requestNewTrustCenterLinkKey
       5  ??Subroutine55_0
       8  ??Subroutine56_0
       6  ??Subroutine57_0
       9  ??Subroutine58_0
       8  ??Subroutine59_0
       2  ??Subroutine60_0
       6  ??Subroutine61_0
       4  ??Subroutine62_0
       7  ??Subroutine63_0
       6  ??Subroutine64_0
       3  ??Subroutine65_0
       5  ??Subroutine66_0
       5  ??Subroutine67_0
       2  ??Subroutine68_0
       4  ??Subroutine69_0
       8  ??Subroutine70_0
       3  ??Subroutine71_0
       5  ??Subroutine72_0
       8  ??Subroutine73_0
       6  ??Subroutine74_0
       5  ??Subroutine75_0
       9  ??Subroutine76_0
       5  ??Subroutine77_0
       5  ??Subroutine78_0
       5  ??Subroutine79_0
       2  ?Subroutine0
       8  ?Subroutine1
       3  ?Subroutine10
       4  ?Subroutine11
       4  ?Subroutine12
       1  ?Subroutine13
      21  ?Subroutine14
      10  ?Subroutine15
      13  ?Subroutine16
       4  ?Subroutine17
       9  ?Subroutine18
       8  ?Subroutine19
       3  ?Subroutine2
      15  ?Subroutine20
       8  ?Subroutine21
       9  ?Subroutine22
       6  ?Subroutine23
       6  ?Subroutine24
       7  ?Subroutine25
       6  ?Subroutine26
       5  ?Subroutine27
       5  ?Subroutine28
       3  ?Subroutine29
       3  ?Subroutine3
       6  ?Subroutine30
       7  ?Subroutine31
       6  ?Subroutine32
      11  ?Subroutine33
       4  ?Subroutine34
      14  ?Subroutine35
       4  ?Subroutine36
       8  ?Subroutine37
      14  ?Subroutine38
       9  ?Subroutine39
       2  ?Subroutine4
       9  ?Subroutine40
      22  ?Subroutine41
       1  ?Subroutine42
      12  ?Subroutine43
      27  ?Subroutine44
      23  ?Subroutine45
      14  ?Subroutine46
      10  ?Subroutine47
       1  ?Subroutine48
       6  ?Subroutine49
       3  ?Subroutine5
       9  ?Subroutine50
       7  ?Subroutine51
       6  ?Subroutine52
      30  ?Subroutine53
      13  ?Subroutine54
       3  ?Subroutine6
       5  ?Subroutine7
       4  ?Subroutine8
       6  ?Subroutine9
      14  APSME_IsDefaultTCLK
       6  APSME_IsDefaultTCLK::?relay
     176  APSME_IsLinkKeyValid
       6  APSME_IsLinkKeyValid::?relay
      58  APSME_KeyFwdToChild
       6  APSME_KeyFwdToChild::?relay
      55  APSME_LinkKeyNVIdGet
       6  APSME_LinkKeyNVIdGet::?relay
     287  APSME_LinkKeySet
       6  APSME_LinkKeySet::?relay
     362  APSME_TCLinkKeyInit
       6  APSME_TCLinkKeyInit::?relay
     560  APSME_TCLinkKeyLoad
       6  APSME_TCLinkKeyLoad::?relay
     355  APSME_TCLinkKeySync
       6  APSME_TCLinkKeySync::?relay
      27  ApsLinkKeyFrmCntr
     360  TCLinkKeyFrmCntr
      19  TrustCenterLinkKey
      78  ZDSecMgrAPSRemove
       6  ZDSecMgrAPSRemove::?relay
     126  ZDSecMgrAddLinkKey
       6  ZDSecMgrAddLinkKey::?relay
      68  ZDSecMgrAddrClear
       6  ZDSecMgrAddrClear::?relay
      73  ZDSecMgrAddrStore
       6  ZDSecMgrAddrStore::?relay
      73  ZDSecMgrAppConfKeyReq
       6  ZDSecMgrAppConfKeyReq::?relay
      39  ZDSecMgrAppKeyGet
       6  ZDSecMgrAppKeyGet::?relay
     276  ZDSecMgrAppKeyReq
       6  ZDSecMgrAppKeyReq::?relay
       1  ZDSecMgrAppKeyType
      23  ZDSecMgrAppKeyTypeSet
       6  ZDSecMgrAppKeyTypeSet::?relay
     120  ZDSecMgrApsLinkKeyInit
       6  ZDSecMgrApsLinkKeyInit::?relay
      23  ZDSecMgrAssocDeviceAuth
       6  ZDSecMgrAssocDeviceAuth::?relay
      26  ZDSecMgrAuthNwkKey
       6  ZDSecMgrAuthNwkKey::?relay
     113  ZDSecMgrAuthenticationCheck
       6  ZDSecMgrAuthenticationCheck::?relay
      31  ZDSecMgrAuthenticationSet
       6  ZDSecMgrAuthenticationSet::?relay
     163  ZDSecMgrClearNVKeyValues
       6  ZDSecMgrClearNVKeyValues::?relay
      12  ZDSecMgrConfig
       6  ZDSecMgrConfig::?relay
     247  ZDSecMgrDeviceJoin
       6  ZDSecMgrDeviceJoin::?relay
     247  ZDSecMgrDeviceJoinDirect
       6  ZDSecMgrDeviceJoinDirect::?relay
     250  ZDSecMgrDeviceJoinFwd
       6  ZDSecMgrDeviceJoinFwd::?relay
       9  ZDSecMgrDeviceNew
       6  ZDSecMgrDeviceNew::?relay
     312  ZDSecMgrDeviceRemove
       6  ZDSecMgrDeviceRemove::?relay
      35  ZDSecMgrDeviceRemoveByExtAddr
       6  ZDSecMgrDeviceRemoveByExtAddr::?relay
      24  ZDSecMgrDeviceValidate
       6  ZDSecMgrDeviceValidate::?relay
      17  ZDSecMgrDeviceValidateRM
       6  ZDSecMgrDeviceValidateRM::?relay
       2  ZDSecMgrEntries
     364  ZDSecMgrEntryFree
       6  ZDSecMgrEntryFree::?relay
      72  ZDSecMgrEntryInit
       6  ZDSecMgrEntryInit::?relay
      98  ZDSecMgrEntryLookup
       6  ZDSecMgrEntryLookup::?relay
      67  ZDSecMgrEntryLookupAMI
       6  ZDSecMgrEntryLookupAMI::?relay
      63  ZDSecMgrEntryLookupAMIGetIndex
       6  ZDSecMgrEntryLookupAMIGetIndex::?relay
      59  ZDSecMgrEntryLookupExt
       6  ZDSecMgrEntryLookupExt::?relay
      92  ZDSecMgrEntryLookupExtGetIndex
       6  ZDSecMgrEntryLookupExtGetIndex::?relay
     114  ZDSecMgrEntryNew
       6  ZDSecMgrEntryNew::?relay
      72  ZDSecMgrExtAddrLookup
       6  ZDSecMgrExtAddrLookup::?relay
      73  ZDSecMgrExtAddrStore
       6  ZDSecMgrExtAddrStore::?relay
     231  ZDSecMgrGenerateKeyFromSeed
       6  ZDSecMgrGenerateKeyFromSeed::?relay
      54  ZDSecMgrGenerateRndKey
       6  ZDSecMgrGenerateRndKey::?relay
     103  ZDSecMgrGenerateSeed
       6  ZDSecMgrGenerateSeed::?relay
      48  ZDSecMgrInit
       6  ZDSecMgrInit::?relay
     111  ZDSecMgrInitNV
       6  ZDSecMgrInitNV::?relay
      28  ZDSecMgrInitNVKeyTables
       6  ZDSecMgrInitNVKeyTables::?relay
     213  ZDSecMgrNewDeviceEvent
       6  ZDSecMgrNewDeviceEvent::?relay
     474  ZDSecMgrNwkKeyInit
       6  ZDSecMgrNwkKeyInit::?relay
      31  ZDSecMgrPermitJoining
       6  ZDSecMgrPermitJoining::?relay
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      23  ZDSecMgrPermitJoiningTimeout
       6  ZDSecMgrPermitJoiningTimeout::?relay
     170  ZDSecMgrReadKeyFromNv
       6  ZDSecMgrReadKeyFromNv::?relay
      71  ZDSecMgrRemoveDeviceInd
       6  ZDSecMgrRemoveDeviceInd::?relay
      38  ZDSecMgrRequestAppKey
       6  ZDSecMgrRequestAppKey::?relay
      40  ZDSecMgrRequestKeyInd
       6  ZDSecMgrRequestKeyInd::?relay
     459  ZDSecMgrRestoreFromNV
       6  ZDSecMgrRestoreFromNV::?relay
     245  ZDSecMgrSaveApsLinkKey
       6  ZDSecMgrSaveApsLinkKey::?relay
     221  ZDSecMgrSaveTCLinkKey
       6  ZDSecMgrSaveTCLinkKey::?relay
     264  ZDSecMgrSendNwkKey
       6  ZDSecMgrSendNwkKey::?relay
     200  ZDSecMgrSetDefaultNV
       6  ZDSecMgrSetDefaultNV::?relay
      23  ZDSecMgrSwitchKeyInd
       6  ZDSecMgrSwitchKeyInd::?relay
     151  ZDSecMgrSwitchNwkKey
       6  ZDSecMgrSwitchNwkKey::?relay
       1  ZDSecMgrTCAuthenticated
      90  ZDSecMgrTCDataLoad
       6  ZDSecMgrTCDataLoad::?relay
       8  ZDSecMgrTCExtAddr
      38  ZDSecMgrTCExtAddrCheck
       6  ZDSecMgrTCExtAddrCheck::?relay
     247  ZDSecMgrTclkReq
       6  ZDSecMgrTclkReq::?relay
     583  ZDSecMgrTransportKeyInd
       6  ZDSecMgrTransportKeyInd::?relay
     260  ZDSecMgrUpdateDeviceInd
       6  ZDSecMgrUpdateDeviceInd::?relay
     202  ZDSecMgrUpdateNwkKey
       6  ZDSecMgrUpdateNwkKey::?relay
     111  ZDSecMgrUpdateTCAddress
       6  ZDSecMgrUpdateTCAddress::?relay
      10  ZDSecMgrVerifyKeyInd
       6  ZDSecMgrVerifyKeyInd::?relay
     179  ZDSecMgrWriteNV
       6  ZDSecMgrWriteNV::?relay
       4  __Constant_1
       4  __Constant_3e9
       4  __Constant_a
       4  __Constant_b
       1  gZDSECMGR_TC_DEVICE_IC_MAX
       1  gZDSECMGR_TC_DEVICE_MAX
       4  requestLinkKeyTimeout
       1  requestNewTrustCenterLinkKey

 
 10 842 bytes in segment BANKED_CODE
    426 bytes in segment BANK_RELAYS
      2 bytes in segment CODE_C
      6 bytes in segment XDATA_I
      6 bytes in segment XDATA_ID
     24 bytes in segment XDATA_ROM_C
    419 bytes in segment XDATA_Z
 
 11 276 bytes of CODE  memory
      8 bytes of CONST memory (+ 16 bytes shared)
    425 bytes of XDATA memory

Errors: none
Warnings: none
