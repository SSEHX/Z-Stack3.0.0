###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                26/Oct/2017  14:48:30
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack 3.0.0\Components\stack\zcl\zcl.c
#    Command line       =  
#        -f "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas
#        Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        "C:\Texas Instruments\Z-Stack 3.0.0\Components\stack\zcl\zcl.c" -D
#        BDB_REPORTING -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE
#        -D xPOWER_SAVING -D NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D
#        xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D
#        xMT_APP_CNF_FUNC -D LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D
#        ZCL_READ -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF -D
#        ZCL_SCENES -D ZCL_GROUPS -D xZCL_LEVEL_CTRL -lC "C:\Texas
#        Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List"
#        -lA "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I "C:\Texas
#        Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
#        "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes
#    List file          =  
#        C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List\zcl.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack
#        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\Obj\zcl.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack 3.0.0\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2015-09-09 11:51:49 -0700 (Wed, 09 Sep 2015) $
      4            Revision:       $Revision: 44489 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52             
     53          #ifdef BDB_REPORTING
     54            #include "bdb_Reporting.h"
     55          #endif
     56          #include "bdb_interface.h"
     57          
     58          #include "zcl_green_power.h"
     59          
     60             
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          /*** Frame Control ***/
     65          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     66          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     67          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     68          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     69          
     70          /*** Attribute Access Control ***/
     71          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     72          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     73          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     74          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     75          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     76          #define zcl_AccessClient( a )         ( (a) & ACCESS_CLIENT )
     77          
     78          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     79          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     80          
     81          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     82                                                  (zclHdr).fc.manuSpecific == 0          && \
     83                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     84          
     85          // Commands that have corresponding responses
     86          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     87                                                  (cmd) == ZCL_CMD_WRITE                  || \
     88                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     89                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     90                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     91                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     92                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     93                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     94                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     95                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     96          #define  ZCL_VALID_MIN_HEADER_LEN  3
     97          
     98          /*********************************************************************
     99           * CONSTANTS
    100           */
    101          
    102          /*********************************************************************
    103           * TYPEDEFS
    104           */
    105          typedef struct zclLibPlugin
    106          {
    107            struct zclLibPlugin *next;
    108            uint16              startClusterID;    // starting cluster ID
    109            uint16              endClusterID;      // ending cluster ID
    110            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    111          } zclLibPlugin_t;
    112          
    113          // Command record list
    114          typedef struct zclCmdRecsList
    115          {
    116            struct zclCmdRecsList *pNext;
    117            uint8                 endpoint;
    118            uint8                 numCommands;
    119            CONST zclCommandRec_t *pCmdRecs;
    120          } zclCmdRecsList_t;
    121          
    122          
    123          // Cluster option list item
    124          typedef struct zclClusterOptionList
    125          {
    126            struct zclClusterOptionList *next;
    127            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    128            uint8                       numOptions; // Number of the following records
    129            zclOptionRec_t              *options;   // option records
    130          } zclClusterOptionList;
    131          
    132          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    133          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    134          
    135          typedef struct
    136          {
    137            zclParseInProfileCmd_t   pfnParseInProfile;
    138            zclProcessInProfileCmd_t pfnProcessInProfile;
    139          } zclCmdItems_t;
    140          
    141          
    142          // List record for external handler for unhandled ZCL Foundation commands/rsps
    143          typedef struct zclExternalFoundationHandlerList
    144          {
    145              struct zclExternalFoundationHandlerList *next;
    146              uint8 zcl_ExternalTaskID;
    147              uint8 zcl_ExternalEndPoint;
    148          } zclExternalFoundationHandlerList;
    149          
    150          
    151          /*********************************************************************
    152           * GLOBAL VARIABLES
    153           */
    154          
    155          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    156            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    157          #endif
    158          
    159          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    160          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    161          
    162          // ZCL Sequence number
    163          //uint8 zcl_SeqNum = 0x00;  //Not longer used, refer to bdb_getZCLFrameCounter() in bdb_interface.h

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    164          uint8 zcl_InSeqNum = 0x00;
   \                     zcl_InSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    165          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    166          uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    167          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    168          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    169          
    170          /*********************************************************************
    171           * EXTERNAL VARIABLES
    172           */
    173          
    174          /*********************************************************************
    175           * EXTERNAL FUNCTIONS
    176           */
    177          
    178          /*********************************************************************
    179           * LOCAL VARIABLES
    180           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    181          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    182          
    183          #if defined ( ZCL_DISCOVER )
    184            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    185          #endif
    186          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    187          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    189          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    190          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    191          
    192          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    193          static zclExternalFoundationHandlerList *externalEndPointHandlerList = (zclExternalFoundationHandlerList *)NULL;
   \                     externalEndPointHandlerList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    194          #endif
    195          
    196          /*********************************************************************
    197           * LOCAL FUNCTIONS
    198           */
    199          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    200          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    201          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    202          
    203          #if !defined ( ZCL_STANDALONE )
    204          static uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId );
    205          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg );
    206          #endif // !defined ( ZCL_STANDALONE )
    207          
    208          #if defined ( ZCL_DISCOVER )
    209            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    210          #endif
    211          
    212          zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    213          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    214          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    215          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    216          
    217          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    218          
    219          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    220          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    221          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    222          #endif // ZCL_READ || ZCL_WRITE
    223          
    224          #ifdef ZCL_READ
    225          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    226          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    227          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    228                                                   uint8 *pAttrData, uint16 *pDataLen );
    229          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    230          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    231          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    232          #endif // ZCL_READ
    233          
    234          #ifdef ZCL_WRITE
    235          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    236                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    237          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    238                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    239          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    240          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    241          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    242          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    243          #endif // ZCL_WRITE
    244          
    245          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    246          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    247          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    248          #endif
    249          
    250          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    251          
    252          #ifdef ZCL_DISCOVER
    253          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    254          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    255          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    256          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    257          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    258          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    259          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    260          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    261          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    262          #endif // ZCL_DISCOVER
    263          
    264          /*********************************************************************
    265           * Parse Profile Command Function Table
    266           */
    267          

   \                                 In  segment CODE_C, align 1
    268          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW `??zclParseInReadCmd::?relay`
   \   000002   ....         DW `??zclProcessInReadCmd::?relay`
   \   000004   ....         DW `??zclParseInReadRspCmd::?relay`
   \   000006   ....         DW `??zcl_HandleExternal::?relay`
   \   000008   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000A   ....         DW `??zclProcessInWriteCmd::?relay`
   \   00000C   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000E   ....         DW `??zclProcessInWriteUndividedCmd::?relay`
   \   000010   ....         DW `??zclParseInWriteRspCmd::?relay`
   \   000012   ....         DW `??zcl_HandleExternal::?relay`
   \   000014   ....         DW `??zclParseInWriteCmd::?relay`
   \   000016   ....         DW `??zclProcessInWriteCmd::?relay`
   \   000018   ....         DW `??zclParseInConfigReportCmd::?relay`
   \   00001A   ....         DW `??zcl_HandleExternal::?relay`
   \   00001C   0000         DW 0H
   \   00001E   0000         DW 0H
   \   000020   ....         DW `??zclParseInReadReportCfgCmd::?relay`
   \   000022   ....         DW `??zcl_HandleExternal::?relay`
   \   000024   0000         DW 0H
   \   000026   0000         DW 0H
   \   000028   0000         DW 0H
   \   00002A   0000         DW 0H
   \   00002C   ....         DW `??zclParseInDefaultRspCmd::?relay`
   \   00002E   ....         DW `??zcl_HandleExternal::?relay`
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    269          {
    270          #ifdef ZCL_READ
    271            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    272            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    273          #else
    274            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    275            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    276          #endif // ZCL_READ
    277          
    278          #ifdef ZCL_WRITE
    279            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    280            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    281            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    282            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    283          #else
    284            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    285            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    286            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    287            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    288          #endif // ZCL_WRITE
    289          
    290          #ifdef ZCL_REPORTING_DEVICE
    291              /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    292          #else
    293              /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    294          #endif
    295          
    296          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    297              /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    298          #else
    299              /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    300          #endif
    301          
    302          #ifdef ZCL_REPORTING_DEVICE
    303              /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    304          #else
    305              /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    306          #endif
    307          
    308          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    309              /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    310          #else
    311              /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    312          #endif
    313          
    314          #ifdef ZCL_REPORT_DESTINATION_DEVICE
    315              /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    316          #else
    317              /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    318          #endif
    319          
    320            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    321          
    322          #ifdef ZCL_DISCOVER
    323            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    324            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    325            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    326            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    327            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    328            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    329            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    330            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    331            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    332            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    333            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    334          #else
    335            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    336            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    337            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    338            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    339            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    340            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    341            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    342            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    343            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    344            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    345            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    346          #endif // ZCL_DISCOVER
    347          };
    348          
    349          /*********************************************************************
    350           * PUBLIC FUNCTIONS
    351           *********************************************************************/
    352          
    353          #if !defined ( ZCL_STANDALONE )
    354          /*********************************************************************
    355           * @fn          zcl_Init
    356           *
    357           * @brief       Initialization function for the zcl layer.
    358           *
    359           * @param       task_id - ZCL task id
    360           *
    361           * @return      none
    362           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    363          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    364          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    365            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    366          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    367          #endif
    368          
    369          #if !defined ( ZCL_STANDALONE )
    370          /*********************************************************************
    371           * @fn          zcl_event_loop
    372           *
    373           * @brief       Event Loop Processor for zcl.
    374           *
    375           * @param       task_id - task id
    376           * @param       events - event bitmap
    377           *
    378           * @return      unprocessed events
    379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    380          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    381          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
    382            uint8 *msgPtr;
    383          
    384            (void)task_id;  // Intentionally unreferenced parameter
    385          
    386            if ( events & SYS_EVENT_MSG )
   \   000009   EB           MOV     A,R3
   \   00000A   5480         ANL     A,#0x80
   \   00000C   604D         JZ      ??zcl_event_loop_0
    387            {
    388              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00000E                ; Setup parameters for call to function osal_msg_receive
   \   00000E   800E         SJMP    ??zcl_event_loop_1
    389              while ( msgPtr != NULL )
    390              {
    391                uint8 dealloc = TRUE;
    392          
    393                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    394                {
    395                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000010                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   `??zcl_ProcessMessageMSG::?relay`; Banked call to: zcl_ProcessMessageMSG
    396                }
    397                else
    398                {
    399                  uint8 taskID;
    400                  taskID = zcl_getExternalFoundationHandler( (afIncomingMSGPacket_t *)msgPtr );
    401          
    402                  if ( taskID != TASK_NO_TASK )
    403                  {
    404                    // send it to another task to process.
    405                    osal_msg_send( taskID, msgPtr );
    406                    dealloc = FALSE;
    407                  }
    408                }
    409          
    410                // Release the memory
    411                if ( dealloc )
    412                {
    413                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   EE           MOV     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    414                }
    415          
    416                // Next
    417                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   00001E                ; Setup parameters for call to function osal_msg_receive
   \   00001E   90....       MOV     DPTR,#zcl_TaskID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   000026   8A..         MOV     ?V2,R2
   \   000028   8B..         MOV     ?V3,R3
   \   00002A   AE..         MOV     R6,?V2
   \   00002C   AF..         MOV     R7,?V3
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   6020         JZ      ??zcl_event_loop_4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   641A         XRL     A,#0x1a
   \   000039   60D5         JZ      ??zcl_event_loop_2
   \   00003B                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   00003B   EE           MOV     A,R6
   \   00003C   FA           MOV     R2,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000042   E9           MOV     A,R1
   \   000043   F9           MOV     R1,A
   \   000044   74FF         MOV     A,#-0x1
   \   000046   69           XRL     A,R1
   \   000047   60CE         JZ      ??zcl_event_loop_3
   \   000049                ; Setup parameters for call to function osal_msg_send
   \   000049   EE           MOV     A,R6
   \   00004A   FA           MOV     R2,A
   \   00004B   EF           MOV     A,R7
   \   00004C   FB           MOV     R3,A
   \   00004D   12....       LCALL   `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   000050   80CC         SJMP    ??zcl_event_loop_1
    418              }
    419          
    420              // return unprocessed events
    421              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   000052   AA..         MOV     R2,?V0
   \   000054   E5..         MOV     A,?V1
   \   000056   6480         XRL     A,#0x80
   \   000058   FB           MOV     R3,A
   \   000059   8004         SJMP    ??zcl_event_loop_5
    422            }
    423          //GP_UPDATE 
    424          #if (ZG_BUILD_RTR_TYPE)
    425            if ( events & ZCL_DATABUF_SEND )
    426            {
    427              gpNotificationMsg_t *gpNotification = NULL;
    428              gpCmdPayloadMsg_t *pCmdPayloadMsgCurr = NULL;
    429              
    430              gpNotification = gp_GetHeadNotificationMsg( );
    431              
    432              if ( gpNotification != NULL )
    433              {
    434                pCmdPayloadMsgCurr = ( gpCmdPayloadMsg_t* ) gpNotification->pMsg ;
    435              }
    436              
    437              zcl_SendCommand( GREEN_POWER_INTERNAL_ENDPOINT, &gpNotification->addr, ZCL_CLUSTER_ID_GREEN_POWER,
    438                                    COMMAND_GP_NOTIFICATION, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    439                                    TRUE, 0,  bdb_getZCLFrameCounter(), pCmdPayloadMsgCurr->lenght, pCmdPayloadMsgCurr->pMsg );
    440              
    441              gp_NotificationMsgClean( gp_GetPHeadNotification ( ) );
    442              
    443              if ( gp_GetHeadNotificationMsg ( ) != NULL )
    444              {
    445                osal_start_timerEx( zcl_TaskID, ZCL_DATABUF_SEND, 50 );
    446              }
    447            }
    448          #endif
    449          
    450            // Discard unknown events
    451            return 0;
   \                     ??zcl_event_loop_0:
   \   00005B   7A00         MOV     R2,#0x0
   \   00005D   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00005F   02....       LJMP    ?Subroutine1 & 0xFFFF
    452          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    453          #endif
    454          
    455          #if !defined ( ZCL_STANDALONE )
    456          /*********************************************************************
    457           * @fn      zcl_registerForMsg
    458           *
    459           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    460           *          messages that aren't processed to one task (if a task is
    461           *          registered).
    462           *
    463           * @param   taskId - task Id of the Application where commands will be sent to
    464           *
    465           * @return  TRUE if task registeration successful, FALSE otherwise
    466           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    467          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    468          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    469            return zcl_addExternalFoundationHandler( taskId, AF_BROADCAST_ENDPOINT );
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   7AFF         MOV     R2,#-0x1
   \   000007   02....       LJMP    ?Subroutine2 & 0xFFFF
    470          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   `??zcl_addExternalFoundationHandler::?relay`; Banked call to: zcl_addExternalFoundationHandler
   \   000003                REQUIRE ??Subroutine165_0
   \   000003                ; // Fall through to label ??Subroutine165_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine165_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    471          
    472          /*********************************************************************
    473           * @fn      zcl_registerForMsgExt
    474           *
    475           * @brief   This function enables a Task to register to recieve all
    476           *          incoming Foundation Command/Response messages, for a particular
    477           *          End Point, that aren't processed by ZCL.
    478           *
    479           *          NOTE: Any Task registered for a unique end point will take
    480           *          priority over any Task registered with the AF_BROADCAST_ENDPOINT
    481           *          value.  ie. If task A registers for End Point 1, task B registers
    482           *          for AF_BROADCAST_ENDPOINT,  commands addressed to End Point 1 will be
    483           *          sent to Task A and NOT Task B.
    484           *
    485           * @param   taskId - task Id of the Application where commands will be sent to
    486           * @param   endPointId - end point Id of interest
    487           *
    488           * @return  TRUE if task registeration successful, FALSE otherwise
    489           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    490          uint8 zcl_registerForMsgExt( uint8 taskId, uint8 endPointId  )
   \                     zcl_registerForMsgExt:
    491          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    492            return ( zcl_addExternalFoundationHandler( taskId, endPointId  ) );
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   02....       LJMP    ?Subroutine2 & 0xFFFF
    493          }
    494          
    495          /*********************************************************************
    496           * @fn      zcl_addExternalFoundationHandler
    497           *
    498           * @brief   This function adds a record to the internal list of external
    499           *          handlers of unhandled incoming Foundation Command/Response messages.
    500           *
    501           * @param   taskId - task Id of the Application where commands will be sent to
    502           * @param   endPointId - end point Id of interest
    503           *
    504           * @return  TRUE if task registeration successful, FALSE otherwise
    505           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    506          uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId  )
   \                     zcl_addExternalFoundationHandler:
    507          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
    508            zclExternalFoundationHandlerList *pNewItem;
    509            zclExternalFoundationHandlerList *pLoop;
    510            zclExternalFoundationHandlerList *pLoopPrev;
    511          
    512            // Fill in the new endpoint registrant list
    513            pNewItem = zcl_mem_alloc( sizeof( zclExternalFoundationHandlerList ) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A04         MOV     R2,#0x4
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000010   8A..         MOV     ?V0,R2
   \   000012   8B..         MOV     ?V1,R3
   \   000014   A8..         MOV     R0,?V0
   \   000016   A9..         MOV     R1,?V1
    514            if ( pNewItem == NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   6032         JZ      ??zcl_addExternalFoundationHandler_0
    515            {
    516              return ( false );
    517            }
    518          
    519            pNewItem->zcl_ExternalEndPoint = endPointId;
   \   00001C   EF           MOV     A,R7
   \   00001D   8882         MOV     DPL,R0
   \   00001F   8983         MOV     DPH,R1
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
    520            pNewItem->zcl_ExternalTaskID = taskId;
   \   000025   EE           MOV     A,R6
   \   000026   8882         MOV     DPL,R0
   \   000028   8983         MOV     DPH,R1
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   12....       LCALL   ?Subroutine33 & 0xFFFF
    521            pNewItem->next = NULL;
   \                     ??CrossCallReturnLabel_35:
   \   00002F   F0           MOVX    @DPTR,A
    522          
    523            // Add to the list
    524            if ( externalEndPointHandlerList == NULL )
   \   000030   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000033   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000036   7009         JNZ     ??zcl_addExternalFoundationHandler_1
    525            {
    526              externalEndPointHandlerList = pNewItem;
   \   000038   90....       MOV     DPTR,#externalEndPointHandlerList
   \   00003B   E8           MOV     A,R0
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   E9           MOV     A,R1
   \   00003F   8044         SJMP    ??zcl_addExternalFoundationHandler_2
    527            }
    528            else
    529            {
    530              // make sure no one else tried to register for this endpoint
    531              pLoop = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_1:
   \   000041   E0           MOVX    A,@DPTR
   \   000042   FB           MOV     R3,A
    532              pLoopPrev = externalEndPointHandlerList;
    533          
    534              while ( pLoop != NULL )
    535              {
    536                if ( ( pLoop->zcl_ExternalEndPoint ) == endPointId )
   \                     ??zcl_addExternalFoundationHandler_3:
   \   000043   8A82         MOV     DPL,R2
   \   000045   8B83         MOV     DPH,R3
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   6F           XRL     A,R7
   \   00004C   7004         JNZ     ??zcl_addExternalFoundationHandler_4
    537                {
    538                  return ( false );
   \                     ??zcl_addExternalFoundationHandler_0:
   \   00004E   7900         MOV     R1,#0x0
   \   000050   8036         SJMP    ??zcl_addExternalFoundationHandler_5
    539                }
    540                pLoopPrev = pLoop;
   \                     ??zcl_addExternalFoundationHandler_4:
   \   000052   EA           MOV     A,R2
   \   000053   FC           MOV     R4,A
   \   000054   EB           MOV     A,R3
   \   000055   FD           MOV     R5,A
    541                pLoop = pLoop->next;
   \   000056   8A82         MOV     DPL,R2
   \   000058   8B83         MOV     DPH,R3
   \   00005A   12....       LCALL   ??Subroutine147_0 & 0xFFFF
    542              }
   \                     ??CrossCallReturnLabel_269:
   \   00005D   70E4         JNZ     ??zcl_addExternalFoundationHandler_3
    543          
    544              if ( endPointId == AF_BROADCAST_ENDPOINT )
   \   00005F   74FF         MOV     A,#-0x1
   \   000061   6F           XRL     A,R7
   \   000062   700D         JNZ     ??zcl_addExternalFoundationHandler_6
    545              {
    546                // put new registration at the end of the list
    547                pLoopPrev->next = pNewItem;
   \   000064   8C82         MOV     DPL,R4
   \   000066   8D83         MOV     DPH,R5
   \   000068   E8           MOV     A,R0
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   E9           MOV     A,R1
   \   00006C   12....       LCALL   ?Subroutine33 & 0xFFFF
    548                pNewItem->next = NULL;
    549              }
   \                     ??CrossCallReturnLabel_36:
   \   00006F   8014         SJMP    ??zcl_addExternalFoundationHandler_2
    550              else
    551              {
    552                // put new registration at the front of the list
    553                zclExternalFoundationHandlerList *temp = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_6:
   \   000071   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000074   12....       LCALL   ??Subroutine173_0 & 0xFFFF
    554                externalEndPointHandlerList = pNewItem;
   \                     ??CrossCallReturnLabel_366:
   \   000077   90....       MOV     DPTR,#externalEndPointHandlerList
   \   00007A   12....       LCALL   ??Subroutine144_0 & 0xFFFF
    555                pNewItem->next = temp;
   \                     ??CrossCallReturnLabel_255:
   \   00007D   8882         MOV     DPL,R0
   \   00007F   8983         MOV     DPH,R1
   \   000081   EA           MOV     A,R2
   \   000082   F0           MOVX    @DPTR,A
   \   000083   A3           INC     DPTR
   \   000084   EB           MOV     A,R3
   \                     ??zcl_addExternalFoundationHandler_2:
   \   000085   F0           MOVX    @DPTR,A
    556              }
    557            }
    558          
    559            return ( true );
   \   000086   7901         MOV     R1,#0x1
   \                     ??zcl_addExternalFoundationHandler_5:
   \   000088   02....       LJMP    ?Subroutine3 & 0xFFFF
    560          
    561          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   E4           CLR     A
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine144_0:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine145_0
   \   000001                ; // Fall through to label ??Subroutine145_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine145_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine147_0:
   \   000000   12....       LCALL   ??Subroutine155_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_392:
   \   000003   EA           MOV     A,R2
   \   000004   4B           ORL     A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine155_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine173_0:
   \   000000   12....       LCALL   ??Subroutine155_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_393:
   \   000003   22           RET
    562          
    563          /*********************************************************************
    564           * @fn      zcl_getExternalFoundationHandler
    565           *
    566           * @brief   This function retrieves the Task ID of the task registered
    567           *          to received unhandled incoming Foundation Command/Response messages
    568           *          for a particular End Point ID.
    569           *
    570           * @param   pInMsg - recevied ZCL command
    571           *
    572           * @return  TASK ID of registered task.  If no task is reigistered, it returns
    573           *          TASK_NO_TASK.
    574           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    575          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg )
   \                     zcl_getExternalFoundationHandler:
    576          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    577            zclExternalFoundationHandlerList *pLoop;
    578            uint8 addressedEndPointId = pInMsg->endPoint;
   \   000004   EA           MOV     A,R2
   \   000005   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000008   3B           ADDC    A,R3
   \   000009   F583         MOV     DPH,A
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   FA           MOV     R2,A
    579          
    580            // make sure no one else tried to register for this endpoint
    581            pLoop = externalEndPointHandlerList;
   \   00000D   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000010   8004         SJMP    ??zcl_getExternalFoundationHandler_0
    582          
    583            while ( pLoop != NULL )
    584            {
    585              if ( ( ( pLoop->zcl_ExternalEndPoint ) == addressedEndPointId ) ||
    586                   ( ( pLoop->zcl_ExternalEndPoint ) == AF_BROADCAST_ENDPOINT ) )
    587              {
    588                return ( pLoop->zcl_ExternalTaskID );
    589              }
    590              pLoop = pLoop->next;
   \                     ??zcl_getExternalFoundationHandler_1:
   \   000012   8882         MOV     DPL,R0
   \   000014   8983         MOV     DPH,R1
   \                     ??zcl_getExternalFoundationHandler_0:
   \   000016   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_346:
   \   000019   601C         JZ      ??zcl_getExternalFoundationHandler_2
   \   00001B   8882         MOV     DPL,R0
   \   00001D   8983         MOV     DPH,R1
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FB           MOV     R3,A
   \   000024   EA           MOV     A,R2
   \   000025   6B           XRL     A,R3
   \   000026   6005         JZ      ??zcl_getExternalFoundationHandler_3
   \   000028   74FF         MOV     A,#-0x1
   \   00002A   6B           XRL     A,R3
   \   00002B   70E5         JNZ     ??zcl_getExternalFoundationHandler_1
   \                     ??zcl_getExternalFoundationHandler_3:
   \   00002D   8882         MOV     DPL,R0
   \   00002F   8983         MOV     DPH,R1
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F9           MOV     R1,A
   \   000035   8002         SJMP    ??zcl_getExternalFoundationHandler_4
    591            }
    592          
    593            return ( TASK_NO_TASK );
   \                     ??zcl_getExternalFoundationHandler_2:
   \   000037   79FF         MOV     R1,#-0x1
   \                     ??zcl_getExternalFoundationHandler_4:
   \   000039   02....       LJMP    ?Subroutine0 & 0xFFFF
    594          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine169_0:
   \   000000   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_358:
   \   000003   49           ORL     A,R1
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine140:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_410:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine135:
   \   000000   2414         ADD     A,#0x14
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   22           RET
    595          #endif
    596          
    597          #if !defined ( ZCL_STANDALONE )
    598          /*********************************************************************
    599           * @fn      zcl_HandleExternal
    600           *
    601           * @brief
    602           *
    603           * @param   pInMsg - incoming message to process
    604           *
    605           * @return  TRUE
    606           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    607          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    608          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    609            zclIncomingMsg_t *pCmd;
    610            uint8 taskID;
    611          
    612            taskID = zcl_getExternalFoundationHandler( pInMsg->msg );
   \   000009                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_367:
   \   000010   12....       LCALL   `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000013   E9           MOV     A,R1
   \   000014   F5..         MOV     ?V0,A
    613          
    614            if ( taskID == TASK_NO_TASK )
   \   000016   74FF         MOV     A,#-0x1
   \   000018   65..         XRL     A,?V0
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    615            {
    616              return ( TRUE );
    617            }
    618          
    619            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   00001F                ; Setup parameters for call to function osal_msg_allocate
   \   00001F   7A19         MOV     R2,#0x19
   \   000021   7B00         MOV     R3,#0x0
   \   000023   12....       LCALL   `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
    620            if ( pCmd != NULL )
   \   000026   EA           MOV     A,R2
   \   000027   4B           ORL     A,R3
   \   000028   7003         JNZ     $+5
   \   00002A   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    621            {
    622              // fill in the message
    623              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   00002D   8A82         MOV     DPL,R2
   \   00002F   8B83         MOV     DPH,R3
   \   000031   7434         MOV     A,#0x34
   \   000033   12....       LCALL   ?Subroutine30 & 0xFFFF
    624              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_28:
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   EA           MOV     A,R2
   \   000039   2402         ADD     A,#0x2
   \   00003B   FC           MOV     R4,A
   \   00003C   E4           CLR     A
   \   00003D   3B           ADDC    A,R3
   \   00003E   FD           MOV     R5,A
   \   00003F   7406         MOV     A,#0x6
   \   000041   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    625              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   00004B   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_432:
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   EC           MOV     A,R4
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   ED           MOV     A,R5
   \   00005E   12....       LCALL   ?Subroutine25 & 0xFFFF
    626              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_19:
   \   000061   A3           INC     DPTR
   \   000062   EA           MOV     A,R2
   \   000063   240A         ADD     A,#0xa
   \   000065   FC           MOV     R4,A
   \   000066   E4           CLR     A
   \   000067   3B           ADDC    A,R3
   \   000068   FD           MOV     R5,A
   \   000069   740C         MOV     A,#0xc
   \   00006B   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    627              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   00006E   8E82         MOV     DPL,R6
   \   000070   8F83         MOV     DPH,R7
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F8           MOV     R0,A
   \   000074   A3           INC     DPTR
   \   000075   E0           MOVX    A,@DPTR
   \   000076   C8           XCH     A,R0
   \   000077   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   00007A   38           ADDC    A,R0
   \   00007B   F583         MOV     DPH,A
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   C0E0         PUSH    A
   \   000080   EA           MOV     A,R2
   \   000081   2416         ADD     A,#0x16
   \   000083   F582         MOV     DPL,A
   \   000085   E4           CLR     A
   \   000086   3B           ADDC    A,R3
   \   000087   F583         MOV     DPH,A
   \   000089   D0E0         POP     A
   \   00008B   F0           MOVX    @DPTR,A
    628              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00008C   EE           MOV     A,R6
   \   00008D   240C         ADD     A,#0xc
   \   00008F   F8           MOV     R0,A
   \   000090   E4           CLR     A
   \   000091   3F           ADDC    A,R7
   \   000092   F9           MOV     R1,A
   \   000093   8882         MOV     DPL,R0
   \   000095   8983         MOV     DPH,R1
   \   000097   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_425:
   \   00009A   EA           MOV     A,R2
   \   00009B   2417         ADD     A,#0x17
   \   00009D   F582         MOV     DPL,A
   \   00009F   E4           CLR     A
   \   0000A0   3B           ADDC    A,R3
   \   0000A1   F583         MOV     DPH,A
   \   0000A3   EC           MOV     A,R4
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   ED           MOV     A,R5
   \   0000A7   12....       LCALL   ?Subroutine20 & 0xFFFF
    629              
    630          #ifdef BDB_REPORTING
    631              if(pCmd->zclHdr.commandID == ZCL_CMD_CONFIG_REPORT)
   \                     ??CrossCallReturnLabel_12:
   \   0000AA   FC           MOV     R4,A
   \   0000AB   7406         MOV     A,#0x6
   \   0000AD   6C           XRL     A,R4
   \   0000AE   7005         JNZ     ??zcl_HandleExternal_1
    632              {
    633                bdb_ProcessInConfigReportCmd(pCmd);
   \   0000B0                ; Setup parameters for call to function bdb_ProcessInConfigReportCmd
   \   0000B0   12....       LCALL   `??bdb_ProcessInConfigReportCmd::?relay`; Banked call to: bdb_ProcessInConfigReportCmd
   \   0000B3   8017         SJMP    ??zcl_HandleExternal_0
    634                return TRUE;          
    635              }
    636              if(pCmd->zclHdr.commandID == ZCL_CMD_READ_REPORT_CFG)
   \                     ??zcl_HandleExternal_1:
   \   0000B5   7408         MOV     A,#0x8
   \   0000B7   6C           XRL     A,R4
   \   0000B8   7005         JNZ     ??zcl_HandleExternal_2
    637              {
    638                bdb_ProcessInReadReportCfgCmd(pCmd);
   \   0000BA                ; Setup parameters for call to function bdb_ProcessInReadReportCfgCmd
   \   0000BA   12....       LCALL   `??bdb_ProcessInReadReportCfgCmd::?relay`; Banked call to: bdb_ProcessInReadReportCfgCmd
   \   0000BD   800D         SJMP    ??zcl_HandleExternal_0
    639                return TRUE;
    640              }
    641          #endif
    642              // Application will free the attrCmd buffer
    643              pInMsg->attrCmd = NULL;
   \                     ??zcl_HandleExternal_2:
   \   0000BF   8882         MOV     DPL,R0
   \   0000C1   8983         MOV     DPH,R1
   \   0000C3   E4           CLR     A
   \   0000C4   F0           MOVX    @DPTR,A
   \   0000C5   A3           INC     DPTR
   \   0000C6   F0           MOVX    @DPTR,A
    644          
    645              /* send message through task message */
    646              osal_msg_send( taskID, (uint8 *)pCmd );
   \   0000C7                ; Setup parameters for call to function osal_msg_send
   \   0000C7   A9..         MOV     R1,?V0
   \   0000C9   12....       LCALL   `??osal_msg_send::?relay`; Banked call to: osal_msg_send
    647            }
    648          
    649            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000CC   7901         MOV     R1,#0x1
   \   0000CE   02....       LJMP    ?Subroutine1 & 0xFFFF
    650          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine138:
   \   000000   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine143:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_409:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_421:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine139:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine178_0
   \   000002                ; // Fall through to label ??Subroutine178_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine178_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine179_0
   \   000002                ; // Fall through to label ??Subroutine179_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine179_0:
   \   000000   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_451:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine183_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET
    651          #endif
    652          
    653          
    654          /*********************************************************************
    655           * @fn          zcl_getRawAFMsg
    656           *
    657           * @brief       Call to get original unprocessed AF message
    658           *              (not parsed by ZCL).
    659           *
    660           *   NOTE:  This function can only be called during a ZCL callback function
    661           *          and the calling function must NOT change any data in the message.
    662           *
    663           * @param       none
    664           *
    665           * @return      pointer to original AF message, NULL if not processing
    666           *              AF message.
    667           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    668          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    669          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    670            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_368:
   \   00000A   80..         SJMP    ?Subroutine0
    671          }
    672          
    673          /*********************************************************************
    674           * @fn          zcl_getParsedTransSeqNum
    675           *
    676           * @brief       Call to the get the transaction sequence number from
    677           *              the incoming message.
    678           *
    679           *   NOTE:  This function can only be called during a ZCL callback function
    680           *          and the calling function must NOT change any data in the message.
    681           *
    682           * @param       none
    683           *
    684           * @return      transaction sequence number.
    685           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    686          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    687          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    688            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009                REQUIRE ?Subroutine0
   \   000009                ; // Fall through to label ?Subroutine0
    689          }
    690          
    691          /*********************************************************************
    692           * @fn          zcl_registerPlugin
    693           *
    694           * @brief       Add a Cluster Library handler
    695           *
    696           * @param       startClusterID - starting cluster ID
    697           * @param       endClusterID - ending cluster ID
    698           * @param       pfnHdlr - function pointer to incoming message handler
    699           *
    700           * @return      ZSuccess if OK
    701           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    702          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    703                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    704          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    705            zclLibPlugin_t *pNewItem;
    706            zclLibPlugin_t *pLoop;
    707          
    708            // Fill in the new profile list
    709            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV     R2,#0x8
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    710            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerPlugin_0
    711            {
    712              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   803B         SJMP    ??CrossCallReturnLabel_25
    713            }
    714          
    715            // Fill in the plugin record.
    716            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000024   12....       LCALL   ?Subroutine110 & 0xFFFF
    717            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_199:
   \   000027   A3           INC     DPTR
   \   000028   12....       LCALL   ?Subroutine18 & 0xFFFF
    718            pNewItem->endClusterID = endClusterID;
    719            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_8:
   \   00002B   740C         MOV     A,#0xc
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_369:
   \   000033   8882         MOV     DPL,R0
   \   000035   8983         MOV     DPH,R1
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   12....       LCALL   ??Subroutine160_0 & 0xFFFF
    720          
    721            // Find spot in list
    722            if (  plugins == NULL )
   \                     ??CrossCallReturnLabel_326:
   \   000040   90....       MOV     DPTR,#plugins
   \   000043   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000046   90....       MOV     DPTR,#plugins
   \   000049   6011         JZ      ??zcl_registerPlugin_1
    723            {
    724              plugins = pNewItem;
    725            }
    726            else
    727            {
    728              // Look for end of list
    729              pLoop = plugins;
   \   00004B   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   00004E   8003         SJMP    ??zcl_registerPlugin_2
    730              while ( pLoop->next != NULL )
    731              {
    732                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_3:
   \   000050   EA           MOV     A,R2
   \   000051   FC           MOV     R4,A
   \   000052   EB           MOV     A,R3
    733              }
   \                     ??zcl_registerPlugin_2:
   \   000053   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000056   70F8         JNZ     ??zcl_registerPlugin_3
    734          
    735              // Put new item at end of list
    736              pLoop->next = pNewItem;
   \   000058   8C82         MOV     DPL,R4
   \   00005A   8D83         MOV     DPH,R5
    737            }
   \                     ??zcl_registerPlugin_1:
   \   00005C   12....       LCALL   ?Subroutine28 & 0xFFFF
    738          
    739            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_25:
   \   00005F   02....       LJMP    ?Subroutine1 & 0xFFFF
    740          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E5..         MOV     A,?V1
   \   000002   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000005   EE           MOV     A,R6
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   EF           MOV     A,R7
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   00000A   A3           INC     DPTR
   \   00000B   E5..         MOV     A,?V0
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine147_0
   \   000005                ; // Fall through to label ??Subroutine147_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine160_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET
    741          
    742          #ifdef ZCL_DISCOVER
    743          /*********************************************************************
    744           * @fn          zcl_registerCmdList
    745           *
    746           * @brief       Register a Command List with ZCL Foundation
    747           *
    748           * @param       endpoint - endpoint the attribute list belongs to
    749           * @param       newCmdList - array of command records
    750           *
    751           * @return      ZSuccess if OK
    752           */
    753          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
    754          {
    755            zclCmdRecsList_t *pNewItem;
    756            zclCmdRecsList_t *pLoop;
    757          
    758            // Fill in the new profile list
    759            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    760            if ( pNewItem == NULL )
    761            {
    762              return (ZMemError);
    763            }
    764          
    765            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    766            pNewItem->endpoint = endpoint;
    767            pNewItem->numCommands = cmdListSize;
    768            pNewItem->pCmdRecs = newCmdList;
    769          
    770            // Find spot in list
    771            if ( gpCmdList == NULL )
    772            {
    773              gpCmdList = pNewItem;
    774            }
    775            else
    776            {
    777              // Look for end of list
    778              pLoop = gpCmdList;
    779              while ( pLoop->pNext != NULL )
    780              {
    781                pLoop = pLoop->pNext;
    782              }
    783          
    784              // Put new item at end of list
    785              pLoop->pNext = pNewItem;
    786            }
    787          
    788            return ( ZSuccess );
    789          }
    790          #endif  // ZCL_DISCOVER
    791          
    792          /*********************************************************************
    793           * @fn          zcl_registerAttrList
    794           *
    795           * @brief       Register an Attribute List with ZCL Foundation
    796           *
    797           * @param       endpoint - endpoint the attribute list belongs to
    798           * @param       numAttr - number of attributes in list
    799           * @param       newAttrList - array of Attribute records.
    800           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    801           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    802           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    803           *
    804           * @return      ZSuccess if OK
    805           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    806          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    807          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    808            zclAttrRecsList *pNewItem;
    809            zclAttrRecsList *pLoop;
    810          
    811            // Fill in the new profile list
    812            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A0A         MOV     R2,#0xa
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    813            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerAttrList_0
    814            {
    815              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8033         SJMP    ??CrossCallReturnLabel_26
    816            }
    817          
    818            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000024   12....       LCALL   ?Subroutine14 & 0xFFFF
    819            pNewItem->endpoint = endpoint;
    820            pNewItem->pfnReadWriteCB = NULL;
   \                     ??CrossCallReturnLabel_4:
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   12....       LCALL   ?Subroutine21 & 0xFFFF
    821            pNewItem->numAttributes = numAttr;
   \                     ??CrossCallReturnLabel_14:
   \   00002D   E5..         MOV     A,?V1
   \   00002F   12....       LCALL   ?Subroutine21 & 0xFFFF
    822            pNewItem->attrs = newAttrList;
   \                     ??CrossCallReturnLabel_15:
   \   000032   A3           INC     DPTR
   \   000033   EE           MOV     A,R6
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   EF           MOV     A,R7
   \   000037   F0           MOVX    @DPTR,A
    823          
    824            // Find spot in list
    825            if ( attrList == NULL )
   \   000038   90....       MOV     DPTR,#attrList
   \   00003B   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   00003E   90....       MOV     DPTR,#attrList
   \   000041   6011         JZ      ??zcl_registerAttrList_1
    826            {
    827              attrList = pNewItem;
    828            }
    829            else
    830            {
    831              // Look for end of list
    832              pLoop = attrList;
   \   000043   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000046   8003         SJMP    ??zcl_registerAttrList_2
    833              while ( pLoop->next != NULL )
    834              {
    835                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_3:
   \   000048   EA           MOV     A,R2
   \   000049   FC           MOV     R4,A
   \   00004A   EB           MOV     A,R3
    836              }
   \                     ??zcl_registerAttrList_2:
   \   00004B   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   00004E   70F8         JNZ     ??zcl_registerAttrList_3
    837          
    838              // Put new item at end of list
    839              pLoop->next = pNewItem;
   \   000050   8C82         MOV     DPL,R4
   \   000052   8D83         MOV     DPH,R5
    840            }
   \                     ??zcl_registerAttrList_1:
   \   000054   12....       LCALL   ?Subroutine28 & 0xFFFF
    841          
    842            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_26:
   \   000057   80..         SJMP    ?Subroutine1
    843          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET
    844          
    845          /*********************************************************************
    846           * @fn          zcl_registerClusterOptionList
    847           *
    848           * @brief       Register a Cluster Option List with ZCL Foundation
    849           *
    850           * @param       endpoint - endpoint the option list belongs to
    851           * @param       numOption - number of options in list
    852           * @param       optionList - array of cluster option records.
    853           *
    854           *              NOTE: This API should be called to enable 'Application
    855           *                    Link Key' security and/or 'APS ACK' for a specific
    856           *                    Cluster. The 'Application Link Key' is discarded
    857           *                    if security isn't enabled on the device.
    858           *                    The default behavior is 'Network Key' when security
    859           *                    is enabled and no 'APS ACK' for the ZCL messages.
    860           *
    861           * @return      ZSuccess if OK
    862           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    863          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    864          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    865            zclClusterOptionList *pNewItem;
    866            zclClusterOptionList *pLoop;
    867          
    868            // Fill in the new profile list
    869            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    870            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerClusterOptionList_0
    871            {
    872              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8025         SJMP    ??CrossCallReturnLabel_27
    873            }
    874          
    875            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL   ?Subroutine14 & 0xFFFF
    876            pNewItem->endpoint = endpoint;
    877            pNewItem->numOptions = numOption;
   \                     ??CrossCallReturnLabel_5:
   \   000027   12....       LCALL   ?Subroutine18 & 0xFFFF
    878            pNewItem->options = optionList;
    879          
    880            // Find spot in list
    881            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_9:
   \   00002A   90....       MOV     DPTR,#clusterOptionList
   \   00002D   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000030   90....       MOV     DPTR,#clusterOptionList
   \   000033   6011         JZ      ??zcl_registerClusterOptionList_1
    882            {
    883              clusterOptionList = pNewItem;
    884            }
    885            else
    886            {
    887              // Look for end of list
    888              pLoop = clusterOptionList;
   \   000035   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000038   8003         SJMP    ??zcl_registerClusterOptionList_2
    889              while ( pLoop->next != NULL )
    890              {
    891                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_3:
   \   00003A   EA           MOV     A,R2
   \   00003B   FC           MOV     R4,A
   \   00003C   EB           MOV     A,R3
    892              }
   \                     ??zcl_registerClusterOptionList_2:
   \   00003D   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000040   70F8         JNZ     ??zcl_registerClusterOptionList_3
    893          
    894              // Put new item at end of list
    895              pLoop->next = pNewItem;
   \   000042   8C82         MOV     DPL,R4
   \   000044   8D83         MOV     DPH,R5
    896            }
   \                     ??zcl_registerClusterOptionList_1:
   \   000046   12....       LCALL   ?Subroutine28 & 0xFFFF
    897          
    898            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_27:
   \   000049                REQUIRE ?Subroutine1
   \   000049                ; // Fall through to label ?Subroutine1
    899          }
    900          
    901          /*********************************************************************
    902           * @fn          zcl_registerValidateAttrData
    903           *
    904           * @brief       Add a validation function for attribute data
    905           *
    906           * @param       pfnValidateAttrData - function pointer to validate routine
    907           *
    908           * @return      ZSuccess if OK
    909           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    910          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    911          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    912            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   12....       LCALL   ??Subroutine160_0 & 0xFFFF
    913          
    914            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_327:
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   02....       LJMP    ?Subroutine0 & 0xFFFF
    915          }
    916          
    917          /*********************************************************************
    918           * @fn          zcl_registerReadWriteCB
    919           *
    920           * @brief       Register the application's callback function to read/write
    921           *              attribute data, and authorize read/write operation.
    922           *
    923           *              Note: The pfnReadWriteCB callback function is only required
    924           *                    when the attribute data format is unknown to ZCL. The
    925           *                    callback function gets called when the pointer 'dataPtr'
    926           *                    to the attribute value is NULL in the attribute database
    927           *                    registered with the ZCL.
    928           *
    929           *              Note: The pfnAuthorizeCB callback function is only required
    930           *                    when the Read/Write operation on an attribute requires
    931           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    932           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    933           *
    934           * @param       endpoint - application's endpoint
    935           * @param       pfnReadWriteCB - function pointer to read/write routine
    936           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    937           *
    938           * @return      ZSuccess if successful. ZFailure, otherwise.
    939           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    940          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    941                                             zclAuthorizeCB_t pfnAuthorizeCB )
    942          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
    943            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV     ?V4,R2
   \   000012   8B..         MOV     ?V5,R3
   \   000014   A8..         MOV     R0,?V4
   \   000016   A9..         MOV     R1,?V5
    944          
    945            if ( pRec != NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   6019         JZ      ??zcl_registerReadWriteCB_0
    946            {
    947              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   12....       LCALL   ?Subroutine25 & 0xFFFF
    948              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \                     ??CrossCallReturnLabel_20:
   \   00002A   E5..         MOV     A,?V0
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   E5..         MOV     A,?V1
   \   000030   F0           MOVX    @DPTR,A
    949          
    950              return ( ZSuccess );
   \   000031   7900         MOV     R1,#0x0
   \   000033   8002         SJMP    ??zcl_registerReadWriteCB_1
    951            }
    952          
    953            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000035   7901         MOV     R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   000037                REQUIRE ?Subroutine4
   \   000037                ; // Fall through to label ?Subroutine4
    954          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    955          
    956          /*********************************************************************
    957           * @fn      zcl_DeviceOperational
    958           *
    959           * @brief   Used to see whether or not the device can send or respond
    960           *          to application level commands.
    961           *
    962           * @param   srcEP - source endpoint
    963           * @param   clusterID - cluster ID
    964           * @param   frameType - command type
    965           * @param   cmd - command ID
    966           *
    967           * @return  TRUE if device is operational, FALSE otherwise
    968           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    969          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    970                                              uint8 frameType, uint8 cmd, uint16 profileID )
    971          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FF           MOV     R7,A
    972            zclAttrRec_t attrRec;
    973            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7401         MOV     A,#0x1
   \   000016   F0           MOVX    @DPTR,A
    974          
    975            (void)profileID;  // Intentionally unreferenced parameter
    976          
    977            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    978            // cannot send or respond to application level commands, other than commands
    979            // to read or write attributes. Note that the Identify cluster cannot be
    980            // disabled, and remains functional regardless of this setting.
    981            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000017   EF           MOV     A,R7
   \   000018   7006         JNZ     ??zcl_DeviceOperational_0
   \   00001A   ED           MOV     A,R5
   \   00001B   C3           CLR     C
   \   00001C   9406         SUBB    A,#0x6
   \   00001E   4050         JC      ??zcl_DeviceOperational_1
    982            {
    983              return ( TRUE );
    984            }
    985          
    986            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   4B           ORL     A,R3
   \   000024   604A         JZ      ??zcl_DeviceOperational_1
    987            {
    988              return ( TRUE );
    989            }
    990          
    991            // Is device enabled?
    992            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    993                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000026                ; Setup parameters for call to function zclFindAttrRec
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP100_8
   \   00002B   88..         MOV     ?V2,R0
   \   00002D   89..         MOV     ?V3,R1
   \   00002F   78..         MOV     R0,#?V2
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   7C12         MOV     R4,#0x12
   \   000036   7D00         MOV     R5,#0x0
   \   000038   7A00         MOV     R2,#0x0
   \   00003A   7B00         MOV     R3,#0x0
   \   00003C   EE           MOV     A,R6
   \   00003D   F9           MOV     R1,A
   \   00003E   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   601C         JZ      ??zcl_DeviceOperational_2
    994            {
    995          #ifdef ZCL_READ
    996              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000049                ; Setup parameters for call to function zclReadAttrData
   \   000049   E4           CLR     A
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   F5..         MOV     ?V3,A
   \   00004E   78..         MOV     R0,#?V2
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   7403         MOV     A,#0x3
   \   000055   12....       LCALL   ?XSTACK_DISP102_8
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?XSTACK_DISP101_8
   \   00005D   12....       LCALL   `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   000060   7402         MOV     A,#0x2
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
    997          #endif
    998            }
    999          
   1000            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_2:
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6401         XRL     A,#0x1
   \   00006E   7004         JNZ     ??zcl_DeviceOperational_3
   \                     ??zcl_DeviceOperational_1:
   \   000070   7901         MOV     R1,#0x1
   \   000072   8002         SJMP    ??zcl_DeviceOperational_4
   \                     ??zcl_DeviceOperational_3:
   \   000074   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_4:
   \   000076   7409         MOV     A,#0x9
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007B   02....       LJMP    ?Subroutine1 & 0xFFFF
   1001          }
   1002          
   1003          /*********************************************************************
   1004           * @fn      zcl_SendCommand
   1005           *
   1006           * @brief   Used to send Profile and Cluster Specific Command messages.
   1007           *
   1008           *          NOTE: The calling application is responsible for incrementing
   1009           *                the Sequence Number.
   1010           *
   1011           * @param   srcEp - source endpoint
   1012           * @param   destAddr - destination address
   1013           * @param   clusterID - cluster ID
   1014           * @param   cmd - command ID
   1015           * @param   specific - whether the command is Cluster Specific
   1016           * @param   direction - client/server direction of the command
   1017           * @param   disableDefaultRsp - disable Default Response command
   1018           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1019           * @param   seqNumber - identification number for the transaction
   1020           * @param   cmdFormatLen - length of the command to be sent
   1021           * @param   cmdFormat - command to be sent
   1022           *
   1023           * @return  ZSuccess if OK
   1024           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1025          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
   1026                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
   1027                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
   1028                                     uint16 cmdFormatLen, uint8 *cmdFormat )
   1029          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V10,R1
   \   00000C   8A..         MOV     ?V14,R2
   \   00000E   8B..         MOV     ?V15,R3
   \   000010   8C..         MOV     ?V0,R4
   \   000012   8D..         MOV     ?V1,R5
   1030            endPointDesc_t *epDesc;
   1031            zclFrameHdr_t hdr;
   1032            uint8 *msgBuf;
   1033            uint16 msgLen;
   1034            uint8 *pBuf;
   1035            uint8 options;
   1036            ZStatus_t status;
   1037          
   1038            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL   `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV     ?V12,R2
   \   000019   8B..         MOV     ?V13,R3
   1039            if ( epDesc == NULL )
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V13
   \   00001E   7005         JNZ     ??zcl_SendCommand_0
   1040            {
   1041              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV     R1,#0x2
   \   000022   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
   1042            }
   1043          
   1044          #if defined ( INTER_PAN )
   1045            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
   1046            {
   1047              options = AF_TX_OPTIONS_NONE;
   1048            }
   1049            else
   1050          #endif
   1051            {
   1052              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000025                ; Setup parameters for call to function zclGetClusterOption
   \   000025   AA..         MOV     R2,?V0
   \   000027   AB..         MOV     R3,?V1
   \   000029   A9..         MOV     R1,?V10
   \   00002B   12....       LCALL   `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   00002E   E9           MOV     A,R1
   \   00002F   F5..         MOV     ?V7,A
   1053          
   1054              // The cluster might not have been defined to use security but if this message
   1055              // is in response to another message that was using APS security this message
   1056              // will be sent with APS security
   1057              if ( !( options & AF_EN_SECURITY ) )
   \   000031   A2E6         MOV     C,0xE0 /* A   */.6
   \   000033   401C         JC      ??zcl_SendCommand_2
   1058              {
   1059                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000035   90....       MOV     DPTR,#rawAFMsg
   \   000038   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   1060          
   1061                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_347:
   \   00003B   6014         JZ      ??zcl_SendCommand_2
   \   00003D   E8           MOV     A,R0
   \   00003E   2419         ADD     A,#0x19
   \   000040   F582         MOV     DPL,A
   \   000042   E4           CLR     A
   \   000043   39           ADDC    A,R1
   \   000044   F583         MOV     DPH,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   6401         XRL     A,#0x1
   \   000049   7006         JNZ     ??zcl_SendCommand_2
   1062                {
   1063                  options |= AF_EN_SECURITY;
   \   00004B   E5..         MOV     A,?V7
   \   00004D   D2E6         SETB    0xE0 /* A   */.6
   \   00004F   F5..         MOV     ?V7,A
   1064                }
   1065              }
   1066            }
   1067          
   1068            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_2:
   \   000051                ; Setup parameters for call to function osal_memset
   \   000051   7C06         MOV     R4,#0x6
   \   000053   7D00         MOV     R5,#0x0
   \   000055   7900         MOV     R1,#0x0
   \   000057   AA..         MOV     R2,?XSP + 0
   \   000059   AB..         MOV     R3,?XSP + 1
   \   00005B   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   1069          
   1070            // Not Profile wide command (like READ, WRITE)
   1071            if ( specific )
   \   00005E   741F         MOV     A,#0x1f
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000066   6009         JZ      ??zcl_SendCommand_3
   1072            {
   1073              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000068   E0           MOVX    A,@DPTR
   \   000069   54FC         ANL     A,#0xfc
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   4401         ORL     A,#0x1
   \   00006F   8003         SJMP    ??zcl_SendCommand_4
   1074            }
   1075            else
   1076            {
   1077              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_3:
   \   000071   E0           MOVX    A,@DPTR
   \   000072   54FC         ANL     A,#0xfc
   1078            }
   \                     ??zcl_SendCommand_4:
   \   000074   12....       LCALL   ?Subroutine27 & 0xFFFF
   1079          
   1080            if ( ( epDesc->simpleDesc == NULL ) ||
   1081                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
   1082                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??CrossCallReturnLabel_23:
   \   000077   12....       LCALL   ??Subroutine168_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   00007A   602B         JZ      ??zcl_SendCommand_5
   \   00007C   741E         MOV     A,#0x1e
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E0           MOVX    A,@DPTR
   \   000082   FE           MOV     R6,A
   \   000083                ; Setup parameters for call to function zcl_DeviceOperational
   \   000083   8882         MOV     DPL,R0
   \   000085   8983         MOV     DPH,R1
   \   000087   A3           INC     DPTR
   \   000088   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00008B   EE           MOV     A,R6
   \   00008C   FD           MOV     R5,A
   \   00008D   7402         MOV     A,#0x2
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   E0           MOVX    A,@DPTR
   \   000093   5403         ANL     A,#0x3
   \   000095   FC           MOV     R4,A
   \   000096   AA..         MOV     R2,?V0
   \   000098   AB..         MOV     R3,?V1
   \   00009A   A9..         MOV     R1,?V10
   \   00009C   12....       LCALL   `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   00009F   7402         MOV     A,#0x2
   \   0000A1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A4   E9           MOV     A,R1
   \   0000A5   7005         JNZ     ??zcl_SendCommand_6
   1083            {
   1084              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   0000A7   7901         MOV     R1,#0x1
   \   0000A9   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
   1085            }
   \                     ??zcl_SendCommand_6:
   \   0000AC   7422         MOV     A,#0x22
   \   0000AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B1   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   1086          
   1087            // Fill in the Maufacturer Code
   1088            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_348:
   \   0000B4   6012         JZ      ??CrossCallReturnLabel_256
   1089            {
   1090              hdr.fc.manuSpecific = 1;
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   4404         ORL     A,#0x4
   \   0000BF   F0           MOVX    @DPTR,A
   1091              hdr.manuCode = manuCode;
   \   0000C0   7402         MOV     A,#0x2
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   1092            }
   1093          
   1094            // Set the Command Direction
   1095            if ( direction )
   \                     ??CrossCallReturnLabel_256:
   \   0000C8   7420         MOV     A,#0x20
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   0000D0   6005         JZ      ??zcl_SendCommand_7
   1096            {
   1097              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   4408         ORL     A,#0x8
   \   0000D5   8003         SJMP    ??zcl_SendCommand_8
   1098            }
   1099            else
   1100            {
   1101              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_8:
   \   0000DA   F0           MOVX    @DPTR,A
   1102            }
   1103          
   1104            // Set the Disable Default Response field
   1105            if ( disableDefaultRsp )
   \   0000DB   7421         MOV     A,#0x21
   \   0000DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E0   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   0000E3   6005         JZ      ??zcl_SendCommand_9
   1106            {
   1107              hdr.fc.disableDefaultRsp = 1;
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   4410         ORL     A,#0x10
   \   0000E8   8003         SJMP    ??zcl_SendCommand_10
   1108            }
   1109            else
   1110            {
   1111              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_10:
   \   0000ED   F0           MOVX    @DPTR,A
   1112            }
   1113          
   1114            // Fill in the Transaction Sequence Number
   1115            hdr.transSeqNum = seqNum;
   \   0000EE   7424         MOV     A,#0x24
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   C0E0         PUSH    A
   \   0000F6   7404         MOV     A,#0x4
   \   0000F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FB   D0E0         POP     A
   \   0000FD   F0           MOVX    @DPTR,A
   1116          
   1117            // Fill in the command
   1118            hdr.commandID = cmd;
   \   0000FE   7405         MOV     A,#0x5
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   EE           MOV     A,R6
   \   000104   F0           MOVX    @DPTR,A
   1119          
   1120            // calculate the needed buffer size
   1121            msgLen = zclCalcHdrSize( &hdr );
   \   000105   7803         MOV     R0,#0x3
   \   000107   85..82       MOV     DPL,?XSP + 0
   \   00010A   85..83       MOV     DPH,?XSP + 1
   \   00010D   E0           MOVX    A,@DPTR
   \   00010E   5404         ANL     A,#0x4
   \   000110   6002         JZ      ??zcl_SendCommand_11
   \   000112   7805         MOV     R0,#0x5
   \                     ??zcl_SendCommand_11:
   \   000114   7425         MOV     A,#0x25
   \   000116   12....       LCALL   ?XSTACK_DISP0_8
   \   000119   12....       LCALL   ?Subroutine44 & 0xFFFF
   1122            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_49:
   \   00011C   E8           MOV     A,R0
   \   00011D   25..         ADD     A,?V8
   \   00011F   FE           MOV     R6,A
   \   000120   E4           CLR     A
   \   000121   35..         ADDC    A,?V9
   \   000123   FF           MOV     R7,A
   1123          
   1124            // Allocate the buffer needed
   1125            msgBuf = zcl_mem_alloc( msgLen );
   \   000124                ; Setup parameters for call to function osal_mem_alloc
   \   000124   EE           MOV     A,R6
   \   000125   FA           MOV     R2,A
   \   000126   EF           MOV     A,R7
   \   000127   FB           MOV     R3,A
   \   000128   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00012B   8A..         MOV     ?V2,R2
   \   00012D   8B..         MOV     ?V3,R3
   1126            if ( msgBuf != NULL )
   \   00012F   EA           MOV     A,R2
   \   000130   45..         ORL     A,?V3
   \   000132   6065         JZ      ??zcl_SendCommand_12
   1127            {
   1128              // Fill in the ZCL Header
   1129              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   000134                ; Setup parameters for call to function zclBuildHdr
   \   000134   AC..         MOV     R4,?V2
   \   000136   AD..         MOV     R5,?V3
   \   000138   AA..         MOV     R2,?XSP + 0
   \   00013A   AB..         MOV     R3,?XSP + 1
   \   00013C   12....       LCALL   `??zclBuildHdr::?relay`; Banked call to: zclBuildHdr
   1130          
   1131              // Fill in the command frame
   1132              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   00013F                ; Setup parameters for call to function osal_memcpy
   \   00013F   7427         MOV     A,#0x27
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00014A   AC..         MOV     R4,?V8
   \   00014C   AD..         MOV     R5,?V9
   \   00014E   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000151   7403         MOV     A,#0x3
   \   000153   12....       LCALL   ?DEALLOC_XSTACK8
   1133          
   1134              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
   1135                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   000156                ; Setup parameters for call to function AF_DataRequest
   \   000156   75..1E       MOV     ?V4,#0x1e
   \   000159   78..         MOV     R0,#?V4
   \   00015B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015E   75....       MOV     ?V4,#zcl_TransID & 0xff
   \   000161   75....       MOV     ?V5,#(zcl_TransID >> 8) & 0xff
   \   000164   78..         MOV     R0,#?V4
   \   000166   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000169   78..         MOV     R0,#?V2
   \   00016B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016E   8E..         MOV     ?V4,R6
   \   000170   8F..         MOV     ?V5,R7
   \   000172   78..         MOV     R0,#?V4
   \   000174   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000177   78..         MOV     R0,#?V0
   \   000179   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017C   A9..         MOV     R1,?V7
   \   00017E   AC..         MOV     R4,?V12
   \   000180   AD..         MOV     R5,?V13
   \   000182   AA..         MOV     R2,?V14
   \   000184   AB..         MOV     R3,?V15
   \   000186   12....       LCALL   `??AF_DataRequest::?relay`; Banked call to: AF_DataRequest
   \   000189   7409         MOV     A,#0x9
   \   00018B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00018E   E9           MOV     A,R1
   \   00018F   FE           MOV     R6,A
   1136              zcl_mem_free ( msgBuf );
   \   000190                ; Setup parameters for call to function osal_mem_free
   \   000190   AA..         MOV     R2,?V2
   \   000192   AB..         MOV     R3,?V3
   \   000194   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000197   8002         SJMP    ??zcl_SendCommand_13
   1137            }
   1138            else
   1139            {
   1140              status = ZMemError;
   \                     ??zcl_SendCommand_12:
   \   000199   7E10         MOV     R6,#0x10
   1141            }
   1142          
   1143            return ( status );
   \                     ??zcl_SendCommand_13:
   \   00019B   EE           MOV     A,R6
   \   00019C   F9           MOV     R1,A
   \                     ??zcl_SendCommand_1:
   \   00019D   7406         MOV     A,#0x6
   \   00019F   02....       LJMP    ?Subroutine5 & 0xFFFF
   1144          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine168_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine169_0
   \   000001                ; // Fall through to label ??Subroutine169_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000003   75..00       MOV     ?V6,#0x0
   \   000006   78..         MOV     R0,#?V4
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V12
   \   000004   85..83       MOV     DPH,?V13
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   1145          
   1146          #ifdef ZCL_READ
   1147          /*********************************************************************
   1148           * @fn      zcl_SendRead
   1149           *
   1150           * @brief   Send a Read command
   1151           *
   1152           * @param   srcEP - Application's endpoint
   1153           * @param   dstAddr - destination address
   1154           * @param   clusterID - cluster ID
   1155           * @param   readCmd - read command to be sent
   1156           * @param   direction - direction of the command
   1157           * @param   seqNum - transaction sequence number
   1158           *
   1159           * @return  ZSuccess if OK
   1160           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1161          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
   1162                                  uint16 clusterID, zclReadCmd_t *readCmd,
   1163                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
   1164          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine45 & 0xFFFF
   1165            uint16 dataLen;
   1166            uint8 *buf;
   1167            uint8 *pBuf;
   1168            ZStatus_t status;
   1169          
   1170            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_55:
   \   000017   25E0         ADD     A,0xE0 /* A   */
   \   000019   FE           MOV     R6,A
   \   00001A   E4           CLR     A
   \   00001B   33           RLC     A
   \   00001C   FF           MOV     R7,A
   1171          
   1172            buf = zcl_mem_alloc( dataLen );
   \   00001D                ; Setup parameters for call to function osal_mem_alloc
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000024   8A..         MOV     ?V0,R2
   \   000026   8B..         MOV     ?V1,R3
   1173            if ( buf != NULL )
   \   000028   EA           MOV     A,R2
   \   000029   45..         ORL     A,?V1
   \   00002B   7003         JNZ     $+5
   \   00002D   02....       LJMP    ??zcl_SendRead_0 & 0xFFFF
   1174            {
   1175              uint8 i;
   1176          
   1177              // Load the buffer - serially
   1178              pBuf = buf;
   1179              for (i = 0; i < readCmd->numAttr; i++)
   \   000030   7C00         MOV     R4,#0x0
   \   000032   801E         SJMP    ??zcl_SendRead_1
   1180              {
   1181                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_2:
   \   000034   EC           MOV     A,R4
   \   000035   25E0         ADD     A,0xE0 /* A   */
   \   000037   F8           MOV     R0,A
   \   000038   E4           CLR     A
   \   000039   33           RLC     A
   \   00003A   F9           MOV     R1,A
   \   00003B   12....       LCALL   ?Subroutine131 & 0xFFFF
   1182                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   1183              }
   \                     ??CrossCallReturnLabel_264:
   \   00003E   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000041   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000044   8A82         MOV     DPL,R2
   \   000046   8B83         MOV     DPH,R3
   \   000048   A3           INC     DPTR
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   EA           MOV     A,R2
   \   00004B   2402         ADD     A,#0x2
   \   00004D   FA           MOV     R2,A
   \   00004E   5001         JNC     ??zcl_SendRead_3
   \   000050   0B           INC     R3
   \                     ??zcl_SendRead_3:
   \   000051   0C           INC     R4
   \                     ??zcl_SendRead_1:
   \   000052   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000055   40DD         JC      ??zcl_SendRead_2
   1184          
   1185              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
   1186                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000057                ; Setup parameters for call to function zcl_SendCommand
   \   000057   78..         MOV     R0,#?V0
   \   000059   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005C   8E..         MOV     ?V4,R6
   \   00005E   8F..         MOV     ?V5,R7
   \   000060   78..         MOV     R0,#?V4
   \   000062   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000065   741C         MOV     A,#0x1c
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000070   E4           CLR     A
   \   000071   F5..         MOV     ?V4,A
   \   000073   F5..         MOV     ?V5,A
   \   000075   78..         MOV     R0,#?V4
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   741E         MOV     A,#0x1e
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000085   741E         MOV     A,#0x1e
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000090   75..00       MOV     ?V3,#0x0
   \   000093   78..         MOV     R0,#?V3
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000098   78..         MOV     R0,#?V3
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009D   AC..         MOV     R4,?V6
   \   00009F   AD..         MOV     R5,?V7
   \   0000A1   AA..         MOV     R2,?V8
   \   0000A3   AB..         MOV     R3,?V9
   \   0000A5   A9..         MOV     R1,?V2
   \   0000A7   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000AA   740B         MOV     A,#0xb
   \   0000AC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AF   E9           MOV     A,R1
   \   0000B0   FE           MOV     R6,A
   1187              zcl_mem_free( buf );
   \   0000B1                ; Setup parameters for call to function osal_mem_free
   \   0000B1   AA..         MOV     R2,?V0
   \   0000B3   AB..         MOV     R3,?V1
   \   0000B5   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000B8   8002         SJMP    ??zcl_SendRead_4
   1188            }
   1189            else
   1190            {
   1191              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   0000BA   7E10         MOV     R6,#0x10
   1192            }
   1193          
   1194            return ( status );
   \                     ??zcl_SendRead_4:
   \   0000BC   02....       LJMP    ?Subroutine6 & 0xFFFF
   1195          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   E5..         MOV     A,?V4
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   E5..         MOV     A,?V5
   \   000007                REQUIRE ??Subroutine146_0
   \   000007                ; // Fall through to label ??Subroutine146_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine146_0:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   A882         MOV     R0,DPL
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine148_0
   \   000006                ; // Fall through to label ??Subroutine148_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine148_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   EC           MOV     A,R4
   \   000003   C3           CLR     C
   \   000004   98           SUBB    A,R0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V3,A
   \   000003   78..         MOV     R0,#?V3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   F583         MOV     DPH,A
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002                REQUIRE ??Subroutine150_0
   \   000002                ; // Fall through to label ??Subroutine150_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine150_0:
   \   000000   7F0C         MOV     R7,#0xc
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine151_0:
   \   000000   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL   ??Subroutine151_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000003   22           RET
   1196          
   1197          /*********************************************************************
   1198           * @fn      zcl_SendReadRsp
   1199           *
   1200           * @brief   Send a Read Response command.
   1201           *
   1202           * @param   srcEP - Application's endpoint
   1203           * @param   dstAddr - destination address
   1204           * @param   clusterID - cluster ID
   1205           * @param   readRspCmd - read response command to be sent
   1206           * @param   direction - direction of the command
   1207           * @param   seqNum - transaction sequence number
   1208           *
   1209           * @return  ZSuccess if OK
   1210           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1211          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
   1212                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1213                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1214          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V3,R1
   \   00000C   8A..         MOV     ?V12,R2
   \   00000E   8B..         MOV     ?V13,R3
   \   000010   8C..         MOV     ?V6,R4
   \   000012   8D..         MOV     ?V7,R5
   1215            uint8 *buf;
   1216            uint16 len = 0;
   \   000014   7E00         MOV     R6,#0x0
   \   000016   7F00         MOV     R7,#0x0
   1217            ZStatus_t status;
   1218            uint8 i;
   1219          
   1220            // calculate the size of the command
   1221            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000018   75..00       MOV     ?V2,#0x0
   \   00001B   7418         MOV     A,#0x18
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000023   8011         SJMP    ??zcl_SendReadRsp_0
   1222            {
   1223              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1224          
   1225              len += 2 + 1; // Attribute ID + Status
   1226          
   1227              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1228              {
   1229                len++; // Attribute Data Type length
   1230          
   1231                // Attribute Data length
   1232                if ( statusRec->data != NULL )
   1233                {
   1234                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1235                }
   1236                else
   1237                {
   1238                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000025                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000025   12....       LCALL   ?Subroutine68 & 0xFFFF
   1239                }
   \                     ??CrossCallReturnLabel_111:
   \   000028   12....       LCALL   `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_2:
   \   00002B   8B..         MOV     ?V1,R3
   \   00002D   EE           MOV     A,R6
   \   00002E   2A           ADD     A,R2
   \   00002F   FE           MOV     R6,A
   \   000030   EF           MOV     A,R7
   \   000031   35..         ADDC    A,?V1
   \   000033   FF           MOV     R7,A
   \                     ??zcl_SendReadRsp_3:
   \   000034   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_0:
   \   000036   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_415:
   \   000039   5033         JNC     ??zcl_SendReadRsp_4
   \   00003B   E5..         MOV     A,?V2
   \   00003D   75F006       MOV     B,#0x6
   \   000040   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   000043   2403         ADD     A,#0x3
   \   000045   FE           MOV     R6,A
   \   000046   E4           CLR     A
   \   000047   3F           ADDC    A,R7
   \   000048   FF           MOV     R7,A
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   70E6         JNZ     ??zcl_SendReadRsp_3
   \   00004E   0E           INC     R6
   \   00004F   EE           MOV     A,R6
   \   000050   7001         JNZ     ??zcl_SendReadRsp_5
   \   000052   0F           INC     R7
   \                     ??zcl_SendReadRsp_5:
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   00005E   8882         MOV     DPL,R0
   \   000060   8983         MOV     DPH,R1
   \   000062   60C1         JZ      ??zcl_SendReadRsp_1
   \   000064                ; Setup parameters for call to function zclGetAttrDataLength
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   F9           MOV     R1,A
   \   000069   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00006C   80BD         SJMP    ??zcl_SendReadRsp_2
   1240              }
   1241            }
   1242          
   1243            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_4:
   \   00006E                ; Setup parameters for call to function osal_mem_alloc
   \   00006E   EE           MOV     A,R6
   \   00006F   FA           MOV     R2,A
   \   000070   EF           MOV     A,R7
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000075   8A..         MOV     ?V0,R2
   \   000077   8B..         MOV     ?V1,R3
   \   000079   8A..         MOV     ?V4,R2
   \   00007B   8B..         MOV     ?V5,R3
   1244            if ( buf != NULL )
   \   00007D   EA           MOV     A,R2
   \   00007E   45..         ORL     A,?V5
   \   000080   7003         JNZ     $+5
   \   000082   02....       LJMP    ??zcl_SendReadRsp_6 & 0xFFFF
   1245            {
   1246              // Load the buffer - serially
   1247              uint8 *pBuf = buf;
   1248          
   1249              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000085   75..00       MOV     ?V2,#0x0
   \   000088   8036         SJMP    ??zcl_SendReadRsp_7
   1250              {
   1251                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1252          
   1253                *pBuf++ = LO_UINT16( statusRec->attrID );
   1254                *pBuf++ = HI_UINT16( statusRec->attrID );
   1255                *pBuf++ = statusRec->status;
   1256          
   1257                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1258                {
   1259                  *pBuf++ = statusRec->dataType;
   1260          
   1261                  if ( statusRec->data != NULL )
   1262                  {
   1263                    // Copy attribute data to the buffer to be sent out
   1264                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1265                  }
   1266                  else
   1267                  {
   1268                    uint16 dataLen;
   1269          
   1270                    // Read attribute data directly into the buffer to be sent out
   1271                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_8:
   \   00008A                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   00008A   A8..         MOV     R0,?XSP + 0
   \   00008C   A9..         MOV     R1,?XSP + 1
   \   00008E   88..         MOV     ?V10,R0
   \   000090   89..         MOV     ?V11,R1
   \   000092   78..         MOV     R0,#?V10
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000097   78..         MOV     R0,#?V0
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   8A82         MOV     DPL,R2
   \   00009E   8B83         MOV     DPH,R3
   \   0000A0   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   0000A3   12....       LCALL   `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   12....       LCALL   ?DEALLOC_XSTACK8
   1272                    pBuf += dataLen;
   \   0000AB   85..82       MOV     DPL,?XSP + 0
   \   0000AE   85..83       MOV     DPH,?XSP + 1
   \   0000B1   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   1273                  }
   \                     ??CrossCallReturnLabel_401:
   \   0000B4   E5..         MOV     A,?V0
   \   0000B6   28           ADD     A,R0
   \   0000B7   F5..         MOV     ?V0,A
   \   0000B9   E5..         MOV     A,?V1
   \   0000BB   39           ADDC    A,R1
   \   0000BC   F5..         MOV     ?V1,A
   \                     ??zcl_SendReadRsp_9:
   \   0000BE   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_7:
   \   0000C0   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_416:
   \   0000C3   506C         JNC     ??zcl_SendReadRsp_10
   \   0000C5   E5..         MOV     A,?V2
   \   0000C7   75F006       MOV     B,#0x6
   \   0000CA   A4           MUL     AB
   \   0000CB   F8           MOV     R0,A
   \   0000CC   A9F0         MOV     R1,B
   \   0000CE   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   0000D1   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   0000D4   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   0000D7   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   0000DA   A3           INC     DPTR
   \   0000DB   F0           MOVX    @DPTR,A
   \   0000DC   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   0000DF   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   0000E2   F0           MOVX    @DPTR,A
   \   0000E3   E5..         MOV     A,?V0
   \   0000E5   2403         ADD     A,#0x3
   \   0000E7   F5..         MOV     ?V0,A
   \   0000E9   5002         JNC     ??zcl_SendReadRsp_11
   \   0000EB   05..         INC     ?V1
   \                     ??zcl_SendReadRsp_11:
   \   0000ED   8882         MOV     DPL,R0
   \   0000EF   8983         MOV     DPH,R1
   \   0000F1   E0           MOVX    A,@DPTR
   \   0000F2   70CA         JNZ     ??zcl_SendReadRsp_9
   \   0000F4   EA           MOV     A,R2
   \   0000F5   2403         ADD     A,#0x3
   \   0000F7   08           INC     R0
   \   0000F8   12....       LCALL   ??Subroutine163_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   0000FB   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   0000FE   F0           MOVX    @DPTR,A
   \   0000FF   A3           INC     DPTR
   \   000100   8582..       MOV     ?V0,DPL
   \   000103   8583..       MOV     ?V1,DPH
   \   000106   8A82         MOV     DPL,R2
   \   000108   8B83         MOV     DPH,R3
   \   00010A   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_433:
   \   00010D   8C82         MOV     DPL,R4
   \   00010F   8D83         MOV     DPH,R5
   \   000111   E582         MOV     A,DPL
   \   000113   4583         ORL     A,DPH
   \   000115   7003         JNZ     $+5
   \   000117   02....       LJMP    ??zcl_SendReadRsp_8 & 0xFFFF
   \   00011A                ; Setup parameters for call to function zclSerializeData
   \   00011A   AC..         MOV     R4,?V0
   \   00011C   AD..         MOV     R5,?V1
   \   00011E   AA82         MOV     R2,DPL
   \   000120   AB83         MOV     R3,DPH
   \   000122   8882         MOV     DPL,R0
   \   000124   8983         MOV     DPH,R1
   \   000126   E0           MOVX    A,@DPTR
   \   000127   F9           MOV     R1,A
   \   000128   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   00012B   8A..         MOV     ?V0,R2
   \   00012D   8B..         MOV     ?V1,R3
   \   00012F   808D         SJMP    ??zcl_SendReadRsp_9
   1274                }
   1275              } // for loop
   1276          
   1277              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1278                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_10:
   \   000131                ; Setup parameters for call to function zcl_SendCommand
   \   000131   78..         MOV     R0,#?V4
   \   000133   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000136   8E..         MOV     ?V0,R6
   \   000138   8F..         MOV     ?V1,R7
   \   00013A   78..         MOV     R0,#?V0
   \   00013C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00013F   7420         MOV     A,#0x20
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014A   E4           CLR     A
   \   00014B   F5..         MOV     ?V0,A
   \   00014D   F5..         MOV     ?V1,A
   \   00014F   78..         MOV     R0,#?V0
   \   000151   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000154   7422         MOV     A,#0x22
   \   000156   12....       LCALL   ?XSTACK_DISP0_8
   \   000159   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   00015C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015F   7422         MOV     A,#0x22
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   000167   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016A   75..00       MOV     ?V0,#0x0
   \   00016D   78..         MOV     R0,#?V0
   \   00016F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000172   75..01       MOV     ?V0,#0x1
   \   000175   78..         MOV     R0,#?V0
   \   000177   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017A   AC..         MOV     R4,?V6
   \   00017C   AD..         MOV     R5,?V7
   \   00017E   AA..         MOV     R2,?V12
   \   000180   AB..         MOV     R3,?V13
   \   000182   A9..         MOV     R1,?V3
   \   000184   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000187   740B         MOV     A,#0xb
   \   000189   12....       LCALL   ?DEALLOC_XSTACK8
   \   00018C   E9           MOV     A,R1
   \   00018D   FE           MOV     R6,A
   1279              zcl_mem_free( buf );
   \   00018E                ; Setup parameters for call to function osal_mem_free
   \   00018E   AA..         MOV     R2,?V4
   \   000190   AB..         MOV     R3,?V5
   \   000192   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000195   8002         SJMP    ??zcl_SendReadRsp_12
   1280            }
   1281            else
   1282            {
   1283              status = ZMemError;
   \                     ??zcl_SendReadRsp_6:
   \   000197   7E10         MOV     R6,#0x10
   1284            }
   1285          
   1286            return ( status );
   \                     ??zcl_SendReadRsp_12:
   \   000199   EE           MOV     A,R6
   \   00019A   F9           MOV     R1,A
   \   00019B   02....       LJMP    ?Subroutine7 & 0xFFFF
   1287          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_448:
   \   000003   AA..         MOV     R2,?V6
   \   000005   AB..         MOV     R3,?V7
   \   000007   A9..         MOV     R1,?V3
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   00000E   EE           MOV     A,R6
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7402         MOV     A,#0x2
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005                REQUIRE ??Subroutine156_0
   \   000005                ; // Fall through to label ??Subroutine156_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine156_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine159_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   78..         MOV     R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   EA           MOV     A,R2
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004                REQUIRE ??Subroutine163_0
   \   000004                ; // Fall through to label ??Subroutine163_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine163_0:
   \   000000   E4           CLR     A
   \   000001   3B           ADDC    A,R3
   \   000002   F9           MOV     R1,A
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine133:
   \   000000   E5..         MOV     A,?V8
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   E5..         MOV     A,?V9
   \   000007   39           ADDC    A,R1
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine175_0:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_411:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006                REQUIRE ??Subroutine176_0
   \   000006                ; // Fall through to label ??Subroutine176_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine176_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V2
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000003   AA82         MOV     R2,DPL
   \   000005   AB83         MOV     R3,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V9,A
   \   000007   22           RET
   1288          #endif // ZCL_READ
   1289          
   1290          #ifdef ZCL_WRITE
   1291          /*********************************************************************
   1292           * @fn      sendWriteRequest
   1293           *
   1294           * @brief   Send a Write command
   1295           *
   1296           * @param   dstAddr - destination address
   1297           * @param   clusterID - cluster ID
   1298           * @param   writeCmd - write command to be sent
   1299           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1300           * @param   direction - direction of the command
   1301           * @param   seqNum - transaction sequence number
   1302           *
   1303           * @return  ZSuccess if OK
   1304           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1305          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1306                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1307                                          uint8 disableDefaultRsp, uint8 seqNum )
   1308          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1309            uint8 *buf;
   1310            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1311            ZStatus_t status;
   1312            uint8 i;
   1313          
   1314            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000013   75..00       MOV     ?V2,#0x0
   \   000016   7416         MOV     A,#0x16
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   00001E   8009         SJMP    ??CrossCallReturnLabel_189
   1315            {
   1316              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   000020   12....       LCALL   ?Subroutine58 & 0xFFFF
   1317          
   1318              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1319          
   1320              // Attribute Data
   1321              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   1322            }
   \                     ??CrossCallReturnLabel_94:
   \   000023   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000026   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000029   85..82       MOV     DPL,?V4
   \   00002C   85..83       MOV     DPH,?V5
   \   00002F   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_412:
   \   000032   40EC         JC      ??zcl_SendWriteRequest_0
   1323          
   1324            buf = zcl_mem_alloc( dataLen );
   \   000034                ; Setup parameters for call to function osal_mem_alloc
   \   000034   EE           MOV     A,R6
   \   000035   FA           MOV     R2,A
   \   000036   EF           MOV     A,R7
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V0,R2
   \   00003D   8B..         MOV     ?V1,R3
   1325            if ( buf != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V1
   \   000042   7003         JNZ     $+5
   \   000044   02....       LJMP    ??zcl_SendWriteRequest_1 & 0xFFFF
   1326            {
   1327              // Load the buffer - serially
   1328              uint8 *pBuf = buf;
   \   000047   A8..         MOV     R0,?V0
   \   000049   A9..         MOV     R1,?V1
   1329              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00004B   75..00       MOV     ?V2,#0x0
   \   00004E   8010         SJMP    ??zcl_SendWriteRequest_2
   1330              {
   1331                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_3:
   \   000050   12....       LCALL   ?Subroutine12 & 0xFFFF
   1332          
   1333                *pBuf++ = LO_UINT16( statusRec->attrID );
   1334                *pBuf++ = HI_UINT16( statusRec->attrID );
   1335                *pBuf++ = statusRec->dataType;
   1336          
   1337                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   1338              }
   \                     ??CrossCallReturnLabel_0:
   \   000053   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000056   8A..         MOV     ?V10,R2
   \   000058   8B..         MOV     ?V11,R3
   \   00005A   A8..         MOV     R0,?V10
   \   00005C   A9..         MOV     R1,?V11
   \   00005E   05..         INC     ?V2
   \                     ??zcl_SendWriteRequest_2:
   \   000060   85..82       MOV     DPL,?V4
   \   000063   85..83       MOV     DPH,?V5
   \   000066   E0           MOVX    A,@DPTR
   \   000067   FA           MOV     R2,A
   \   000068   E5..         MOV     A,?V2
   \   00006A   C3           CLR     C
   \   00006B   9A           SUBB    A,R2
   \   00006C   40E2         JC      ??zcl_SendWriteRequest_3
   1339          
   1340              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1341                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00006E                ; Setup parameters for call to function zcl_SendCommand
   \   00006E   78..         MOV     R0,#?V0
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   8E..         MOV     ?V4,R6
   \   000075   8F..         MOV     ?V5,R7
   \   000077   78..         MOV     R0,#?V4
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   741F         MOV     A,#0x1f
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000087   E4           CLR     A
   \   000088   F5..         MOV     ?V4,A
   \   00008A   F5..         MOV     ?V5,A
   \   00008C   78..         MOV     R0,#?V4
   \   00008E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000091   7421         MOV     A,#0x21
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009C   7421         MOV     A,#0x21
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   75..00       MOV     ?V2,#0x0
   \   0000AA   78..         MOV     R0,#?V2
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AF   7422         MOV     A,#0x22
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BA   AC..         MOV     R4,?V6
   \   0000BC   AD..         MOV     R5,?V7
   \   0000BE   AA..         MOV     R2,?V8
   \   0000C0   AB..         MOV     R3,?V9
   \   0000C2   A9..         MOV     R1,?V3
   \   0000C4   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000C7   740B         MOV     A,#0xb
   \   0000C9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CC   E9           MOV     A,R1
   \   0000CD   FE           MOV     R6,A
   1342              zcl_mem_free( buf );
   \   0000CE                ; Setup parameters for call to function osal_mem_free
   \   0000CE   AA..         MOV     R2,?V0
   \   0000D0   AB..         MOV     R3,?V1
   \   0000D2   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000D5   8002         SJMP    ??zcl_SendWriteRequest_4
   1343            }
   1344            else
   1345            {
   1346              status = ZMemError;
   \                     ??zcl_SendWriteRequest_1:
   \   0000D7   7E10         MOV     R6,#0x10
   1347            }
   1348          
   1349            return ( status);
   \                     ??zcl_SendWriteRequest_4:
   \   0000D9                REQUIRE ?Subroutine11
   \   0000D9                ; // Fall through to label ?Subroutine11
   1350          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine156_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   8B..         MOV     ?V1,R3
   \   000002   EA           MOV     A,R2
   \   000003   2403         ADD     A,#0x3
   \   000005   F8           MOV     R0,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V1
   \   000009   F9           MOV     R1,A
   \   00000A   EE           MOV     A,R6
   \   00000B   28           ADD     A,R0
   \   00000C   FE           MOV     R6,A
   \   00000D   EF           MOV     A,R7
   \   00000E   39           ADDC    A,R1
   \   00000F   FF           MOV     R7,A
   \   000010   05..         INC     ?V2
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F005       MOV     B,#0x5
   \   000005   A4           MUL     AB
   \   000006   F8           MOV     R0,A
   \   000007   A9F0         MOV     R1,B
   \   000009   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_391:
   \   00000F   8882         MOV     DPL,R0
   \   000011   8983         MOV     DPH,R1
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine155_0
   \   000003                ; // Fall through to label ??Subroutine155_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F005       MOV     B,#0x5
   \   000005   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000008   8582..       MOV     ?V12,DPL
   \   00000B   8583..       MOV     ?V13,DPH
   \   00000E   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000011   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000014   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000017   F0           MOVX    @DPTR,A
   \   000018   E5..         MOV     A,?V12
   \   00001A   2402         ADD     A,#0x2
   \   00001C   FA           MOV     R2,A
   \   00001D   E4           CLR     A
   \   00001E   35..         ADDC    A,?V13
   \   000020   FB           MOV     R3,A
   \   000021   8A..         MOV     ?V10,R2
   \   000023   8B..         MOV     ?V11,R3
   \   000025   8A82         MOV     DPL,R2
   \   000027   F583         MOV     DPH,A
   \   000029   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   00002C   A3           INC     DPTR
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E                ; Setup parameters for call to function zclSerializeData
   \   00002E                ; Setup parameters for call to function zclSerializeData
   \   00002E   E8           MOV     A,R0
   \   00002F   2403         ADD     A,#0x3
   \   000031   FC           MOV     R4,A
   \   000032   E4           CLR     A
   \   000033   39           ADDC    A,R1
   \   000034   FD           MOV     R5,A
   \   000035   85..82       MOV     DPL,?V12
   \   000038   85..83       MOV     DPH,?V13
   \   00003B   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_389:
   \   00003E   85..82       MOV     DPL,?V10
   \   000041   85..83       MOV     DPH,?V11
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F9           MOV     R1,A
   \   000046   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine141:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V2,A
   \   000003   78..         MOV     R0,#?V2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine134:
   \   000000   A4           MUL     AB
   \   000001   FA           MOV     R2,A
   \   000002   ABF0         MOV     R3,B
   \   000004   E5..         MOV     A,?V4
   \   000006   2A           ADD     A,R2
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V5
   \   00000B   3B           ADDC    A,R3
   \   00000C   F583         MOV     DPH,A
   \   00000E   A3           INC     DPTR
   \   00000F   22           RET
   1351          
   1352          /*********************************************************************
   1353           * @fn      zcl_SendWriteRsp
   1354           *
   1355           * @brief   Send a Write Response command
   1356           *
   1357           * @param   dstAddr - destination address
   1358           * @param   clusterID - cluster ID
   1359           * @param   wrtieRspCmd - write response command to be sent
   1360           * @param   direction - direction of the command
   1361           * @param   seqNum - transaction sequence number
   1362           *
   1363           * @return  ZSuccess if OK
   1364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1365          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1366                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1367                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1368          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine45 & 0xFFFF
   1369            uint16 dataLen;
   1370            uint8 *buf;
   1371            ZStatus_t status;
   1372          
   1373            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \                     ??CrossCallReturnLabel_56:
   \   000017   75F003       MOV     B,#0x3
   \   00001A   A4           MUL     AB
   \   00001B   F5..         MOV     ?V6,A
   \   00001D   E5F0         MOV     A,B
   \   00001F   F5..         MOV     ?V7,A
   1374          
   1375            buf = zcl_mem_alloc( dataLen );
   \   000021                ; Setup parameters for call to function osal_mem_alloc
   \   000021   AA..         MOV     R2,?V6
   \   000023   FB           MOV     R3,A
   \   000024   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000027   8A..         MOV     ?V0,R2
   \   000029   8B..         MOV     ?V1,R3
   1376            if ( buf != NULL )
   \   00002B   EA           MOV     A,R2
   \   00002C   45..         ORL     A,?V1
   \   00002E   7003         JNZ     $+5
   \   000030   02....       LJMP    ??zcl_SendWriteRsp_0 & 0xFFFF
   1377            {
   1378              // Load the buffer - serially
   1379              uint8 i;
   1380              uint8 *pBuf = buf;
   1381              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   000033   7C00         MOV     R4,#0x0
   \   000035   802C         SJMP    ??zcl_SendWriteRsp_1
   1382              {
   1383                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_2:
   \   000037   EC           MOV     A,R4
   \   000038   75F003       MOV     B,#0x3
   \   00003B   A4           MUL     AB
   \   00003C   F8           MOV     R0,A
   \   00003D   A9F0         MOV     R1,B
   \   00003F   E5..         MOV     A,?V4
   \   000041   28           ADD     A,R0
   \   000042   F8           MOV     R0,A
   \   000043   E5..         MOV     A,?V5
   \   000045   39           ADDC    A,R1
   \   000046   12....       LCALL   ?Subroutine65 & 0xFFFF
   1384                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_284:
   \   000049   E8           MOV     A,R0
   \   00004A   2402         ADD     A,#0x2
   \   00004C   F8           MOV     R0,A
   \   00004D   5001         JNC     ??zcl_SendWriteRsp_3
   \   00004F   09           INC     R1
   \                     ??zcl_SendWriteRsp_3:
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   12....       LCALL   ?Subroutine120 & 0xFFFF
   1385                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1386              }
   \                     ??CrossCallReturnLabel_287:
   \   000057   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   EA           MOV     A,R2
   \   00005C   2403         ADD     A,#0x3
   \   00005E   FA           MOV     R2,A
   \   00005F   5001         JNC     ??zcl_SendWriteRsp_4
   \   000061   0B           INC     R3
   \                     ??zcl_SendWriteRsp_4:
   \   000062   0C           INC     R4
   \                     ??zcl_SendWriteRsp_1:
   \   000063   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000066   40CF         JC      ??zcl_SendWriteRsp_2
   1387          
   1388              // If there's only a single status record and its status field is set to
   1389              // SUCCESS then omit the attribute ID field.
   1390              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000068   7401         MOV     A,#0x1
   \   00006A   68           XRL     A,R0
   \   00006B   700A         JNZ     ??zcl_SendWriteRsp_5
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   7006         JNZ     ??zcl_SendWriteRsp_5
   1391              {
   1392                dataLen = 1;
   \   000071   75..01       MOV     ?V6,#0x1
   \   000074   75..00       MOV     ?V7,#0x0
   1393              }
   1394          
   1395              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1396                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_5:
   \   000077                ; Setup parameters for call to function zcl_SendCommand
   \   000077   78..         MOV     R0,#?V0
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   78..         MOV     R0,#?V6
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000081   741C         MOV     A,#0x1c
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008C   E4           CLR     A
   \   00008D   F5..         MOV     ?V4,A
   \   00008F   F5..         MOV     ?V5,A
   \   000091   78..         MOV     R0,#?V4
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   741E         MOV     A,#0x1e
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A1   741E         MOV     A,#0x1e
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0000A9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AC   75..00       MOV     ?V3,#0x0
   \   0000AF   78..         MOV     R0,#?V3
   \   0000B1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B4   75..04       MOV     ?V3,#0x4
   \   0000B7   78..         MOV     R0,#?V3
   \   0000B9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BC   EE           MOV     A,R6
   \   0000BD   FC           MOV     R4,A
   \   0000BE   EF           MOV     A,R7
   \   0000BF   FD           MOV     R5,A
   \   0000C0   AA..         MOV     R2,?V8
   \   0000C2   AB..         MOV     R3,?V9
   \   0000C4   A9..         MOV     R1,?V2
   \   0000C6   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000C9   740B         MOV     A,#0xb
   \   0000CB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CE   E9           MOV     A,R1
   \   0000CF   FE           MOV     R6,A
   1397              zcl_mem_free( buf );
   \   0000D0                ; Setup parameters for call to function osal_mem_free
   \   0000D0   AA..         MOV     R2,?V0
   \   0000D2   AB..         MOV     R3,?V1
   \   0000D4   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000D7   8002         SJMP    ??zcl_SendWriteRsp_6
   1398            }
   1399            else
   1400            {
   1401              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0000D9   7E10         MOV     R6,#0x10
   1402            }
   1403          
   1404            return ( status );
   \                     ??zcl_SendWriteRsp_6:
   \   0000DB   02....       LJMP    ?Subroutine6 & 0xFFFF
   1405          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   F9           MOV     R1,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine149_0
   \   000006                ; // Fall through to label ??Subroutine149_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine149_0:
   \   000000   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine151_0
   \   000001                ; // Fall through to label ??Subroutine151_0
   1406          #endif // ZCL_WRITE
   1407          
   1408          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   1409          /*********************************************************************
   1410           * @fn      zcl_SendConfigReportCmd
   1411           *
   1412           * @brief   Send a Configure Reporting command
   1413           *
   1414           * @param   dstAddr - destination address
   1415           * @param   clusterID - cluster ID
   1416           * @param   cfgReportCmd - configure reporting command to be sent
   1417           * @param   direction - direction of the command
   1418           * @param   seqNum - transaction sequence number
   1419           *
   1420           * @return  ZSuccess if OK
   1421           */
   1422          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1423                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1424                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1425          {
   1426            uint8 *buf;
   1427            uint16 dataLen = 0;
   1428            ZStatus_t status;
   1429            uint8 i;
   1430          
   1431            // Find out the data length
   1432            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1433            {
   1434              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1435          
   1436              dataLen += 1 + 2; // Direction + Attribute ID
   1437          
   1438              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1439              {
   1440                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1441          
   1442                // Find out the size of the Reportable Change field (for Analog data types)
   1443                if ( zclAnalogDataType( reportRec->dataType ) )
   1444                {
   1445                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1446                }
   1447              }
   1448              else
   1449              {
   1450                dataLen += 2; // Timeout Period
   1451              }
   1452            }
   1453          
   1454            buf = zcl_mem_alloc( dataLen );
   1455            if ( buf != NULL )
   1456            {
   1457              // Load the buffer - serially
   1458              uint8 *pBuf = buf;
   1459          
   1460              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1461              {
   1462                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1463          
   1464                *pBuf++ = reportRec->direction;
   1465                *pBuf++ = LO_UINT16( reportRec->attrID );
   1466                *pBuf++ = HI_UINT16( reportRec->attrID );
   1467          
   1468                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1469                {
   1470                  *pBuf++ = reportRec->dataType;
   1471                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1472                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1473                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1474                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1475          
   1476                  if ( zclAnalogDataType( reportRec->dataType ) )
   1477                  {
   1478                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1479                  }
   1480                }
   1481                else
   1482                {
   1483                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   1484                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1485                }
   1486              } // for loop
   1487          
   1488              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1489                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1490              zcl_mem_free( buf );
   1491            }
   1492            else
   1493            {
   1494              status = ZMemError;
   1495            }
   1496          
   1497            return ( status );
   1498          }
   1499          #endif
   1500          
   1501          #ifdef ZCL_REPORTING_DEVICE
   1502          /*********************************************************************
   1503           * @fn      zcl_SendConfigReportRspCmd
   1504           *
   1505           * @brief   Send a Configure Reporting Response command
   1506           *
   1507           * @param   dstAddr - destination address
   1508           * @param   clusterID - cluster ID
   1509           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1510           * @param   direction - direction of the command
   1511           * @param   seqNum - transaction sequence number
   1512           *
   1513           * @return  ZSuccess if OK
   1514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1515          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1516                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1517                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1518          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine45 & 0xFFFF
   1519            uint16 dataLen;
   1520            uint8 *buf;
   1521            ZStatus_t status;
   1522          
   1523            // Atrribute list (Status, Direction and Attribute ID)
   1524            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \                     ??CrossCallReturnLabel_57:
   \   000017   F5..         MOV     ?V0,A
   \   000019   75..00       MOV     ?V1,#0x0
   \   00001C   7402         MOV     A,#0x2
   \   00001E   78..         MOV     R0,#?V0
   \   000020   12....       LCALL   ?S_SHL
   \   000023   85....       MOV     ?V6,?V0
   \   000026   85....       MOV     ?V7,?V1
   1525          
   1526            buf = zcl_mem_alloc( dataLen );
   \   000029                ; Setup parameters for call to function osal_mem_alloc
   \   000029   AA..         MOV     R2,?V6
   \   00002B   AB..         MOV     R3,?V7
   \   00002D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000030   8A..         MOV     ?V0,R2
   \   000032   8B..         MOV     ?V1,R3
   1527            if ( buf != NULL )
   \   000034   EA           MOV     A,R2
   \   000035   45..         ORL     A,?V1
   \   000037   7003         JNZ     $+5
   \   000039   02....       LJMP    ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
   1528            {
   1529              // Load the buffer - serially
   1530              uint8 *pBuf = buf;
   1531              uint8 i;
   1532          
   1533              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   00003C   7C00         MOV     R4,#0x0
   \   00003E   803D         SJMP    ??zcl_SendConfigReportRspCmd_1
   1534              {
   1535                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   000040   8C..         MOV     ?V10,R4
   \   000042   75..00       MOV     ?V11,#0x0
   \   000045   7402         MOV     A,#0x2
   \   000047   78..         MOV     R0,#?V10
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   E5..         MOV     A,?V4
   \   00004E   25..         ADD     A,?V10
   \   000050   F8           MOV     R0,A
   \   000051   E5..         MOV     A,?V5
   \   000053   35..         ADDC    A,?V11
   \   000055   12....       LCALL   ?Subroutine65 & 0xFFFF
   1536                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \                     ??CrossCallReturnLabel_285:
   \   000058   8882         MOV     DPL,R0
   \   00005A   8983         MOV     DPH,R1
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000061   F0           MOVX    @DPTR,A
   1537                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \   000062   E8           MOV     A,R0
   \   000063   2403         ADD     A,#0x3
   \   000065   F8           MOV     R0,A
   \   000066   5001         JNC     ??zcl_SendConfigReportRspCmd_3
   \   000068   09           INC     R1
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   000069   8882         MOV     DPL,R0
   \   00006B   8983         MOV     DPH,R1
   \   00006D   12....       LCALL   ?Subroutine85 & 0xFFFF
   1538                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1539              }
   \                     ??CrossCallReturnLabel_145:
   \   000070   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000073   A3           INC     DPTR
   \   000074   F0           MOVX    @DPTR,A
   \   000075   EA           MOV     A,R2
   \   000076   2404         ADD     A,#0x4
   \   000078   FA           MOV     R2,A
   \   000079   5001         JNC     ??zcl_SendConfigReportRspCmd_4
   \   00007B   0B           INC     R3
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   00007C   0C           INC     R4
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   00007D   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000080   40BE         JC      ??zcl_SendConfigReportRspCmd_2
   1540          
   1541              // If there's only a single status record and its status field is set to
   1542              // SUCCESS then omit the attribute ID field.
   1543              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000082   7401         MOV     A,#0x1
   \   000084   68           XRL     A,R0
   \   000085   700A         JNZ     ??zcl_SendConfigReportRspCmd_5
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   7006         JNZ     ??zcl_SendConfigReportRspCmd_5
   1544              {
   1545                dataLen = 1;
   \   00008B   75..01       MOV     ?V6,#0x1
   \   00008E   75..00       MOV     ?V7,#0x0
   1546              }
   1547          
   1548              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1549                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1550                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_5:
   \   000091                ; Setup parameters for call to function zcl_SendCommand
   \   000091   78..         MOV     R0,#?V0
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   78..         MOV     R0,#?V6
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009B   741C         MOV     A,#0x1c
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A6   E4           CLR     A
   \   0000A7   F5..         MOV     ?V4,A
   \   0000A9   F5..         MOV     ?V5,A
   \   0000AB   78..         MOV     R0,#?V4
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B0   741E         MOV     A,#0x1e
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BB   741E         MOV     A,#0x1e
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   0000C3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C6   75..00       MOV     ?V3,#0x0
   \   0000C9   78..         MOV     R0,#?V3
   \   0000CB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CE   75..07       MOV     ?V3,#0x7
   \   0000D1   78..         MOV     R0,#?V3
   \   0000D3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D6   EE           MOV     A,R6
   \   0000D7   FC           MOV     R4,A
   \   0000D8   EF           MOV     A,R7
   \   0000D9   FD           MOV     R5,A
   \   0000DA   AA..         MOV     R2,?V8
   \   0000DC   AB..         MOV     R3,?V9
   \   0000DE   A9..         MOV     R1,?V2
   \   0000E0   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000E3   740B         MOV     A,#0xb
   \   0000E5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E8   E9           MOV     A,R1
   \   0000E9   FE           MOV     R6,A
   1551              zcl_mem_free( buf );
   \   0000EA                ; Setup parameters for call to function osal_mem_free
   \   0000EA   AA..         MOV     R2,?V0
   \   0000EC   AB..         MOV     R3,?V1
   \   0000EE   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000F1   8002         SJMP    ??zcl_SendConfigReportRspCmd_6
   1552            }
   1553            else
   1554            {
   1555              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   0000F3   7E10         MOV     R6,#0x10
   1556            }
   1557          
   1558            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_6:
   \   0000F5                REQUIRE ?Subroutine6
   \   0000F5                ; // Fall through to label ?Subroutine6
   1559          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   000003   A3           INC     DPTR
   \   000004   22           RET
   1560          #endif
   1561          
   1562          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   1563          /*********************************************************************
   1564           * @fn      zcl_SendReadReportCfgCmd
   1565           *
   1566           * @brief   Send a Read Reporting Configuration command
   1567           *
   1568           * @param   dstAddr - destination address
   1569           * @param   clusterID - cluster ID
   1570           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1571           * @param   direction - direction of the command
   1572           * @param   seqNum - transaction sequence number
   1573           *
   1574           * @return  ZSuccess if OK
   1575           */
   1576          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1577                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1578                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1579          {
   1580            uint16 dataLen;
   1581            uint8 *buf;
   1582            ZStatus_t status;
   1583          
   1584            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1585          
   1586            buf = zcl_mem_alloc( dataLen );
   1587            if ( buf != NULL )
   1588            {
   1589              // Load the buffer - serially
   1590              uint8 *pBuf = buf;
   1591              uint8 i;
   1592          
   1593              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   1594              {
   1595                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1596                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1597                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1598              }
   1599          
   1600              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1601                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1602              zcl_mem_free( buf );
   1603            }
   1604            else
   1605            {
   1606              status = ZMemError;
   1607            }
   1608          
   1609            return ( status );
   1610          }
   1611          #endif
   1612          
   1613          #ifdef ZCL_REPORTING_DEVICE
   1614          /*********************************************************************
   1615           * @fn      zcl_SendReadReportCfgRspCmd
   1616           *
   1617           * @brief   Send a Read Reporting Configuration Response command
   1618           *
   1619           * @param   dstAddr - destination address
   1620           * @param   clusterID - cluster ID
   1621           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1622           * @param   direction - direction of the command
   1623           * @param   seqNum - transaction sequence number
   1624           *
   1625           * @return  ZSuccess if OK
   1626           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1627          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1628                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1629                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1630          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   00000D   89..         MOV     ?V1,R1
   \   00000F   8C..         MOV     ?V12,R4
   \   000011   8D..         MOV     ?V13,R5
   1631            uint8 *buf;
   1632            uint16 dataLen = 0;
   \   000013   7E00         MOV     R6,#0x0
   \   000015   7F00         MOV     R7,#0x0
   1633            ZStatus_t status;
   1634            uint8 i;
   1635          
   1636            // Find out the data length
   1637            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000017   75..00       MOV     ?V0,#0x0
   \   00001A   741A         MOV     A,#0x1a
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000022   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_0
   1638            {
   1639              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1640          
   1641              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1642          
   1643              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1644              {
   1645                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1646                {
   1647                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1648          
   1649                  // Find out the size of the Reportable Change field (for Analog data types)
   1650                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1651                  {
   1652                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1653                  }
   1654                }
   1655                else
   1656                {
   1657                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   000024   EE           MOV     A,R6
   \   000025   2402         ADD     A,#0x2
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   000027   FE           MOV     R6,A
   \   000028   E4           CLR     A
   \   000029   3F           ADDC    A,R7
   \   00002A   FF           MOV     R7,A
   1658                }
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   00002B   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   00002D   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   000030   5041         JNC     ??zcl_SendReadReportCfgRspCmd_4
   \   000032   E5..         MOV     A,?V0
   \   000034   75F00D       MOV     B,#0xd
   \   000037   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   00003A   2404         ADD     A,#0x4
   \   00003C   FE           MOV     R6,A
   \   00003D   E4           CLR     A
   \   00003E   3F           ADDC    A,R7
   \   00003F   FF           MOV     R7,A
   \   000040   E0           MOVX    A,@DPTR
   \   000041   70E8         JNZ     ??zcl_SendReadReportCfgRspCmd_3
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   70DD         JNZ     ??zcl_SendReadReportCfgRspCmd_1
   \   000047   EE           MOV     A,R6
   \   000048   2405         ADD     A,#0x5
   \   00004A   FE           MOV     R6,A
   \   00004B   E4           CLR     A
   \   00004C   3F           ADDC    A,R7
   \   00004D   FF           MOV     R7,A
   \   00004E   E8           MOV     A,R0
   \   00004F   2404         ADD     A,#0x4
   \   000051   F5..         MOV     ?V2,A
   \   000053   E4           CLR     A
   \   000054   39           ADDC    A,R1
   \   000055   F5..         MOV     ?V3,A
   \   000057                ; Setup parameters for call to function zclAnalogDataType
   \   000057   85..82       MOV     DPL,?V2
   \   00005A   F583         MOV     DPH,A
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F9           MOV     R1,A
   \   00005E   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000061   E9           MOV     A,R1
   \   000062   60C7         JZ      ??zcl_SendReadReportCfgRspCmd_3
   \   000064                ; Setup parameters for call to function zclGetDataTypeLength
   \   000064   85..82       MOV     DPL,?V2
   \   000067   85..83       MOV     DPH,?V3
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F9           MOV     R1,A
   \   00006C   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   00006F   EE           MOV     A,R6
   \   000070   29           ADD     A,R1
   \   000071   80B4         SJMP    ??zcl_SendReadReportCfgRspCmd_2
   1659              }
   1660            }
   1661          
   1662            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   000073                ; Setup parameters for call to function osal_mem_alloc
   \   000073   EE           MOV     A,R6
   \   000074   FA           MOV     R2,A
   \   000075   EF           MOV     A,R7
   \   000076   FB           MOV     R3,A
   \   000077   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00007A   8A..         MOV     ?V2,R2
   \   00007C   8B..         MOV     ?V3,R3
   1663            if ( buf != NULL )
   \   00007E   EA           MOV     A,R2
   \   00007F   45..         ORL     A,?V3
   \   000081   7003         JNZ     $+5
   \   000083   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
   1664            {
   1665              // Load the buffer - serially
   1666              uint8 *pBuf = buf;
   \   000086   8A..         MOV     ?V6,R2
   \   000088   8B..         MOV     ?V7,R3
   1667          
   1668              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   00008A   75..00       MOV     ?V0,#0x0
   \   00008D   801D         SJMP    ??zcl_SendReadReportCfgRspCmd_6
   1669              {
   1670                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1671          
   1672                *pBuf++ = reportRspRec->status;
   1673                *pBuf++ = reportRspRec->direction;
   1674                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1675                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1676          
   1677                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1678                {
   1679                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1680                  {
   1681                    *pBuf++ = reportRspRec->dataType;
   1682                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1683                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1684                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1685                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1686          
   1687                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1688                    {
   1689                      pBuf = zclSerializeData( reportRspRec->dataType,
   1690                                               reportRspRec->reportableChange, pBuf );
   1691                    }
   1692                  }
   1693                  else
   1694                  {
   1695                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   00008F   E5..         MOV     A,?V4
   \   000091   2409         ADD     A,#0x9
   \   000093   FA           MOV     R2,A
   \   000094   E4           CLR     A
   \   000095   35..         ADDC    A,?V5
   \   000097   FB           MOV     R3,A
   \   000098   8A82         MOV     DPL,R2
   \   00009A   8B83         MOV     DPH,R3
   \   00009C   12....       LCALL   ?Subroutine116 & 0xFFFF
   1696                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1697                  }
   \                     ??CrossCallReturnLabel_208:
   \   00009F   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0000A2   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   0000A5   F0           MOVX    @DPTR,A
   \   0000A6   8C..         MOV     ?V6,R4
   \   0000A8   8D..         MOV     ?V7,R5
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   0000AA   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   0000AC   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   0000AF   4003         JC      $+5
   \   0000B1   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_9 & 0xFFFF
   \   0000B4   E5..         MOV     A,?V0
   \   0000B6   75F00D       MOV     B,#0xd
   \   0000B9   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   0000BC   8582..       MOV     ?V4,DPL
   \   0000BF   8583..       MOV     ?V5,DPH
   \   0000C2   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   0000C5   85..82       MOV     DPL,?V4
   \   0000C8   85..83       MOV     DPH,?V5
   \   0000CB   A3           INC     DPTR
   \   0000CC   AA82         MOV     R2,DPL
   \   0000CE   AB83         MOV     R3,DPH
   \   0000D0   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   0000D3   F0           MOVX    @DPTR,A
   \   0000D4   E5..         MOV     A,?V4
   \   0000D6   2402         ADD     A,#0x2
   \   0000D8   F8           MOV     R0,A
   \   0000D9   E4           CLR     A
   \   0000DA   35..         ADDC    A,?V5
   \   0000DC   F9           MOV     R1,A
   \   0000DD   8882         MOV     DPL,R0
   \   0000DF   8983         MOV     DPH,R1
   \   0000E1   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   0000E4   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000E7   F0           MOVX    @DPTR,A
   \   0000E8   E5..         MOV     A,?V6
   \   0000EA   2404         ADD     A,#0x4
   \   0000EC   F5..         MOV     ?V6,A
   \   0000EE   5002         JNC     ??zcl_SendReadReportCfgRspCmd_10
   \   0000F0   05..         INC     ?V7
   \                     ??zcl_SendReadReportCfgRspCmd_10:
   \   0000F2   85..82       MOV     DPL,?V4
   \   0000F5   85..83       MOV     DPH,?V5
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   70AF         JNZ     ??zcl_SendReadReportCfgRspCmd_8
   \   0000FB   E5..         MOV     A,?V6
   \   0000FD   2402         ADD     A,#0x2
   \   0000FF   FC           MOV     R4,A
   \   000100   E4           CLR     A
   \   000101   35..         ADDC    A,?V7
   \   000103   FD           MOV     R5,A
   \   000104   85..82       MOV     DPL,?V6
   \   000107   85..83       MOV     DPH,?V7
   \   00010A   A3           INC     DPTR
   \   00010B   A882         MOV     R0,DPL
   \   00010D   A983         MOV     R1,DPH
   \   00010F   8A82         MOV     DPL,R2
   \   000111   8B83         MOV     DPH,R3
   \   000113   E0           MOVX    A,@DPTR
   \   000114   6003         JZ      $+5
   \   000116   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_7 & 0xFFFF
   \   000119   E5..         MOV     A,?V4
   \   00011B   2404         ADD     A,#0x4
   \   00011D   F5..         MOV     ?V10,A
   \   00011F   E4           CLR     A
   \   000120   35..         ADDC    A,?V5
   \   000122   F5..         MOV     ?V11,A
   \   000124   85..82       MOV     DPL,?V10
   \   000127   F583         MOV     DPH,A
   \   000129   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   00012C   E5..         MOV     A,?V4
   \   00012E   2405         ADD     A,#0x5
   \   000130   F5..         MOV     ?V14,A
   \   000132   E4           CLR     A
   \   000133   35..         ADDC    A,?V5
   \   000135   F5..         MOV     ?V15,A
   \   000137   85..82       MOV     DPL,?V14
   \   00013A   F583         MOV     DPH,A
   \   00013C   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   00013F   F0           MOVX    @DPTR,A
   \   000140   85..82       MOV     DPL,?V14
   \   000143   85..83       MOV     DPH,?V15
   \   000146   12....       LCALL   ??Subroutine152_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   000149   F0           MOVX    @DPTR,A
   \   00014A   E5..         MOV     A,?V4
   \   00014C   2407         ADD     A,#0x7
   \   00014E   F8           MOV     R0,A
   \   00014F   E4           CLR     A
   \   000150   35..         ADDC    A,?V5
   \   000152   F9           MOV     R1,A
   \   000153   8882         MOV     DPL,R0
   \   000155   8983         MOV     DPH,R1
   \   000157   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00015A   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00015D   A3           INC     DPTR
   \   00015E   F0           MOVX    @DPTR,A
   \   00015F   E5..         MOV     A,?V6
   \   000161   2405         ADD     A,#0x5
   \   000163   F5..         MOV     ?V6,A
   \   000165   5002         JNC     ??zcl_SendReadReportCfgRspCmd_11
   \   000167   05..         INC     ?V7
   \                     ??zcl_SendReadReportCfgRspCmd_11:
   \   000169                ; Setup parameters for call to function zclAnalogDataType
   \   000169   85..82       MOV     DPL,?V10
   \   00016C   85..83       MOV     DPH,?V11
   \   00016F   E0           MOVX    A,@DPTR
   \   000170   F9           MOV     R1,A
   \   000171   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000174   E9           MOV     A,R1
   \   000175   7003         JNZ     $+5
   \   000177   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
   \   00017A                ; Setup parameters for call to function zclSerializeData
   \   00017A   AC..         MOV     R4,?V6
   \   00017C   AD..         MOV     R5,?V7
   \   00017E   E5..         MOV     A,?V4
   \   000180   240B         ADD     A,#0xb
   \   000182   F582         MOV     DPL,A
   \   000184   E4           CLR     A
   \   000185   35..         ADDC    A,?V5
   \   000187   F583         MOV     DPH,A
   \   000189   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   1698                }
   1699              }
   \                     ??CrossCallReturnLabel_370:
   \   00018C   85..82       MOV     DPL,?V10
   \   00018F   85..83       MOV     DPH,?V11
   \   000192   E0           MOVX    A,@DPTR
   \   000193   F9           MOV     R1,A
   \   000194   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000197   8A..         MOV     ?V6,R2
   \   000199   8B..         MOV     ?V7,R3
   \   00019B   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
   1700          
   1701              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1702                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1703                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   00019E                ; Setup parameters for call to function zcl_SendCommand
   \   00019E   78..         MOV     R0,#?V2
   \   0001A0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A3   8E..         MOV     ?V4,R6
   \   0001A5   8F..         MOV     ?V5,R7
   \   0001A7   78..         MOV     R0,#?V4
   \   0001A9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001AC   7422         MOV     A,#0x22
   \   0001AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B1   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   0001B4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001B7   E4           CLR     A
   \   0001B8   F5..         MOV     ?V4,A
   \   0001BA   F5..         MOV     ?V5,A
   \   0001BC   78..         MOV     R0,#?V4
   \   0001BE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001C1   7424         MOV     A,#0x24
   \   0001C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C6   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   0001C9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001CC   7424         MOV     A,#0x24
   \   0001CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D1   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   0001D4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D7   75..00       MOV     ?V0,#0x0
   \   0001DA   78..         MOV     R0,#?V0
   \   0001DC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001DF   75..09       MOV     ?V0,#0x9
   \   0001E2   78..         MOV     R0,#?V0
   \   0001E4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001E7   AC..         MOV     R4,?V12
   \   0001E9   AD..         MOV     R5,?V13
   \   0001EB   740B         MOV     A,#0xb
   \   0001ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F0   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_371:
   \   0001F3   A9..         MOV     R1,?V1
   \   0001F5   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0001F8   740B         MOV     A,#0xb
   \   0001FA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FD   E9           MOV     A,R1
   \   0001FE   FE           MOV     R6,A
   1704              zcl_mem_free( buf );
   \   0001FF                ; Setup parameters for call to function osal_mem_free
   \   0001FF   AA..         MOV     R2,?V2
   \   000201   AB..         MOV     R3,?V3
   \   000203   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000206   8002         SJMP    ??zcl_SendReadReportCfgRspCmd_12
   1705            }
   1706            else
   1707            {
   1708              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   000208   7E10         MOV     R6,#0x10
   1709            }
   1710          
   1711            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_12:
   \   00020A   EE           MOV     A,R6
   \   00020B   F9           MOV     R1,A
   \   00020C   7402         MOV     A,#0x2
   \   00020E   02....       LJMP    ?Subroutine5 & 0xFFFF
   1712          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V6
   \   000004   85..83       MOV     DPH,?V7
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine152_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine153_0
   \   000001                ; // Fall through to label ??Subroutine153_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine153_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006                REQUIRE ??Subroutine154_0
   \   000006                ; // Fall through to label ??Subroutine154_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine154_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V0
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   000004   85..82       MOV     DPL,?V6
   \   000007   85..83       MOV     DPH,?V7
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine160_0
   \   000006                ; // Fall through to label ??Subroutine160_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000003   A3           INC     DPTR
   \   000004   22           RET
   1713          
   1714          /*********************************************************************
   1715           * @fn      zcl_SendReportCmd
   1716           *
   1717           * @brief   Send a Report command
   1718           *
   1719           * @param   dstAddr - destination address
   1720           * @param   clusterID - cluster ID
   1721           * @param   reportCmd - report command to be sent
   1722           * @param   direction - direction of the command
   1723           * @param   seqNum - transaction sequence number
   1724           *
   1725           * @return  ZSuccess if OK
   1726           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1727          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1728                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1729                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1730          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1731            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1732            uint8 *buf;
   1733            ZStatus_t status;
   1734            uint8 i;
   1735          
   1736            // calculate the size of the command
   1737            for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000013   75..00       MOV     ?V2,#0x0
   \   000016   7416         MOV     A,#0x16
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00001E   8009         SJMP    ??CrossCallReturnLabel_190
   1738            {
   1739              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_0:
   \   000020   12....       LCALL   ?Subroutine58 & 0xFFFF
   1740          
   1741              dataLen += 2 + 1; // Attribute ID + data type
   1742          
   1743              // Attribute Data
   1744              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1745            }
   \                     ??CrossCallReturnLabel_95:
   \   000023   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000026   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000029   85..82       MOV     DPL,?V4
   \   00002C   85..83       MOV     DPH,?V5
   \   00002F   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_413:
   \   000032   40EC         JC      ??zcl_SendReportCmd_0
   1746          
   1747            buf = zcl_mem_alloc( dataLen );
   \   000034                ; Setup parameters for call to function osal_mem_alloc
   \   000034   EE           MOV     A,R6
   \   000035   FA           MOV     R2,A
   \   000036   EF           MOV     A,R7
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V0,R2
   \   00003D   8B..         MOV     ?V1,R3
   1748            if ( buf != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V1
   \   000042   7003         JNZ     $+5
   \   000044   02....       LJMP    ??zcl_SendReportCmd_1 & 0xFFFF
   1749            {
   1750              // Load the buffer - serially
   1751              uint8 *pBuf = buf;
   \   000047   A8..         MOV     R0,?V0
   \   000049   A9..         MOV     R1,?V1
   1752          
   1753              for ( i = 0; i < reportCmd->numAttr; i++ )
   \   00004B   75..00       MOV     ?V2,#0x0
   \   00004E   8010         SJMP    ??zcl_SendReportCmd_2
   1754              {
   1755                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_3:
   \   000050   12....       LCALL   ?Subroutine12 & 0xFFFF
   1756          
   1757                *pBuf++ = LO_UINT16( reportRec->attrID );
   1758                *pBuf++ = HI_UINT16( reportRec->attrID );
   1759                *pBuf++ = reportRec->dataType;
   1760          
   1761                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1762              }
   \                     ??CrossCallReturnLabel_1:
   \   000053   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000056   8A..         MOV     ?V10,R2
   \   000058   8B..         MOV     ?V11,R3
   \   00005A   A8..         MOV     R0,?V10
   \   00005C   A9..         MOV     R1,?V11
   \   00005E   05..         INC     ?V2
   \                     ??zcl_SendReportCmd_2:
   \   000060   85..82       MOV     DPL,?V4
   \   000063   85..83       MOV     DPH,?V5
   \   000066   E0           MOVX    A,@DPTR
   \   000067   FA           MOV     R2,A
   \   000068   E5..         MOV     A,?V2
   \   00006A   C3           CLR     C
   \   00006B   9A           SUBB    A,R2
   \   00006C   40E2         JC      ??zcl_SendReportCmd_3
   1763          
   1764              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1765                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00006E                ; Setup parameters for call to function zcl_SendCommand
   \   00006E   78..         MOV     R0,#?V0
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   8E..         MOV     ?V4,R6
   \   000075   8F..         MOV     ?V5,R7
   \   000077   78..         MOV     R0,#?V4
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   741E         MOV     A,#0x1e
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000087   E4           CLR     A
   \   000088   F5..         MOV     ?V4,A
   \   00008A   F5..         MOV     ?V5,A
   \   00008C   78..         MOV     R0,#?V4
   \   00008E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000091   7420         MOV     A,#0x20
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009C   7420         MOV     A,#0x20
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   75..00       MOV     ?V2,#0x0
   \   0000AA   78..         MOV     R0,#?V2
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AF   75..0A       MOV     ?V2,#0xa
   \   0000B2   78..         MOV     R0,#?V2
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B7   AC..         MOV     R4,?V6
   \   0000B9   AD..         MOV     R5,?V7
   \   0000BB   AA..         MOV     R2,?V8
   \   0000BD   AB..         MOV     R3,?V9
   \   0000BF   A9..         MOV     R1,?V3
   \   0000C1   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000C4   740B         MOV     A,#0xb
   \   0000C6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C9   E9           MOV     A,R1
   \   0000CA   FE           MOV     R6,A
   1766              zcl_mem_free( buf );
   \   0000CB                ; Setup parameters for call to function osal_mem_free
   \   0000CB   AA..         MOV     R2,?V0
   \   0000CD   AB..         MOV     R3,?V1
   \   0000CF   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000D2   8002         SJMP    ??zcl_SendReportCmd_4
   1767            }
   1768            else
   1769            {
   1770              status = ZMemError;
   \                     ??zcl_SendReportCmd_1:
   \   0000D4   7E10         MOV     R6,#0x10
   1771            }
   1772          
   1773            return ( status );
   \                     ??zcl_SendReportCmd_4:
   \   0000D6   02....       LJMP    ?Subroutine11 & 0xFFFF
   1774          }
   1775          #endif
   1776          
   1777          /*********************************************************************
   1778           * @fn      zcl_SendDefaultRspCmd
   1779           *
   1780           * @brief   Send a Default Response command
   1781           *
   1782           *          Note: The manufacturer code field should be set if this
   1783           *          command is being sent in response to a manufacturer specific
   1784           *          command.
   1785           *
   1786           * @param   dstAddr - destination address
   1787           * @param   clusterID - cluster ID
   1788           * @param   defaultRspCmd - default response command to be sent
   1789           * @param   direction - direction of the command
   1790           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1791           * @param   seqNum - transaction sequence number
   1792           *
   1793           * @return  ZSuccess if OK
   1794           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1795          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1796                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1797                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1798          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine80 & 0xFFFF
   1799            uint8 buf[2]; // Command ID and Status;
   1800          
   1801            // Load the buffer - serially
   1802            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_137:
   \   000014   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000017   12....       LCALL   ?Subroutine23 & 0xFFFF
   1803            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_17:
   \   00001A   C0E0         PUSH    A
   \   00001C   7401         MOV     A,#0x1
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   D0E0         POP     A
   \   000023   F0           MOVX    @DPTR,A
   1804          
   1805            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1806                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000024                ; Setup parameters for call to function zcl_SendCommand
   \   000024   A8..         MOV     R0,?XSP + 0
   \   000026   A9..         MOV     R1,?XSP + 1
   \   000028   88..         MOV     ?V0,R0
   \   00002A   89..         MOV     ?V1,R1
   \   00002C   78..         MOV     R0,#?V0
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   75..02       MOV     ?V0,#0x2
   \   000034   75..00       MOV     ?V1,#0x0
   \   000037   78..         MOV     R0,#?V0
   \   000039   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003C   7416         MOV     A,#0x16
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000047   7415         MOV     A,#0x15
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00004F   7416         MOV     A,#0x16
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   000057   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005A   7416         MOV     A,#0x16
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   000062   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000065   75..00       MOV     ?V0,#0x0
   \   000068   78..         MOV     R0,#?V0
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006D   75..0B       MOV     ?V0,#0xb
   \   000070   78..         MOV     R0,#?V0
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000075   EE           MOV     A,R6
   \   000076   F9           MOV     R1,A
   \   000077   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00007A   740B         MOV     A,#0xb
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007F   7402         MOV     A,#0x2
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   \   000084   02....       LJMP    ?Subroutine3 & 0xFFFF
   1807          }
   1808          
   1809          #ifdef ZCL_DISCOVER
   1810          /*********************************************************************
   1811           * @fn      zcl_SendDiscoverCmdsCmd
   1812           *
   1813           * @brief   Send a Discover Commands command
   1814           *
   1815           * @param   dstAddr - destination address
   1816           * @param   clusterID - cluster ID
   1817           * @param   cmdType - requesting command ID
   1818           * @param   pDiscoverCmd - discover command to be sent
   1819           * @param   direction - direction of the command
   1820           * @param   seqNum - transaction sequence number
   1821           *
   1822           * @return  ZSuccess if OK
   1823           */
   1824          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1825                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1826                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1827          {
   1828            uint8 payload[2]; // size of startCmdID and maxCmdID
   1829            ZStatus_t status;
   1830          
   1831            payload[0] = pDiscoverCmd->startCmdID;
   1832            payload[1] = pDiscoverCmd->maxCmdID;
   1833          
   1834            // Send message for either commands received or generated
   1835            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1836            {
   1837              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1838                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1839            }
   1840            else  // generated
   1841            {
   1842              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1843                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1844            }
   1845          
   1846            return ( status );
   1847          }
   1848          
   1849          /*********************************************************************
   1850           * @fn      zcl_SendDiscoverCmdsRspCmd
   1851           *
   1852           * @brief   Send a Discover Commands Response command
   1853           *
   1854           * @param   dstAddr - destination address
   1855           * @param   clusterID - cluster ID
   1856           * @param   pDiscoverRspCmd - response command to be sent
   1857           * @param   direction - direction of the command
   1858           * @param   seqNum - transaction sequence number
   1859           *
   1860           * @return  ZSuccess if OK
   1861           */
   1862          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1863                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1864                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1865          {
   1866            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1867            uint8 *pCmdBuf;
   1868            uint8 i;
   1869            ZStatus_t status = ZSuccess;
   1870          
   1871            // allocate memory
   1872            pCmdBuf = zcl_mem_alloc( payloadSize );
   1873            if ( pCmdBuf != NULL )
   1874            {
   1875              uint8 *pBuf = pCmdBuf;
   1876          
   1877              // Load the buffer - serially
   1878              *pBuf++ = pDiscoverRspCmd->discComplete;
   1879              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1880              {
   1881                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1882              }
   1883          
   1884              // Send response message for either commands received or generated
   1885              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1886              {
   1887                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1888                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1889              }
   1890              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1891              {
   1892                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1893                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1894              }
   1895          
   1896              zcl_mem_free( pCmdBuf );
   1897            }
   1898            else
   1899            {
   1900              status = ZMemError;
   1901            }
   1902          
   1903            return ( status );
   1904          }
   1905          
   1906          /*********************************************************************
   1907           * @fn      zcl_SendDiscoverAttrsCmd
   1908           *
   1909           * @brief   Send a Discover Attributes command
   1910           *
   1911           * @param   dstAddr - destination address
   1912           * @param   clusterID - cluster ID
   1913           * @param   pDiscoverCmd - discover command to be sent
   1914           * @param   direction - direction of the command
   1915           * @param   seqNum - transaction sequence number
   1916           *
   1917           * @return  ZSuccess if OK
   1918           */
   1919          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1920                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1921                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1922          {
   1923            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1924            uint8 *buf;
   1925            ZStatus_t status;
   1926          
   1927            buf = zcl_mem_alloc( dataLen );
   1928            if ( buf != NULL )
   1929            {
   1930              // Load the buffer - serially
   1931              uint8 *pBuf = buf;
   1932              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1933              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1934              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1935          
   1936              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1937                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1938              zcl_mem_free( buf );
   1939            }
   1940            else
   1941            {
   1942              status = ZMemError;
   1943            }
   1944          
   1945            return ( status );
   1946          }
   1947          
   1948          /*********************************************************************
   1949           * @fn      zcl_SendDiscoverAttrsRspCmd
   1950           *
   1951           * @brief   Send a Discover Attributes Response command
   1952           *
   1953           * @param   dstAddr - destination address
   1954           * @param   clusterID - cluster ID
   1955           * @param   reportRspCmd - report response command to be sent
   1956           * @param   direction - direction of the command
   1957           * @param   seqNum - transaction sequence number
   1958           *
   1959           * @return  ZSuccess if OK
   1960           */
   1961          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1962                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1963                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1964          {
   1965            uint16 dataLen = 1; // Discovery complete
   1966            uint8 *buf;
   1967            ZStatus_t status;
   1968          
   1969            // calculate the size of the command
   1970            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1971          
   1972            buf = zcl_mem_alloc( dataLen );
   1973            if ( buf != NULL )
   1974            {
   1975              // Load the buffer - serially
   1976              uint8 i;
   1977              uint8 *pBuf = buf;
   1978          
   1979              *pBuf++ = pDiscoverRspCmd->discComplete;
   1980          
   1981              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1982              {
   1983                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1984                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1985                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1986              }
   1987          
   1988              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1989                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1990              zcl_mem_free( buf );
   1991            }
   1992            else
   1993            {
   1994              status = ZMemError;
   1995            }
   1996          
   1997            return ( status );
   1998          }
   1999          
   2000          /*********************************************************************
   2001           * @fn      zcl_SendDiscoverAttrsExt
   2002           *
   2003           * @brief   Send a Discover Attributes Extended command
   2004           *
   2005           * @param   dstAddr - destination address
   2006           * @param   clusterID - cluster ID
   2007           * @param   pDiscoverAttrsExt:
   2008           *            - startAttrID: the first attribute to be selected
   2009           *            - maxAttrIDs: maximum number of returned attributes
   2010           * @param   direction - direction of the command
   2011           * @param   seqNum - transaction sequence number
   2012           *
   2013           * @return  ZSuccess if OK
   2014           */
   2015          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   2016                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   2017                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2018          {
   2019            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   2020            ZStatus_t status;
   2021          
   2022            // Load the buffer - serially
   2023            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   2024            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   2025            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   2026          
   2027            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   2028                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   2029          
   2030            return ( status );
   2031          }
   2032          
   2033          /*********************************************************************
   2034           * @fn      zcl_SendDiscoverAttrsExtRsp
   2035           *
   2036           * @brief   Send a Discover Attributes Extended Response command
   2037           *
   2038           * @param   dstAddr - destination address
   2039           * @param   clusterID - cluster ID
   2040           * @param   pDiscoverRspCmd:
   2041           *            - discComplete: indicates whether all requested attributes returned
   2042           *            - attrID: attribute ID
   2043           *            - attrDataType: data type of the given attribute
   2044           *            - attrAccessControl: access control of the given attribute
   2045           * @param   direction - direction of the command
   2046           * @param   seqNum - transaction sequence number
   2047           *
   2048           * @return  ZSuccess if OK
   2049           */
   2050          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   2051                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   2052                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2053          {
   2054            uint8 *buf;
   2055            uint8 i;
   2056            uint16 dataLen = 1; // Discovery complete
   2057            ZStatus_t status;
   2058          
   2059            // calculate the size of the command
   2060            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   2061          
   2062            buf = zcl_mem_alloc( dataLen );
   2063            if ( buf != NULL )
   2064            {
   2065              // Load the buffer - serially
   2066              uint8 *pBuf = buf;
   2067              *pBuf++ = pDiscoverRspCmd->discComplete;
   2068              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   2069              {
   2070                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   2071                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   2072                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   2073                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   2074              }
   2075          
   2076              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   2077                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   2078              zcl_mem_free( buf );
   2079            }
   2080            else
   2081            {
   2082              status = ZMemError;
   2083            }
   2084          
   2085            return ( status );
   2086          }
   2087          #endif // ZCL_DISCOVER
   2088          
   2089          /*********************************************************************
   2090           * @fn      zcl_ProcessMessageMSG
   2091           *
   2092           * @brief   Data message processor callback.  This function processes
   2093           *          any incoming data - probably from other devices.  So, based
   2094           *          on cluster ID, perform the intended action.
   2095           *
   2096           * @param   pkt - incoming message
   2097           *
   2098           * @return  zclProcMsgStatus_t
   2099           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2100          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   2101          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2102            endPointDesc_t *epDesc;
   2103            zclIncoming_t inMsg;
   2104            zclLibPlugin_t *pInPlugin;
   2105            zclDefaultRspCmd_t defautlRspCmd;
   2106            uint8 options;
   2107            uint8 securityEnable;
   2108            uint8 interPanMsg;
   2109            ZStatus_t status = ZFailure;
   2110            uint8 defaultResponseSent = FALSE;
   \   00000E   75..00       MOV     ?V2,#0x0
   2111          
   2112            if ( pkt->cmd.DataLength < ZCL_VALID_MIN_HEADER_LEN  )
   \   000011   EE           MOV     A,R6
   \   000012   2420         ADD     A,#0x20
   \   000014   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   000017   C3           CLR     C
   \   000018   E0           MOVX    A,@DPTR
   \   000019   9403         SUBB    A,#0x3
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   9400         SUBB    A,#0x0
   \   00001F   5005         JNC     ??zcl_ProcessMessageMSG_0
   2113            {
   2114              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   000021   7901         MOV     R1,#0x1
   \   000023   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2115            }
   2116          
   2117            // Initialize
   2118            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   000026   90....       MOV     DPTR,#rawAFMsg
   \   000029   EE           MOV     A,R6
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   EF           MOV     A,R7
   \   00002D   F0           MOVX    @DPTR,A
   2119            inMsg.msg = pkt;
   \   00002E   7402         MOV     A,#0x2
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   EE           MOV     A,R6
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   EF           MOV     A,R7
   \   000037   F0           MOVX    @DPTR,A
   2120            inMsg.attrCmd = NULL;
   \   000038   740E         MOV     A,#0xe
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E4           CLR     A
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   F0           MOVX    @DPTR,A
   2121            inMsg.pData = NULL;
   \   000041   740A         MOV     A,#0xa
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   E4           CLR     A
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   F0           MOVX    @DPTR,A
   2122            inMsg.pDataLen = 0;
   \   00004A   740C         MOV     A,#0xc
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   E4           CLR     A
   \   000050   F0           MOVX    @DPTR,A
   \   000051   A3           INC     DPTR
   \   000052   F0           MOVX    @DPTR,A
   2123          
   2124            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000053   EE           MOV     A,R6
   \   000054   2422         ADD     A,#0x22
   \   000056   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   000059   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_426:
   \   00005C   7404         MOV     A,#0x4
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   12....       LCALL   `??zclParseHdr::?relay`; Banked call to: zclParseHdr
   \   000068   8A..         MOV     ?V6,R2
   \   00006A   8B..         MOV     ?V7,R3
   \   00006C   A8..         MOV     R0,?V6
   \   00006E   A9..         MOV     R1,?V7
   \   000070   740A         MOV     A,#0xa
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   2125            inMsg.pDataLen = pkt->cmd.DataLength;
   2126            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_257:
   \   000078   85..82       MOV     DPL,?V4
   \   00007B   85..83       MOV     DPH,?V5
   \   00007E   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_372:
   \   000081   EA           MOV     A,R2
   \   000082   C3           CLR     C
   \   000083   98           SUBB    A,R0
   \   000084   F8           MOV     R0,A
   \   000085   EB           MOV     A,R3
   \   000086   99           SUBB    A,R1
   \   000087   F9           MOV     R1,A
   \   000088   85..82       MOV     DPL,?V0
   \   00008B   85..83       MOV     DPH,?V1
   \   00008E   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000091   740C         MOV     A,#0xc
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   2127          
   2128            // Temporary workaround to allow callback functions access to the
   2129            // transaction sequence number.  Callback functions will call
   2130            // zcl_getParsedTransSeqNum() to retrieve this number.
   2131            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_258:
   \   000099   7408         MOV     A,#0x8
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   0000A2   F0           MOVX    @DPTR,A
   2132          
   2133            // Find the wanted endpoint
   2134            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000A3   EE           MOV     A,R6
   \   0000A4   2414         ADD     A,#0x14
   \   0000A6   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   F9           MOV     R1,A
   \   0000AB   12....       LCALL   `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   0000AE   8A82         MOV     DPL,R2
   \   0000B0   8B83         MOV     DPH,R3
   2135            if ( epDesc == NULL )
   \   0000B2   E582         MOV     A,DPL
   \   0000B4   4583         ORL     A,DPH
   \   0000B6   700C         JNZ     ??zcl_ProcessMessageMSG_2
   2136            {
   2137              rawAFMsg = NULL;
   \   0000B8   90....       MOV     DPTR,#rawAFMsg
   \   0000BB   E4           CLR     A
   \   0000BC   F0           MOVX    @DPTR,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   F0           MOVX    @DPTR,A
   2138              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000BF   7902         MOV     R1,#0x2
   \   0000C1   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2139            }
   2140          
   2141            if ( ( epDesc->simpleDesc == NULL ) ||
   2142                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   2143                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000C4   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   0000C7   602B         JZ      ??zcl_ProcessMessageMSG_3
   \   0000C9   EE           MOV     A,R6
   \   0000CA   2404         ADD     A,#0x4
   \   0000CC   F5..         MOV     ?V4,A
   \   0000CE   E4           CLR     A
   \   0000CF   3F           ADDC    A,R7
   \   0000D0   F5..         MOV     ?V5,A
   \   0000D2                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000D2   A3           INC     DPTR
   \   0000D3   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000D6   740B         MOV     A,#0xb
   \   0000D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DB   E0           MOVX    A,@DPTR
   \   0000DC   FD           MOV     R5,A
   \   0000DD   7406         MOV     A,#0x6
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   5403         ANL     A,#0x3
   \   0000E5   FC           MOV     R4,A
   \   0000E6   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   0000E9   12....       LCALL   `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   0000EC   7402         MOV     A,#0x2
   \   0000EE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F1   E9           MOV     A,R1
   \   0000F2   700C         JNZ     ??zcl_ProcessMessageMSG_4
   2144            {
   2145              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   0000F4   90....       MOV     DPTR,#rawAFMsg
   \   0000F7   E4           CLR     A
   \   0000F8   F0           MOVX    @DPTR,A
   \   0000F9   A3           INC     DPTR
   \   0000FA   F0           MOVX    @DPTR,A
   2146              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   0000FB   7903         MOV     R1,#0x3
   \   0000FD   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2147            }
   2148          
   2149          #if defined ( INTER_PAN )
   2150            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   2151            {
   2152              // No foundation command is supported thru Inter-PAN communication.
   2153              // But the Light Link cluster uses a different Frame Control format
   2154              // for it's Inter-PAN messages, where the messages could be confused
   2155              // with the foundation commands.
   2156              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   2157              {
   2158                rawAFMsg = NULL;
   2159                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   2160              }
   2161          
   2162              interPanMsg = TRUE;
   2163              options = AF_TX_OPTIONS_NONE;
   2164            }
   2165            else
   2166          #endif
   2167            {
   2168              interPanMsg = FALSE;
   2169              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   000100                ; Setup parameters for call to function zclGetClusterOption
   \   000100   12....       LCALL   ?Subroutine41 & 0xFFFF
   2170            }
   \                     ??CrossCallReturnLabel_45:
   \   000103   12....       LCALL   `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   000106   E9           MOV     A,R1
   \   000107   F5..         MOV     ?V3,A
   2171          
   2172            // Find the appropriate plugin
   2173            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   000109   85..82       MOV     DPL,?V4
   \   00010C   85..83       MOV     DPH,?V5
   \   00010F   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_373:
   \   000112   EA           MOV     A,R2
   \   000113   FC           MOV     R4,A
   \   000114   EB           MOV     A,R3
   \   000115   FD           MOV     R5,A
   \   000116   90....       MOV     DPTR,#plugins
   \   000119   8004         SJMP    ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   00011B   8882         MOV     DPL,R0
   \   00011D   8983         MOV     DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   00011F   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   000122   7003         JNZ     $+5
   \   000124   02....       LJMP    ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   000127   8882         MOV     DPL,R0
   \   000129   8983         MOV     DPH,R1
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   12....       LCALL   ??Subroutine170_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_361:
   \   000130   C3           CLR     C
   \   000131   EC           MOV     A,R4
   \   000132   95..         SUBB    A,?V6
   \   000134   ED           MOV     A,R5
   \   000135   95..         SUBB    A,?V7
   \   000137   40E2         JC      ??zcl_ProcessMessageMSG_6
   \   000139   8882         MOV     DPL,R0
   \   00013B   8983         MOV     DPH,R1
   \   00013D   A3           INC     DPTR
   \   00013E   A3           INC     DPTR
   \   00013F   A3           INC     DPTR
   \   000140   A3           INC     DPTR
   \   000141   C3           CLR     C
   \   000142   E0           MOVX    A,@DPTR
   \   000143   9C           SUBB    A,R4
   \   000144   A3           INC     DPTR
   \   000145   E0           MOVX    A,@DPTR
   \   000146   9D           SUBB    A,R5
   \   000147   40D2         JC      ??zcl_ProcessMessageMSG_6
   \   000149   E8           MOV     A,R0
   \   00014A   FC           MOV     R4,A
   \   00014B   E9           MOV     A,R1
   \   00014C   FD           MOV     R5,A
   \   00014D   7404         MOV     A,#0x4
   \   00014F   12....       LCALL   ?XSTACK_DISP0_8
   \   000152   E0           MOVX    A,@DPTR
   \   000153   5407         ANL     A,#0x7
   \   000155   700D         JNZ     ??zcl_ProcessMessageMSG_8
   \   000157   7409         MOV     A,#0x9
   \   000159   12....       LCALL   ?XSTACK_DISP0_8
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   640B         XRL     A,#0xb
   \   00015F   7003         JNZ     $+5
   \   000161   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2174          
   2175            // Local and remote Security options must match except for Default Response command
   2176            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   2177            {
   2178              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_8:
   \   000164   E5..         MOV     A,?V3
   \   000166   A2E6         MOV     C,0xE0 /* A   */.6
   \   000168   4003         JC      $+5
   \   00016A   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   00016D   EE           MOV     A,R6
   \   00016E   2419         ADD     A,#0x19
   \   000170   F582         MOV     DPL,A
   \   000172   E4           CLR     A
   \   000173   3F           ADDC    A,R7
   \   000174   F583         MOV     DPH,A
   \   000176   E0           MOVX    A,@DPTR
   \   000177   6003         JZ      $+5
   \   000179   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2179          
   2180              // Make sure that Clusters specifically defined to use security are received secure,
   2181              // any other cluster that wants to use APS security will be allowed
   2182              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   2183              {
   2184                if ( UNICAST_MSG( inMsg.msg ) )
   \   00017C   7402         MOV     A,#0x2
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000184   707D         JNZ     ??zcl_ProcessMessageMSG_10
   \   000186   7402         MOV     A,#0x2
   \   000188   12....       LCALL   ?XSTACK_DISP0_8
   \   00018B   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   00018E   7073         JNZ     ??zcl_ProcessMessageMSG_10
   2185                {
   2186                  // Send a Default Response command back with no Application Link Key security
   2187                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   000190                ; Setup parameters for call to function zclSetSecurityOption
   \   000190   7C00         MOV     R4,#0x0
   \   000192   85..82       MOV     DPL,?V0
   \   000195   85..83       MOV     DPH,?V1
   \   000198   E0           MOVX    A,@DPTR
   \   000199   F9           MOV     R1,A
   \   00019A   12....       LCALL   `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2188          
   2189                  defautlRspCmd.statusCode = status;
   \   00019D   7401         MOV     A,#0x1
   \   00019F   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A2   7401         MOV     A,#0x1
   \   0001A4   F0           MOVX    @DPTR,A
   2190                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001A5   7409         MOV     A,#0x9
   \   0001A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AA   12....       LCALL   ?Subroutine75 & 0xFFFF
   2191                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2192                                         inMsg.msg->clusterId, &defautlRspCmd,
   2193                                         !inMsg.hdr.fc.direction, true,
   2194                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_125:
   \   0001AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B0   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0001B3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001B6   7407         MOV     A,#0x7
   \   0001B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BB   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001BE   75..01       MOV     ?V2,#0x1
   \   0001C1   78..         MOV     R0,#?V2
   \   0001C3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C6   7408         MOV     A,#0x8
   \   0001C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CB   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   0001CE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D1   7405         MOV     A,#0x5
   \   0001D3   12....       LCALL   ?XSTACK_DISP100_8
   \   0001D6   88..         MOV     ?V2,R0
   \   0001D8   89..         MOV     ?V3,R1
   \   0001DA   78..         MOV     R0,#?V2
   \   0001DC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DF   7409         MOV     A,#0x9
   \   0001E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E4   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0001E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EA   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   0001ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F0   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   0001F3   12....       LCALL   `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   0001F6   7407         MOV     A,#0x7
   \   0001F8   12....       LCALL   ?DEALLOC_XSTACK8
   2195          
   2196                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   0001FB                ; Setup parameters for call to function zclSetSecurityOption
   \   0001FB   7C01         MOV     R4,#0x1
   \   0001FD   12....       LCALL   ?Subroutine41 & 0xFFFF
   2197                }
   \                     ??CrossCallReturnLabel_46:
   \   000200   12....       LCALL   `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2198          
   2199                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_10:
   \   000203   90....       MOV     DPTR,#rawAFMsg
   \   000206   E4           CLR     A
   \   000207   F0           MOVX    @DPTR,A
   \   000208   A3           INC     DPTR
   \   000209   F0           MOVX    @DPTR,A
   2200                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   00020A   7905         MOV     R1,#0x5
   \   00020C   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2201              }
   2202            }
   \                     ??zcl_ProcessMessageMSG_7:
   \   00020F   7C00         MOV     R4,#0x0
   \   000211   7D00         MOV     R5,#0x0
   2203          
   2204            // Is this a foundation type message
   2205            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_9:
   \   000213   7404         MOV     A,#0x4
   \   000215   12....       LCALL   ?XSTACK_DISP0_8
   \   000218   E0           MOVX    A,@DPTR
   \   000219   F8           MOV     R0,A
   \   00021A   5403         ANL     A,#0x3
   \   00021C   6003         JZ      $+5
   \   00021E   02....       LJMP    ??zcl_ProcessMessageMSG_11 & 0xFFFF
   2206            {
   2207              if ( inMsg.hdr.fc.manuSpecific )
   \   000221   E8           MOV     A,R0
   \   000222   5404         ANL     A,#0x4
   \   000224   6005         JZ      ??zcl_ProcessMessageMSG_12
   2208              {
   2209                // We don't support any manufacturer specific command
   2210                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000226   7E84         MOV     R6,#-0x7c
   \   000228   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   2211              }
   2212              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   2213                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_12:
   \   00022B   7409         MOV     A,#0x9
   \   00022D   12....       LCALL   ?XSTACK_DISP0_8
   \   000230   E0           MOVX    A,@DPTR
   \   000231   F5..         MOV     ?V4,A
   \   000233   C3           CLR     C
   \   000234   9417         SUBB    A,#0x17
   \   000236   4003         JC      $+5
   \   000238   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   \   00023B   75..00       MOV     ?V5,#0x0
   \   00023E   7402         MOV     A,#0x2
   \   000240   78..         MOV     R0,#?V4
   \   000242   12....       LCALL   ?S_SHL
   \   000245   74..         MOV     A,#zclCmdTable & 0xff
   \   000247   25..         ADD     A,?V4
   \   000249   F582         MOV     DPL,A
   \   00024B   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   00024D   35..         ADDC    A,?V5
   \   00024F   F583         MOV     DPH,A
   \   000251   E4           CLR     A
   \   000252   93           MOVC    A,@A+DPTR
   \   000253   F8           MOV     R0,A
   \   000254   7401         MOV     A,#0x1
   \   000256   93           MOVC    A,@A+DPTR
   \   000257   F9           MOV     R1,A
   \   000258   E8           MOV     A,R0
   \   000259   49           ORL     A,R1
   \   00025A   7003         JNZ     $+5
   \   00025C   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   2214              {
   2215                zclParseCmd_t parseCmd;
   2216          
   2217                parseCmd.endpoint = pkt->endPoint;
   \   00025F   85..82       MOV     DPL,?V0
   \   000262   85..83       MOV     DPH,?V1
   \   000265   E0           MOVX    A,@DPTR
   \   000266   C0E0         PUSH    A
   \   000268   7410         MOV     A,#0x10
   \   00026A   12....       LCALL   ?XSTACK_DISP0_8
   \   00026D   D0E0         POP     A
   \   00026F   F0           MOVX    @DPTR,A
   2218                parseCmd.dataLen = inMsg.pDataLen;
   \   000270   740C         MOV     A,#0xc
   \   000272   12....       LCALL   ?XSTACK_DISP0_8
   \   000275   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_374:
   \   000278   7411         MOV     A,#0x11
   \   00027A   12....       LCALL   ?XSTACK_DISP0_8
   \   00027D   12....       LCALL   ??Subroutine160_0 & 0xFFFF
   2219                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_328:
   \   000280   740A         MOV     A,#0xa
   \   000282   12....       LCALL   ?XSTACK_DISP0_8
   \   000285   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_375:
   \   000288   7413         MOV     A,#0x13
   \   00028A   12....       LCALL   ?XSTACK_DISP0_8
   \   00028D   12....       LCALL   ??Subroutine160_0 & 0xFFFF
   2220          
   2221                // Parse the command, remember that the return value is a pointer to allocated memory
   2222                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_329:
   \   000290                ; Setup parameters for indirect call
   \   000290   7410         MOV     A,#0x10
   \   000292   12....       LCALL   ?XSTACK_DISP101_8
   \   000295   8882         MOV     DPL,R0
   \   000297   8983         MOV     DPH,R1
   \   000299   12....       LCALL   ?CALL_IND
   \   00029C   8A..         MOV     ?V0,R2
   \   00029E   8B..         MOV     ?V1,R3
   \   0002A0   A8..         MOV     R0,?V0
   \   0002A2   A9..         MOV     R1,?V1
   \   0002A4   740E         MOV     A,#0xe
   \   0002A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A9   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   2223                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_259:
   \   0002AC   E8           MOV     A,R0
   \   0002AD   49           ORL     A,R1
   \   0002AE   604C         JZ      ??zcl_ProcessMessageMSG_15
   \   0002B0   7409         MOV     A,#0x9
   \   0002B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B5   E0           MOVX    A,@DPTR
   \   0002B6   F5..         MOV     ?V0,A
   \   0002B8   75..00       MOV     ?V1,#0x0
   \   0002BB   7402         MOV     A,#0x2
   \   0002BD   78..         MOV     R0,#?V0
   \   0002BF   12....       LCALL   ?S_SHL
   \   0002C2   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   0002C4   25..         ADD     A,?V0
   \   0002C6   F582         MOV     DPL,A
   \   0002C8   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0002CA   35..         ADDC    A,?V1
   \   0002CC   F583         MOV     DPH,A
   \   0002CE   E4           CLR     A
   \   0002CF   93           MOVC    A,@A+DPTR
   \   0002D0   F8           MOV     R0,A
   \   0002D1   7401         MOV     A,#0x1
   \   0002D3   93           MOVC    A,@A+DPTR
   \   0002D4   F9           MOV     R1,A
   \   0002D5   8882         MOV     DPL,R0
   \   0002D7   8983         MOV     DPH,R1
   \   0002D9   E582         MOV     A,DPL
   \   0002DB   4583         ORL     A,DPH
   \   0002DD   6012         JZ      ??zcl_ProcessMessageMSG_16
   2224                {
   2225                  // Process the command
   2226                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0002DF                ; Setup parameters for indirect call
   \   0002DF   7402         MOV     A,#0x2
   \   0002E1   12....       LCALL   ?XSTACK_DISP101_8
   \   0002E4   12....       LCALL   ?CALL_IND
   2227                  {
   2228                    // Couldn't find attribute in the table.
   2229                  }
   2230                }
   2231          
   2232                // Free the buffer
   2233                if ( inMsg.attrCmd )
   \   0002E7   740E         MOV     A,#0xe
   \   0002E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0002EC   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_350:
   \   0002EF   600B         JZ      ??zcl_ProcessMessageMSG_15
   2234                {
   2235                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_16:
   \   0002F1                ; Setup parameters for call to function osal_mem_free
   \   0002F1   740E         MOV     A,#0xe
   \   0002F3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F6   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   2236                }
   \                     ??CrossCallReturnLabel_376:
   \   0002F9   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2237          
   2238                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_15:
   \   0002FC   7409         MOV     A,#0x9
   \   0002FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000301   E0           MOVX    A,@DPTR
   \   000302   F8           MOV     R0,A
   \   000303   6053         JZ      ??zcl_ProcessMessageMSG_17
   \   000305   7402         MOV     A,#0x2
   \   000307   68           XRL     A,R0
   \   000308   604E         JZ      ??zcl_ProcessMessageMSG_17
   \   00030A   7403         MOV     A,#0x3
   \   00030C   68           XRL     A,R0
   \   00030D   6049         JZ      ??zcl_ProcessMessageMSG_17
   \   00030F   7406         MOV     A,#0x6
   \   000311   68           XRL     A,R0
   \   000312   6044         JZ      ??zcl_ProcessMessageMSG_17
   \   000314   7408         MOV     A,#0x8
   \   000316   68           XRL     A,R0
   \   000317   603F         JZ      ??zcl_ProcessMessageMSG_17
   \   000319   740C         MOV     A,#0xc
   \   00031B   68           XRL     A,R0
   \   00031C   603A         JZ      ??zcl_ProcessMessageMSG_17
   \   00031E   7411         MOV     A,#0x11
   \   000320   68           XRL     A,R0
   \   000321   6035         JZ      ??zcl_ProcessMessageMSG_17
   \   000323   7413         MOV     A,#0x13
   \   000325   68           XRL     A,R0
   \   000326   6030         JZ      ??zcl_ProcessMessageMSG_17
   \   000328   7415         MOV     A,#0x15
   \   00032A   68           XRL     A,R0
   \   00032B   602B         JZ      ??zcl_ProcessMessageMSG_17
   \   00032D   740B         MOV     A,#0xb
   \   00032F   68           XRL     A,R0
   \   000330   6026         JZ      ??zcl_ProcessMessageMSG_17
   2239                {
   2240                  rawAFMsg = NULL;
   2241                  return ( ZCL_PROC_SUCCESS ); // We're done
   2242                }
   2243          
   2244                status = ZSuccess;
   \   000332   7E00         MOV     R6,#0x0
   \   000334   8042         SJMP    ??zcl_ProcessMessageMSG_13
   2245              }
   2246              else
   2247              {
   2248                // Unsupported message
   2249                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_14:
   \   000336   7E82         MOV     R6,#-0x7e
   \   000338   803E         SJMP    ??zcl_ProcessMessageMSG_13
   2250              }
   2251            }
   2252            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2253            {
   2254              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_11:
   \   00033A   EC           MOV     A,R4
   \   00033B   4D           ORL     A,R5
   \   00033C   602A         JZ      ??zcl_ProcessMessageMSG_18
   \   00033E   8C82         MOV     DPL,R4
   \   000340   8D83         MOV     DPH,R5
   \   000342   A3           INC     DPTR
   \   000343   A3           INC     DPTR
   \   000344   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000347   601F         JZ      ??zcl_ProcessMessageMSG_18
   2255              {
   2256                // The return value of the plugin function will be
   2257                //  ZSuccess - Supported and need default response
   2258                //  ZFailure - Unsupported
   2259                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2260                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2261                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2262                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2263                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   000349                ; Setup parameters for indirect call
   \   000349   7402         MOV     A,#0x2
   \   00034B   12....       LCALL   ?XSTACK_DISP101_8
   \   00034E   12....       LCALL   ?CALL_IND
   \   000351   E9           MOV     A,R1
   \   000352   FE           MOV     R6,A
   2264                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000353   74FF         MOV     A,#-0x1
   \   000355   6E           XRL     A,R6
   \   000356   700B         JNZ     ??zcl_ProcessMessageMSG_19
   2265                {
   2266                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_17:
   \   000358   90....       MOV     DPTR,#rawAFMsg
   \   00035B   E4           CLR     A
   \   00035C   F0           MOVX    @DPTR,A
   \   00035D   A3           INC     DPTR
   \   00035E   F0           MOVX    @DPTR,A
   2267                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   00035F   F9           MOV     R1,A
   \   000360   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2268                }
   2269              }
   2270          
   2271              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_19:
   \   000363   7401         MOV     A,#0x1
   \   000365   6E           XRL     A,R6
   \   000366   7010         JNZ     ??zcl_ProcessMessageMSG_13
   2272              {
   2273                // Unsupported message
   2274                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_18:
   \   000368   7404         MOV     A,#0x4
   \   00036A   12....       LCALL   ?XSTACK_DISP0_8
   \   00036D   E0           MOVX    A,@DPTR
   \   00036E   5404         ANL     A,#0x4
   \   000370   6004         JZ      ??zcl_ProcessMessageMSG_20
   2275                {
   2276                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000372   7E83         MOV     R6,#-0x7d
   \   000374   8002         SJMP    ??zcl_ProcessMessageMSG_13
   2277                }
   2278                else
   2279                {
   2280                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_20:
   \   000376   7E81         MOV     R6,#-0x7f
   2281                }
   2282              }
   2283            }
   2284          
   2285            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_13:
   \   000378   7402         MOV     A,#0x2
   \   00037A   12....       LCALL   ?XSTACK_DISP0_8
   \   00037D   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000380   707B         JNZ     ??zcl_ProcessMessageMSG_21
   \   000382   7402         MOV     A,#0x2
   \   000384   12....       LCALL   ?XSTACK_DISP0_8
   \   000387   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_357:
   \   00038A   7071         JNZ     ??zcl_ProcessMessageMSG_21
   \   00038C   7404         MOV     A,#0x4
   \   00038E   12....       LCALL   ?XSTACK_DISP0_8
   \   000391   E0           MOVX    A,@DPTR
   \   000392   FA           MOV     R2,A
   \   000393   5410         ANL     A,#0x10
   \   000395   7066         JNZ     ??zcl_ProcessMessageMSG_21
   2286            {
   2287              // Send a Default Response command back
   2288              defautlRspCmd.statusCode = status;
   \   000397   7401         MOV     A,#0x1
   \   000399   12....       LCALL   ?XSTACK_DISP0_8
   \   00039C   EE           MOV     A,R6
   \   00039D   F0           MOVX    @DPTR,A
   2289              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   00039E   7409         MOV     A,#0x9
   \   0003A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A3   12....       LCALL   ?Subroutine75 & 0xFFFF
   2290              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2291                                     inMsg.msg->clusterId, &defautlRspCmd,
   2292                                     !inMsg.hdr.fc.direction, true,
   2293                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_126:
   \   0003A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A9   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   0003AC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003AF   7407         MOV     A,#0x7
   \   0003B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B4   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0003B7   75..01       MOV     ?V0,#0x1
   \   0003BA   78..         MOV     R0,#?V0
   \   0003BC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003BF   EA           MOV     A,R2
   \   0003C0   13           RRC     A
   \   0003C1   13           RRC     A
   \   0003C2   13           RRC     A
   \   0003C3   541F         ANL     A,#0x1f
   \   0003C5   6401         XRL     A,#0x1
   \   0003C7   5401         ANL     A,#0x1
   \   0003C9   F5..         MOV     ?V0,A
   \   0003CB   78..         MOV     R0,#?V0
   \   0003CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003D0   7405         MOV     A,#0x5
   \   0003D2   12....       LCALL   ?XSTACK_DISP100_8
   \   0003D5   88..         MOV     ?V0,R0
   \   0003D7   89..         MOV     ?V1,R1
   \   0003D9   78..         MOV     R0,#?V0
   \   0003DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0003DE   7409         MOV     A,#0x9
   \   0003E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E3   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0003E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E9   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   0003EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003EF   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   0003F2   12....       LCALL   `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   0003F5   7407         MOV     A,#0x7
   \   0003F7   12....       LCALL   ?DEALLOC_XSTACK8
   2294              defaultResponseSent = TRUE;
   \   0003FA   75..01       MOV     ?V2,#0x1
   2295            }
   2296          
   2297            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   0003FD   90....       MOV     DPTR,#rawAFMsg
   \   000400   E4           CLR     A
   \   000401   F0           MOVX    @DPTR,A
   \   000402   A3           INC     DPTR
   \   000403   F0           MOVX    @DPTR,A
   2298            if ( status == ZSuccess )
   \   000404   EE           MOV     A,R6
   \   000405   7004         JNZ     ??zcl_ProcessMessageMSG_22
   2299            {
   2300              return ( ZCL_PROC_SUCCESS );
   \   000407   7900         MOV     R1,#0x0
   \   000409   801F         SJMP    ??zcl_ProcessMessageMSG_1
   2301            }
   2302            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_22:
   \   00040B   7484         MOV     A,#-0x7c
   \   00040D   6E           XRL     A,R6
   \   00040E   700E         JNZ     ??zcl_ProcessMessageMSG_23
   2303            {
   2304              if ( defaultResponseSent )
   \   000410   E5..         MOV     A,?V2
   \   000412   A2E0         MOV     C,0xE0 /* A   */.0
   \   000414   5004         JNC     ??zcl_ProcessMessageMSG_24
   2305              {
   2306                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   000416   7907         MOV     R1,#0x7
   \   000418   8010         SJMP    ??zcl_ProcessMessageMSG_1
   2307              }
   2308              else
   2309              {
   2310                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_24:
   \   00041A   7906         MOV     R1,#0x6
   \   00041C   800C         SJMP    ??zcl_ProcessMessageMSG_1
   2311              }
   2312            }
   2313            else
   2314            {
   2315              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_23:
   \   00041E   E5..         MOV     A,?V2
   \   000420   A2E0         MOV     C,0xE0 /* A   */.0
   \   000422   5004         JNC     ??zcl_ProcessMessageMSG_25
   2316              {
   2317                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   000424   7909         MOV     R1,#0x9
   \   000426   8002         SJMP    ??zcl_ProcessMessageMSG_1
   2318              }
   2319              else
   2320              {
   2321                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_25:
   \   000428   7908         MOV     R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   00042A   7415         MOV     A,#0x15
   2322              }
   2323            }
   \   00042C   02....       LJMP    ?Subroutine8 & 0xFFFF
   2324          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine157_0
   \   000001                ; // Fall through to label ??Subroutine157_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine157_0:
   \   000000   28           ADD     A,R0
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   39           ADDC    A,R1
   \   000005   F9           MOV     R1,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   F5..         MOV     ?V0,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V1,A
   \   000006                ; Setup parameters for call to function zclParseHdr
   \   000006                ; Setup parameters for call to function afFindEndPointDesc
   \   000006   85..82       MOV     DPL,?V0
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV     A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   C8           XCH     A,R0
   \   000003   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000006   38           ADDC    A,R0
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   C8           XCH     A,R0
   \   000005   2415         ADD     A,#0x15
   \   000007   F582         MOV     DPL,A
   \   000009   E4           CLR     A
   \   00000A   38           ADDC    A,R0
   \   00000B   F583         MOV     DPH,A
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000003   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_450:
   \   000006   7409         MOV     A,#0x9
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine158_0
   \   000004                ; // Fall through to label ??Subroutine158_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine158_0:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   000003   E582         MOV     A,DPL
   \   000005   4583         ORL     A,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ??Subroutine155_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_388:
   \   000009   85..82       MOV     DPL,?V0
   \   00000C   85..83       MOV     DPH,?V1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine166_0
   \   000003                ; // Fall through to label ??Subroutine166_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine166_0:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine168_0
   \   000004                ; // Fall through to label ??Subroutine168_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine142:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine170_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V6,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V7,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   F5..         MOV     ?V4,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V5,A
   \   000006   85..82       MOV     DPL,?V4
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000003   F5..         MOV     ?V2,A
   \   000005   78..         MOV     R0,#?V2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   6401         XRL     A,#0x1
   \   000008   5401         ANL     A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine183_0
   \   000004                ; // Fall through to label ??Subroutine183_0
   2325          
   2326          /*********************************************************************
   2327           * PRIVATE FUNCTIONS
   2328           *********************************************************************/
   2329          
   2330          /*********************************************************************
   2331           * @fn      zclParseHdr
   2332           *
   2333           * @brief   Parse header of the ZCL format
   2334           *
   2335           * @param   hdr - place to put the frame control information
   2336           * @param   pData - incoming buffer to parse
   2337           *
   2338           * @return  pointer past the header
   2339           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2340          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2341          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2342            // Clear the header
   2343            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2344          
   2345            // Parse the Frame Control
   2346            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0
   \   000019   85..83       MOV     DPH,?V1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   FA           MOV     R2,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FB           MOV     R3,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   5403         ANL     A,#0x3
   \   00002A   F8           MOV     R0,A
   \   00002B   EA           MOV     A,R2
   \   00002C   48           ORL     A,R0
   \   00002D   F8           MOV     R0,A
   \   00002E   EB           MOV     A,R3
   \   00002F   F9           MOV     R1,A
   \   000030   85..82       MOV     DPL,?V0
   \   000033   85..83       MOV     DPH,?V1
   \   000036   12....       LCALL   ?Subroutine22 & 0xFFFF
   2347            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_417:
   \   000039   A2E2         MOV     C,0xE0 /* A   */.2
   \   00003B   5004         JNC     ??zclParseHdr_0
   \   00003D   D2F0         SETB    B.0
   \   00003F   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000041   C2F0         CLR     B.0
   \                     ??zclParseHdr_1:
   \   000043   85..82       MOV     DPL,?V0
   \   000046   85..83       MOV     DPH,?V1
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   54FB         ANL     A,#0xfb
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A2F0         MOV     C,B.0
   \   00004F   E4           CLR     A
   \   000050   33           RLC     A
   \   000051   F5..         MOV     ?V2,A
   \   000053   75..00       MOV     ?V3,#0x0
   \   000056   7402         MOV     A,#0x2
   \   000058   78..         MOV     R0,#?V2
   \   00005A   12....       LCALL   ?S_SHL
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   45..         ORL     A,?V2
   \   000060   12....       LCALL   ??Subroutine177_0 & 0xFFFF
   2348            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_419:
   \   000063   A2E3         MOV     C,0xE0 /* A   */.3
   \   000065   85..82       MOV     DPL,?V0
   \   000068   85..83       MOV     DPH,?V1
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   5004         JNC     ??zclParseHdr_2
   2349            {
   2350              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00006E   4408         ORL     A,#0x8
   \   000070   8002         SJMP    ??zclParseHdr_3
   2351            }
   2352            else
   2353            {
   2354              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000072   54F7         ANL     A,#0xf7
   2355            }
   \                     ??zclParseHdr_3:
   \   000074   12....       LCALL   ??Subroutine177_0 & 0xFFFF
   2356          
   2357            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_420:
   \   000077   A2E4         MOV     C,0xE0 /* A   */.4
   \   000079   5004         JNC     ??zclParseHdr_4
   \   00007B   D2F0         SETB    B.0
   \   00007D   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   00007F   C2F0         CLR     B.0
   \                     ??zclParseHdr_5:
   \   000081   85..82       MOV     DPL,?V0
   \   000084   85..83       MOV     DPH,?V1
   \   000087   E0           MOVX    A,@DPTR
   \   000088   54EF         ANL     A,#0xef
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B   A2F0         MOV     C,B.0
   \   00008D   E4           CLR     A
   \   00008E   33           RLC     A
   \   00008F   F5..         MOV     ?V2,A
   \   000091   7404         MOV     A,#0x4
   \   000093   78..         MOV     R0,#?V2
   \   000095   12....       LCALL   ?S_SHL
   \   000098   E0           MOVX    A,@DPTR
   \   000099   45..         ORL     A,?V2
   \   00009B   12....       LCALL   ?Subroutine26 & 0xFFFF
   2358            pData++;  // move past the frame control field
   2359          
   2360            // parse the manfacturer code
   2361            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_21:
   \   00009E   85..82       MOV     DPL,?V0
   \   0000A1   85..83       MOV     DPH,?V1
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   5404         ANL     A,#0x4
   \   0000A7   6010         JZ      ??zclParseHdr_6
   2362            {
   2363              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   0000A9   8E82         MOV     DPL,R6
   \   0000AB   8F83         MOV     DPH,R7
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   FA           MOV     R2,A
   \   0000AF   A3           INC     DPTR
   \   0000B0   12....       LCALL   ?Subroutine78 & 0xFFFF
   2364              pData += 2;
   2365            }
   \                     ??CrossCallReturnLabel_133:
   \   0000B3   12....       LCALL   ??Subroutine161_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   0000B6   5001         JNC     ??zclParseHdr_6
   \   0000B8   0F           INC     R7
   2366          
   2367            // parse the Transaction Sequence Number
   2368            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   0000B9   8E82         MOV     DPL,R6
   \   0000BB   8F83         MOV     DPH,R7
   \   0000BD   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   2369          
   2370            // parse the Cluster's command ID
   2371            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_345:
   \   0000C5   85..82       MOV     DPL,?V0
   \   0000C8   85..83       MOV     DPH,?V1
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   F0           MOVX    @DPTR,A
   2372          
   2373            // Should point to the frame payload
   2374            return ( pData );
   \   0000D1   EE           MOV     A,R6
   \   0000D2   2402         ADD     A,#0x2
   \   0000D4   FA           MOV     R2,A
   \   0000D5   E4           CLR     A
   \   0000D6   3F           ADDC    A,R7
   \   0000D7   FB           MOV     R3,A
   \   0000D8   02....       LJMP    ?Subroutine1 & 0xFFFF
   2375          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine161_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine162_0
   \   000001                ; // Fall through to label ??Subroutine162_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine162_0:
   \   000000   A3           INC     DPTR
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   EE           MOV     A,R6
   \   000006   2402         ADD     A,#0x2
   \   000008   FE           MOV     R6,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine167_0:
   \   000000   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_422:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_397:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_423:
   \   000003   A3           INC     DPTR
   \   000004   AE82         MOV     R6,DPL
   \   000006   AF83         MOV     R7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   EA           MOV     A,R2
   \   000003   85..82       MOV     DPL,?V0
   \   000006   85..83       MOV     DPH,?V1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004                REQUIRE ??Subroutine177_0
   \   000004                ; // Fall through to label ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine177_0:
   \   000000   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_424:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET
   2376          
   2377          /*********************************************************************
   2378           * @fn      zclBuildHdr
   2379           *
   2380           * @brief   Build header of the ZCL format
   2381           *
   2382           * @param   hdr - outgoing header information
   2383           * @param   pData - outgoing header space
   2384           *
   2385           * @return  pointer past the header
   2386           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine152_0
   \   000003                ; // Fall through to label ??Subroutine152_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2387          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2388          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2389            // Build the Frame Control byte
   2390            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine164_0 & 0xFFFF
   2391            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_342:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine32 & 0xFFFF
   2392            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_340:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine32 & 0xFFFF
   2393            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_341:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   F8           MOV     R0,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   48           ORL     A,R0
   \   000026   F0           MOVX    @DPTR,A
   2394            pData++;  // move past the frame control field
   \   000027   A3           INC     DPTR
   \   000028   AC82         MOV     R4,DPL
   \   00002A   AD83         MOV     R5,DPH
   2395          
   2396            // Add the manfacturer code
   2397            if ( hdr->fc.manuSpecific )
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   E0           MOVX    A,@DPTR
   \   000031   5404         ANL     A,#0x4
   \   000033   6016         JZ      ??zclBuildHdr_0
   2398            {
   2399              *pData++ = LO_UINT16( hdr->manuCode );
   \   000035   12....       LCALL   ?Subroutine99 & 0xFFFF
   2400              *pData++ = HI_UINT16( hdr->manuCode );
   2401            }
   \                     ??CrossCallReturnLabel_339:
   \   000038   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   00003B   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00003E   8C82         MOV     DPL,R4
   \   000040   8D83         MOV     DPH,R5
   \   000042   A3           INC     DPTR
   \   000043   F0           MOVX    @DPTR,A
   \   000044   EC           MOV     A,R4
   \   000045   2402         ADD     A,#0x2
   \   000047   FC           MOV     R4,A
   \   000048   5001         JNC     ??zclBuildHdr_0
   \   00004A   0D           INC     R5
   2402          
   2403            // Add the Transaction Sequence Number
   2404            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   00004B   8A82         MOV     DPL,R2
   \   00004D   8B83         MOV     DPH,R3
   \   00004F   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   000052   12....       LCALL   ?Subroutine31 & 0xFFFF
   2405          
   2406            // Add the Cluster's command ID
   2407            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_34:
   \   000055   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   000058   A3           INC     DPTR
   \   000059   F0           MOVX    @DPTR,A
   2408          
   2409            // Should point to the frame payload
   2410            return ( pData );
   \   00005A   EC           MOV     A,R4
   \   00005B   2402         ADD     A,#0x2
   \   00005D   FA           MOV     R2,A
   \   00005E   E4           CLR     A
   \   00005F   3D           ADDC    A,R5
   \   000060   FB           MOV     R3,A
   \   000061   80..         SJMP    ??Subroutine165_0
   2411          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   F8           MOV     R0,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   48           ORL     A,R0
   \   000007                REQUIRE ??Subroutine164_0
   \   000007                ; // Fall through to label ??Subroutine164_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine164_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET
   2412          
   2413          /*********************************************************************
   2414           * @fn      zclCalcHdrSize
   2415           *
   2416           * @brief   Calculate the number of bytes needed for an outgoing
   2417           *          ZCL header.
   2418           *
   2419           * @param   hdr - outgoing header information
   2420           *
   2421           * @return  returns the number of bytes needed
   2422           */
   2423          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2424          {
   2425            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2426          
   2427            // Add the manfacturer code
   2428            if ( hdr->fc.manuSpecific )
   2429            {
   2430              needed += 2;
   2431            }
   2432          
   2433            return ( needed );
   2434          }
   2435          
   2436          /*********************************************************************
   2437           * @fn      zclFindPlugin
   2438           *
   2439           * @brief   Find the right plugin for a cluster ID
   2440           *
   2441           * @param   clusterID - cluster ID to look for
   2442           * @param   profileID - profile ID
   2443           *
   2444           * @return  pointer to plugin, NULL if not found
   2445           */
   2446          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2447          {
   2448            zclLibPlugin_t *pLoop = plugins;
   2449          
   2450            (void)profileID;  // Intentionally unreferenced parameter
   2451          
   2452            while ( pLoop != NULL )
   2453            {
   2454              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2455              {
   2456                return ( pLoop );
   2457              }
   2458          
   2459              pLoop = pLoop->next;
   2460            }
   2461          
   2462            return ( (zclLibPlugin_t *)NULL );
   2463          }
   2464          
   2465          #ifdef ZCL_DISCOVER
   2466          /*********************************************************************
   2467           * @fn      zclFindCmdRecsList
   2468           *
   2469           * @brief   Find the right command record list for an endpoint
   2470           *
   2471           * @param   endpoint - endpoint to look for
   2472           *
   2473           * @return  pointer to record list, NULL if not found
   2474           */
   2475          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2476          {
   2477            zclCmdRecsList_t *pLoop = gpCmdList;
   2478          
   2479            while ( pLoop != NULL )
   2480            {
   2481              if ( pLoop->endpoint == endpoint )
   2482              {
   2483                return ( pLoop );
   2484              }
   2485          
   2486              pLoop = pLoop->pNext;
   2487            }
   2488          
   2489            return ( NULL );
   2490          }
   2491          
   2492          /*********************************************************************
   2493           * @fn      zclFindCmdRec
   2494           *
   2495           * @brief   Find the command record that matchs the parameters
   2496           *
   2497           * @param   endpoint - Application's endpoint
   2498           * @param   clusterID - cluster ID
   2499           * @param   attrId - attribute looking for
   2500           * @param   pAttr - attribute record to be returned
   2501           *
   2502           * @return  TRUE if record found. FALSE, otherwise.
   2503           */
   2504          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2505          {
   2506            uint8 i;
   2507            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2508          
   2509            if ( pRec != NULL )
   2510            {
   2511              for ( i = 0; i < pRec->numCommands; i++ )
   2512              {
   2513                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2514                {
   2515                  *pCmd = pRec->pCmdRecs[i];
   2516          
   2517                  return ( TRUE ); // EMBEDDED RETURN
   2518                }
   2519              }
   2520            }
   2521          
   2522            return ( FALSE );
   2523          }
   2524          #endif // ZCL_DISCOVER
   2525          
   2526          /*********************************************************************
   2527           * @fn      zclFindAttrRecsList
   2528           *
   2529           * @brief   Find the right attribute record list for an endpoint
   2530           *
   2531           * @param   clusterID - endpointto look for
   2532           *
   2533           * @return  pointer to record list, NULL if not found
   2534           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2535          zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2536          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2537            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV     DPTR,#attrList
   \   000007   8004         SJMP    ??zclFindAttrRecsList_0
   2538          
   2539            while ( pLoop != NULL )
   2540            {
   2541              if ( pLoop->endpoint == endpoint )
   2542              {
   2543                return ( pLoop );
   2544              }
   2545          
   2546              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_1:
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRecsList_0:
   \   00000D   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   000010   600C         JZ      ??zclFindAttrRecsList_2
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   69           XRL     A,R1
   \   00001A   70ED         JNZ     ??zclFindAttrRecsList_1
   \   00001C   8004         SJMP    ??zclFindAttrRecsList_3
   2547            }
   2548          
   2549            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7B00         MOV     R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   000022   02....       LJMP    ?Subroutine0 & 0xFFFF
   2550          }
   2551          
   2552          /*********************************************************************
   2553           * @fn      zclFindAttrRec
   2554           *
   2555           * @brief   Find the attribute record that matchs the parameters
   2556           *
   2557           * @param   endpoint - Application's endpoint
   2558           * @param   clusterID - cluster ID
   2559           * @param   attrId - attribute looking for
   2560           * @param   pAttr - attribute record to be returned
   2561           *
   2562           * @return  TRUE if record found. FALSE, otherwise.
   2563           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2564          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2565          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2566            uint8 x;
   2567            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV     ?V4,R2
   \   000012   8B..         MOV     ?V5,R3
   2568          
   2569            if ( pRec != NULL )
   \   000014   EA           MOV     A,R2
   \   000015   45..         ORL     A,?V5
   \   000017   6075         JZ      ??zclFindAttrRec_0
   2570            {
   2571              for ( x = 0; x < pRec->numAttributes; x++ )
   \   000019   7C00         MOV     R4,#0x0
   \   00001B   8001         SJMP    ??zclFindAttrRec_1
   \                     ??zclFindAttrRec_2:
   \   00001D   0C           INC     R4
   \                     ??zclFindAttrRec_1:
   \   00001E   85..82       MOV     DPL,?V4
   \   000021   85..83       MOV     DPH,?V5
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ??Subroutine148_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   00002E   505E         JNC     ??zclFindAttrRec_0
   2572              {
   2573                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   000030   8C..         MOV     ?V6,R4
   \   000032   75..00       MOV     ?V7,#0x0
   \   000035   7403         MOV     A,#0x3
   \   000037   78..         MOV     R0,#?V6
   \   000039   12....       LCALL   ?S_SHL
   \   00003C   85..82       MOV     DPL,?V4
   \   00003F   85..83       MOV     DPH,?V5
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   25..         ADD     A,?V6
   \   00004D   F8           MOV     R0,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   35..         ADDC    A,?V7
   \   000052   F9           MOV     R1,A
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   E4           CLR     A
   \   000058   93           MOVC    A,@A+DPTR
   \   000059   FA           MOV     R2,A
   \   00005A   7401         MOV     A,#0x1
   \   00005C   93           MOVC    A,@A+DPTR
   \   00005D   FB           MOV     R3,A
   \   00005E   E5..         MOV     A,?V0
   \   000060   6A           XRL     A,R2
   \   000061   7003         JNZ     ??zclFindAttrRec_3
   \   000063   E5..         MOV     A,?V1
   \   000065   6B           XRL     A,R3
   \                     ??zclFindAttrRec_3:
   \   000066   70B5         JNZ     ??zclFindAttrRec_2
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E4           CLR     A
   \   00006B   93           MOVC    A,@A+DPTR
   \   00006C   FA           MOV     R2,A
   \   00006D   7401         MOV     A,#0x1
   \   00006F   93           MOVC    A,@A+DPTR
   \   000070   FB           MOV     R3,A
   \   000071   EE           MOV     A,R6
   \   000072   6A           XRL     A,R2
   \   000073   7002         JNZ     ??zclFindAttrRec_4
   \   000075   EF           MOV     A,R7
   \   000076   6B           XRL     A,R3
   \                     ??zclFindAttrRec_4:
   \   000077   70A4         JNZ     ??zclFindAttrRec_2
   2574                {
   2575                  *pAttr = pRec->attrs[x];
   \   000079   7410         MOV     A,#0x10
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_427:
   \   000081   8983         MOV     DPH,R1
   \   000083   8882         MOV     DPL,R0
   \   000085   7408         MOV     A,#0x8
   \   000087   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   2576          
   2577                  return ( TRUE ); // EMBEDDED RETURN
   \   00008A   7901         MOV     R1,#0x1
   \   00008C   8002         SJMP    ??zclFindAttrRec_5
   2578                }
   2579              }
   2580            }
   2581          
   2582            return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   00008E   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_5:
   \   000090   80..         SJMP    ??Subroutine166_0
   2583          }
   2584          
   2585          #if defined ( ZCL_STANDALONE )
   2586          /*********************************************************************
   2587           * @fn      zclSetAttrRecList
   2588           *
   2589           * @brief   Set attribute record list for end point
   2590           *
   2591           * @param   endpoint - endpoint the attribute list belongs to
   2592           * @param   numAttr - number of attributes in list
   2593           * @param   attrList - array of attribute records.
   2594           *                     NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE
   2595           *                     IN ASCENDING ORDER. OTHERWISE, THE DISCOVERY
   2596           *                     RESPONSE COMMAND WILL NOT HAVE THE RIGHT
   2597           *                     ATTRIBUTE INFO
   2598           *
   2599           * @return  TRUE if successful, FALSE otherwise.
   2600           */
   2601          uint8 zclSetAttrRecList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t attrList[] )
   2602          {
   2603            zclAttrRecsList *pRecsList = zclFindAttrRecsList( endpoint );
   2604          
   2605            if ( pRecsList != NULL )
   2606            {
   2607              pRecsList->numAttributes = numAttr;
   2608              pRecsList->attrs = attrList;
   2609              return ( TRUE );
   2610            }
   2611          
   2612            return ( FALSE );
   2613          }
   2614          
   2615          #endif // ZCL_STANDALONE
   2616          
   2617          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2618          /*********************************************************************
   2619           * @fn      zclGetReadWriteCB
   2620           *
   2621           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2622           *
   2623           * @param   endpoint - Application's endpoint
   2624           *
   2625           * @return  Read/Write CB, NULL if not found
   2626           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2627          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2628          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2629            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2630          
   2631            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetReadWriteCB_0
   2632            {
   2633              return ( pRec->pfnReadWriteCB );
   \   000012   12....       LCALL   ??Subroutine172_0 & 0xFFFF
   2634            }
   \                     ??CrossCallReturnLabel_381:
   \   000015   8004         SJMP    ??zclGetReadWriteCB_1
   2635          
   2636            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   00001B   02....       LJMP    ?Subroutine3 & 0xFFFF
   2637          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine172_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine173_0
   \   000003                ; // Fall through to label ??Subroutine173_0
   2638          
   2639          /*********************************************************************
   2640           * @fn      zclGetAuthorizeCB
   2641           *
   2642           * @brief   Get the Read/Write Authorization callback function pointer
   2643           *          for a given endpoint.
   2644           *
   2645           * @param   endpoint - Application's endpoint
   2646           *
   2647           * @return  Authorization CB, NULL if not found
   2648           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2649          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2650          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2651            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2652          
   2653            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetAuthorizeCB_0
   2654            {
   2655              return ( pRec->pfnAuthorizeCB );
   \   000012   12....       LCALL   ?Subroutine59 & 0xFFFF
   2656            }
   \                     ??CrossCallReturnLabel_386:
   \   000015   8004         SJMP    ??zclGetAuthorizeCB_1
   2657          
   2658            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   00001B   80..         SJMP    ?Subroutine3
   2659          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine171_0
   \   000001                ; // Fall through to label ??Subroutine171_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine171_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine172_0
   \   000001                ; // Fall through to label ??Subroutine172_0
   2660          #endif // ZCL_READ || ZCL_WRITE
   2661          
   2662          /*********************************************************************
   2663           * @fn      zclFindClusterOption
   2664           *
   2665           * @brief   Find the option record that matchs the cluster id
   2666           *
   2667           * @param   endpoint - Application's endpoint
   2668           * @param   clusterID - cluster ID looking for
   2669           *
   2670           * @return  pointer to clutser option, NULL if not found
   2671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2672          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2673          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   2674            zclClusterOptionList *pLoop;
   2675          
   2676            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000011   8009         SJMP    ??zclFindClusterOption_0
   2677            while ( pLoop != NULL )
   2678            {
   2679              if ( pLoop->endpoint == endpoint )
   2680              {
   2681                uint8 x;
   2682                for ( x = 0; x < pLoop->numOptions; x++ )
   2683                {
   2684                  if ( pLoop->options[x].clusterID == clusterID )
   2685                  {
   2686                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2687                  }
   2688                }
   2689              }
   2690          
   2691              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000013   8C82         MOV     DPL,R4
   \   000015   8D83         MOV     DPH,R5
   \   000017   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   00001A   FC           MOV     R4,A
   \   00001B   E9           MOV     A,R1
   \                     ??zclFindClusterOption_0:
   \   00001C   FD           MOV     R5,A
   \   00001D   EC           MOV     A,R4
   \   00001E   4D           ORL     A,R5
   \   00001F   6045         JZ      ??zclFindClusterOption_2
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   65..         XRL     A,?V1
   \   00002A   70E7         JNZ     ??zclFindClusterOption_1
   \   00002C   75..00       MOV     ?V0,#0x0
   \   00002F   8002         SJMP    ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000031   05..         INC     ?V0
   \                     ??zclFindClusterOption_3:
   \   000033   8C82         MOV     DPL,R4
   \   000035   8D83         MOV     DPH,R5
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   00003D   50D4         JNC     ??zclFindClusterOption_1
   \   00003F   E5..         MOV     A,?V0
   \   000041   75F003       MOV     B,#0x3
   \   000044   A4           MUL     AB
   \   000045   F8           MOV     R0,A
   \   000046   A9F0         MOV     R1,B
   \   000048   8C82         MOV     DPL,R4
   \   00004A   8D83         MOV     DPH,R5
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   28           ADD     A,R0
   \   000052   FA           MOV     R2,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   39           ADDC    A,R1
   \   000056   FB           MOV     R3,A
   \   000057   8A82         MOV     DPL,R2
   \   000059   8B83         MOV     DPH,R3
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   6E           XRL     A,R6
   \   00005D   7003         JNZ     ??zclFindClusterOption_5
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   6F           XRL     A,R7
   \                     ??zclFindClusterOption_5:
   \   000062   70CD         JNZ     ??zclFindClusterOption_4
   \   000064   8004         SJMP    ??zclFindClusterOption_6
   2692            }
   2693          
   2694            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   000066   7A00         MOV     R2,#0x0
   \   000068   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   00006A                REQUIRE ?Subroutine3
   \   00006A                ; // Fall through to label ?Subroutine3
   2695          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_360:
   \   000003   22           RET
   2696          
   2697          /*********************************************************************
   2698           * @fn      zclGetClusterOption
   2699           *
   2700           * @brief   Get the option record that matchs the cluster id
   2701           *
   2702           * @param   endpoint - Application's endpoint
   2703           * @param   clusterID - cluster ID looking for
   2704           *
   2705           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2706           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2707          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2708          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2709            uint8 option;
   2710            zclOptionRec_t *pOption;
   2711          
   2712            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2713            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6006         JZ      ??zclGetClusterOption_0
   2714            {
   2715              option = pOption->option;
   2716              if ( !ZG_SECURE_ENABLED )
   2717              {
   2718                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2719              }
   2720          
   2721              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   8002         SJMP    ??zclGetClusterOption_1
   2722            }
   2723          
   2724            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000018   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00001A   80..         SJMP    ?Subroutine3
   2725          }
   2726          
   2727          /*********************************************************************
   2728           * @fn      zclSetSecurityOption
   2729           *
   2730           * @brief   Set the security option for the cluster id
   2731           *
   2732           * @param   endpoint - Application's endpoint
   2733           * @param   clusterID - cluster ID looking for
   2734           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2735           *
   2736           * @return  none
   2737           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2738          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2739          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FF           MOV     R7,A
   2740            zclOptionRec_t *pOption;
   2741          
   2742            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   A8..         MOV     R0,?V0
   \   000010   A9..         MOV     R1,?V1
   2743            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   6015         JZ      ??zclSetSecurityOption_0
   2744            {
   2745              if ( enable )
   \   000016   E8           MOV     A,R0
   \   000017   2402         ADD     A,#0x2
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   39           ADDC    A,R1
   \   00001D   F583         MOV     DPH,A
   \   00001F   EF           MOV     A,R7
   \   000020   6005         JZ      ??zclSetSecurityOption_1
   2746              {
   2747                pOption->option |= AF_EN_SECURITY;
   \   000022   E0           MOVX    A,@DPTR
   \   000023   D2E6         SETB    0xE0 /* A   */.6
   \   000025   8003         SJMP    ??zclSetSecurityOption_2
   2748              }
   2749              else
   2750              {
   2751                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   00002A   F0           MOVX    @DPTR,A
   2752              }
   2753            }
   2754          }
   \                     ??zclSetSecurityOption_0:
   \   00002B   80..         SJMP    ?Subroutine3
   2755          
   2756          #ifdef ZCL_DISCOVER
   2757          /*********************************************************************
   2758           * @fn      zclFindNextCmdRec
   2759           *
   2760           * @brief   Find the command (or next) record that matchs the parameters
   2761           *
   2762           * @param   endpoint - Application's endpoint
   2763           * @param   clusterID - cluster ID
   2764           * @param   commandID - command ID from requesting command
   2765           * @param   direction- direction of received command
   2766           * @param   pCmdID - command looking for
   2767           * @param   pCmd - command information within command record list
   2768           *
   2769           * @return  pointer to command record, NULL no more records of this cluster
   2770           */
   2771          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2772                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2773          {
   2774            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2775            uint8 i;
   2776          
   2777            if ( pRec != NULL )
   2778            {
   2779              for ( i = 0; i < pRec->numCommands; i++ )
   2780              {
   2781                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2782                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2783                {
   2784                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2785                  {
   2786                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2787                    {
   2788                      *pCmd = pRec->pCmdRecs[i];
   2789          
   2790                      // Update command ID
   2791                      *pCmdID = pCmd->cmdID;
   2792          
   2793                      return ( TRUE ); // EMBEDDED RETURN
   2794                    }
   2795                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2796                    {
   2797                      *pCmd = pRec->pCmdRecs[i];
   2798          
   2799                      // Update command ID
   2800                      *pCmdID = pCmd->cmdID;
   2801          
   2802                      return ( TRUE ); // EMBEDDED RETURN
   2803                    }
   2804                  }
   2805                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2806                  {
   2807                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2808                    {
   2809                      *pCmd = pRec->pCmdRecs[i];
   2810          
   2811                      // Update command ID
   2812                      *pCmdID = pCmd->cmdID;
   2813          
   2814                      return ( TRUE ); // EMBEDDED RETURN
   2815                    }
   2816                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2817                    {
   2818                      *pCmd = pRec->pCmdRecs[i];
   2819          
   2820                      // Update command ID
   2821                      *pCmdID = pCmd->cmdID;
   2822          
   2823                      return ( TRUE ); // EMBEDDED RETURN
   2824                    }
   2825                  }
   2826                  else
   2827                  {
   2828                    return ( FALSE ); // Incorrect Command ID
   2829                  }
   2830                }
   2831              }
   2832            }
   2833          
   2834            return ( FALSE );
   2835          }
   2836          
   2837          /*********************************************************************
   2838           * @fn      zclFindNextAttrRec
   2839           *
   2840           * @brief   Find the attribute (or next) record that matchs the parameters
   2841           *
   2842           * @param   endpoint - Application's endpoint
   2843           * @param   clusterID - cluster ID
   2844           * @param   attr - attribute looking for
   2845           *
   2846           * @return  pointer to attribute record, NULL if not found
   2847           */
   2848          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2849                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2850          {
   2851            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2852            uint8 attrDir;
   2853          
   2854            if ( pRec != NULL )
   2855            {
   2856              uint16 x;
   2857          
   2858              for ( x = 0; x < pRec->numAttributes; x++ )
   2859              {
   2860                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2861                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2862                {
   2863                  // also make sure direction is right
   2864                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2865                  if ( attrDir == direction )
   2866                  {
   2867                    // return attribute and found attribute ID
   2868                    *pAttr = pRec->attrs[x];
   2869                    *attrId = pAttr->attr.attrId;
   2870          
   2871                    return ( TRUE ); // EMBEDDED RETURN
   2872                  }
   2873                }
   2874              }
   2875            }
   2876          
   2877            return ( FALSE );
   2878          }
   2879          #endif // ZCL_DISCOVER
   2880          
   2881          /*********************************************************************
   2882           * @fn      zclSerializeData
   2883           *
   2884           * @brief   Builds a buffer from the attribute data to sent out over
   2885           *          the air.
   2886           *          NOTE - Not compatible with application's attributes callbacks.
   2887           *
   2888           * @param   dataType - data types defined in zcl.h
   2889           * @param   attrData - pointer to the attribute data
   2890           * @param   buf - where to put the serialized data
   2891           *
   2892           * @return  pointer to end of destination buffer
   2893           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2894          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2895          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   2896            uint8 *pStr;
   2897            uint16 len;
   2898          
   2899            if ( attrData == NULL )
   \   00000D   EE           MOV     A,R6
   \   00000E   4F           ORL     A,R7
   \   00000F   7003         JNZ     $+5
   \   000011   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2900            {
   2901              return ( buf );
   2902            }
   2903          
   2904            switch ( dataType )
   \   000014   EA           MOV     A,R2
   \   000015   2402         ADD     A,#0x2
   \   000017   F5..         MOV     ?V4,A
   \   000019   E4           CLR     A
   \   00001A   3B           ADDC    A,R3
   \   00001B   F5..         MOV     ?V5,A
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   8B83         MOV     DPH,R3
   \   000021   A3           INC     DPTR
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   8E..         MOV     ?V0,R6
   \   000028   8F..         MOV     ?V1,R7
   \   00002A   75..00       MOV     ?V2,#0x0
   \   00002D   E9           MOV     A,R1
   \   00002E   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000031   04           DB        4
   \   000032   41           DB        65
   \   000033   42           DB        66
   \   000034   ....         DW        ??zclSerializeData_1
   \   000036   43           DB        67
   \   000037   44           DB        68
   \   000038   ....         DW        ??zclSerializeData_2
   \   00003A   E0           DB        224
   \   00003B   E2           DB        226
   \   00003C   ....         DW        ??zclSerializeData_3
   \   00003E   E8           DB        232
   \   00003F   E9           DB        233
   \   000040   ....         DW        ??zclSerializeData_4
   \   000042   21           DB        33
   \   000043   08           DB        8
   \   000044   ....         DW        ??zclSerializeData_5
   \   000046   09           DB        9
   \   000047   ....         DW        ??zclSerializeData_4
   \   000049   0A           DB        10
   \   00004A   ....         DW        ??zclSerializeData_6
   \   00004C   0B           DB        11
   \   00004D   ....         DW        ??zclSerializeData_3
   \   00004F   10           DB        16
   \   000050   ....         DW        ??zclSerializeData_5
   \   000052   18           DB        24
   \   000053   ....         DW        ??zclSerializeData_5
   \   000055   19           DB        25
   \   000056   ....         DW        ??zclSerializeData_4
   \   000058   1A           DB        26
   \   000059   ....         DW        ??zclSerializeData_6
   \   00005B   1B           DB        27
   \   00005C   ....         DW        ??zclSerializeData_3
   \   00005E   20           DB        32
   \   00005F   ....         DW        ??zclSerializeData_5
   \   000061   21           DB        33
   \   000062   ....         DW        ??zclSerializeData_4
   \   000064   22           DB        34
   \   000065   ....         DW        ??zclSerializeData_6
   \   000067   23           DB        35
   \   000068   ....         DW        ??zclSerializeData_3
   \   00006A   24           DB        36
   \   00006B   ....         DW        ??zclSerializeData_7
   \   00006D   25           DB        37
   \   00006E   ....         DW        ??zclSerializeData_8
   \   000070   26           DB        38
   \   000071   ....         DW        ??zclSerializeData_9
   \   000073   27           DB        39
   \   000074   ....         DW        ??zclSerializeData_10
   \   000076   28           DB        40
   \   000077   ....         DW        ??zclSerializeData_5
   \   000079   29           DB        41
   \   00007A   ....         DW        ??zclSerializeData_4
   \   00007C   2A           DB        42
   \   00007D   ....         DW        ??zclSerializeData_6
   \   00007F   2B           DB        43
   \   000080   ....         DW        ??zclSerializeData_3
   \   000082   2C           DB        44
   \   000083   ....         DW        ??zclSerializeData_7
   \   000085   2D           DB        45
   \   000086   ....         DW        ??zclSerializeData_8
   \   000088   2E           DB        46
   \   000089   ....         DW        ??zclSerializeData_9
   \   00008B   2F           DB        47
   \   00008C   ....         DW        ??zclSerializeData_10
   \   00008E   30           DB        48
   \   00008F   ....         DW        ??zclSerializeData_5
   \   000091   31           DB        49
   \   000092   ....         DW        ??zclSerializeData_4
   \   000094   38           DB        56
   \   000095   ....         DW        ??zclSerializeData_4
   \   000097   39           DB        57
   \   000098   ....         DW        ??zclSerializeData_3
   \   00009A   3A           DB        58
   \   00009B   ....         DW        ??zclSerializeData_10
   \   00009D   EA           DB        234
   \   00009E   ....         DW        ??zclSerializeData_3
   \   0000A0   F0           DB        240
   \   0000A1   ....         DW        ??zclSerializeData_10
   \   0000A3   F1           DB        241
   \   0000A4   ....         DW        ??zclSerializeData_11
   \   0000A6   ....         DW        ??zclSerializeData_0
   2905            {
   2906              case ZCL_DATATYPE_DATA8:
   2907              case ZCL_DATATYPE_BOOLEAN:
   2908              case ZCL_DATATYPE_BITMAP8:
   2909              case ZCL_DATATYPE_INT8:
   2910              case ZCL_DATATYPE_UINT8:
   2911              case ZCL_DATATYPE_ENUM8:
   2912                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   0000A8   8E82         MOV     DPL,R6
   \   0000AA   8F83         MOV     DPH,R7
   \   0000AC   12....       LCALL   ??Subroutine149_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   0000AF   EC           MOV     A,R4
   \   0000B0   FA           MOV     R2,A
   \   0000B1   ED           MOV     A,R5
   \   0000B2   FB           MOV     R3,A
   2913                 break;
   \   0000B3   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2914          
   2915              case ZCL_DATATYPE_DATA16:
   2916              case ZCL_DATATYPE_BITMAP16:
   2917              case ZCL_DATATYPE_UINT16:
   2918              case ZCL_DATATYPE_INT16:
   2919              case ZCL_DATATYPE_ENUM16:
   2920              case ZCL_DATATYPE_SEMI_PREC:
   2921              case ZCL_DATATYPE_CLUSTER_ID:
   2922              case ZCL_DATATYPE_ATTR_ID:
   2923                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   0000B6   12....       LCALL   ?Subroutine24 & 0xFFFF
   2924                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_343:
   \   0000B9   8C82         MOV     DPL,R4
   \   0000BB   8D83         MOV     DPH,R5
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   0A           INC     R2
   \   0000BF   0A           INC     R2
   \   0000C0   AB..         MOV     R3,?V5
   2925                break;
   \   0000C2   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2926          
   2927              case ZCL_DATATYPE_DATA24:
   2928              case ZCL_DATATYPE_BITMAP24:
   2929              case ZCL_DATATYPE_UINT24:
   2930              case ZCL_DATATYPE_INT24:
   2931                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   0000C5   8E82         MOV     DPL,R6
   \   0000C7   8F83         MOV     DPH,R7
   \   0000C9   78..         MOV     R0,#?V0
   \   0000CB   12....       LCALL   ?L_MOV_X
   \   0000CE   8A82         MOV     DPL,R2
   \   0000D0   8B83         MOV     DPH,R3
   \   0000D2   E5..         MOV     A,?V0
   \   0000D4   12....       LCALL   ?Subroutine30 & 0xFFFF
   2932                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_29:
   \   0000D7   78..         MOV     R0,#?V0
   \   0000D9   12....       LCALL   ?L_MOV_X
   \   0000DC   E5..         MOV     A,?V1
   \   0000DE   8C82         MOV     DPL,R4
   \   0000E0   8D83         MOV     DPH,R5
   \   0000E2   12....       LCALL   ?Subroutine30 & 0xFFFF
   2933                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_30:
   \   0000E5   78..         MOV     R0,#?V0
   \   0000E7   12....       LCALL   ?L_MOV_X
   \   0000EA   7410         MOV     A,#0x10
   \   0000EC   78..         MOV     R0,#?V0
   \   0000EE   12....       LCALL   ?UL_SHR
   \   0000F1   85..82       MOV     DPL,?V4
   \   0000F4   85..83       MOV     DPH,?V5
   \   0000F7   E5..         MOV     A,?V0
   \   0000F9   F0           MOVX    @DPTR,A
   \   0000FA   EA           MOV     A,R2
   \   0000FB   2403         ADD     A,#0x3
   \   0000FD   FA           MOV     R2,A
   \   0000FE   506D         JNC     ??zclSerializeData_0
   \   000100   0B           INC     R3
   2934                break;
   \   000101   806A         SJMP    ??zclSerializeData_0
   2935          
   2936              case ZCL_DATATYPE_DATA32:
   2937              case ZCL_DATATYPE_BITMAP32:
   2938              case ZCL_DATATYPE_UINT32:
   2939              case ZCL_DATATYPE_INT32:
   2940              case ZCL_DATATYPE_SINGLE_PREC:
   2941              case ZCL_DATATYPE_TOD:
   2942              case ZCL_DATATYPE_DATE:
   2943              case ZCL_DATATYPE_UTC:
   2944              case ZCL_DATATYPE_BAC_OID:
   2945                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   000103                ; Setup parameters for call to function osal_buffer_uint32
   \   000103   8E82         MOV     DPL,R6
   \   000105   8F83         MOV     DPH,R7
   \   000107   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   00010A   12....       LCALL   `??osal_buffer_uint32::?relay`; Banked call to: osal_buffer_uint32
   \   00010D   7404         MOV     A,#0x4
   \   00010F   12....       LCALL   ?DEALLOC_XSTACK8
   2946                break;
   \   000112   8059         SJMP    ??zclSerializeData_0
   2947          
   2948              case ZCL_DATATYPE_UINT40:
   2949              case ZCL_DATATYPE_INT40:
   2950                pStr = (uint8*)attrData;
   2951                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   000114                ; Setup parameters for call to function osal_memcpy
   \   000114   78..         MOV     R0,#?V0
   \   000116   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000119   7C05         MOV     R4,#0x5
   \   00011B   8046         SJMP    ??zclSerializeData_12
   2952                break;
   2953          
   2954              case ZCL_DATATYPE_UINT48:
   2955              case ZCL_DATATYPE_INT48:
   2956                pStr = (uint8*)attrData;
   2957                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   00011D                ; Setup parameters for call to function osal_memcpy
   \   00011D   78..         MOV     R0,#?V0
   \   00011F   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000122   7C06         MOV     R4,#0x6
   \   000124   803D         SJMP    ??zclSerializeData_12
   2958                break;
   2959          
   2960              case ZCL_DATATYPE_UINT56:
   2961              case ZCL_DATATYPE_INT56:
   2962                pStr = (uint8*)attrData;
   2963                buf = zcl_memcpy( buf, pStr, 7 );
   \                     ??zclSerializeData_9:
   \   000126                ; Setup parameters for call to function osal_memcpy
   \   000126   78..         MOV     R0,#?V0
   \   000128   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00012B   7C07         MOV     R4,#0x7
   \   00012D   8034         SJMP    ??zclSerializeData_12
   2964                break;
   2965          
   2966              case ZCL_DATATYPE_DOUBLE_PREC:
   2967              case ZCL_DATATYPE_IEEE_ADDR:
   2968              case ZCL_DATATYPE_UINT64:
   2969              case ZCL_DATATYPE_INT64:
   2970                pStr = (uint8*)attrData;
   2971                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_10:
   \   00012F                ; Setup parameters for call to function osal_memcpy
   \   00012F   78..         MOV     R0,#?V0
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000134   7C08         MOV     R4,#0x8
   \   000136   802B         SJMP    ??zclSerializeData_12
   2972                break;
   2973          
   2974              case ZCL_DATATYPE_CHAR_STR:
   2975              case ZCL_DATATYPE_OCTET_STR:
   2976                pStr = (uint8*)attrData;
   2977                len = *pStr;
   2978                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   000138                ; Setup parameters for call to function osal_memcpy
   \   000138   78..         MOV     R0,#?V0
   \   00013A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00013D   8E82         MOV     DPL,R6
   \   00013F   8F83         MOV     DPH,R7
   \   000141   E0           MOVX    A,@DPTR
   \   000142   2401         ADD     A,#0x1
   \   000144   FC           MOV     R4,A
   \   000145   E4           CLR     A
   \   000146   3400         ADDC    A,#0x0
   \   000148   800F         SJMP    ??zclSerializeData_13
   2979                break;
   2980          
   2981              case ZCL_DATATYPE_LONG_CHAR_STR:
   2982              case ZCL_DATATYPE_LONG_OCTET_STR:
   2983                pStr = (uint8*)attrData;
   2984                len = BUILD_UINT16( pStr[0], pStr[1] );
   2985                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   00014A                ; Setup parameters for call to function osal_memcpy
   \   00014A   78..         MOV     R0,#?V0
   \   00014C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00014F   8E82         MOV     DPL,R6
   \   000151   8F83         MOV     DPH,R7
   \   000153   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000156   FC           MOV     R4,A
   \   000157   E4           CLR     A
   \   000158   39           ADDC    A,R1
   \                     ??zclSerializeData_13:
   \   000159   FD           MOV     R5,A
   \   00015A   8009         SJMP    ??zclSerializeData_14
   2986                break;
   2987          
   2988              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2989                pStr = (uint8*)attrData;
   2990                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_11:
   \   00015C                ; Setup parameters for call to function osal_memcpy
   \   00015C   78..         MOV     R0,#?V0
   \   00015E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000161   7C10         MOV     R4,#0x10
   \                     ??zclSerializeData_12:
   \   000163   7D00         MOV     R5,#0x0
   \                     ??zclSerializeData_14:
   \   000165   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000168   7403         MOV     A,#0x3
   \   00016A   12....       LCALL   ?DEALLOC_XSTACK8
   2991                break;
   2992          
   2993              case ZCL_DATATYPE_NO_DATA:
   2994              case ZCL_DATATYPE_UNKNOWN:
   2995                // Fall through
   2996          
   2997              default:
   2998                break;
   2999            }
   3000          
   3001            return ( buf );
   \                     ??zclSerializeData_0:
   \   00016D                REQUIRE ?Subroutine9
   \   00016D                ; // Fall through to label ?Subroutine9
   3002          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7F07         MOV     R7,#0x7
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   000007                REQUIRE ??Subroutine167_0
   \   000007                ; // Fall through to label ??Subroutine167_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   2402         ADD     A,#0x2
   \   000007   22           RET
   3003          
   3004          #if defined ZCL_REPORTING_DEVICE || defined ZCL_REPORT_CONFIGURING_DEVICE
   3005          /*********************************************************************
   3006           * @fn      zclAnalogDataType
   3007           *
   3008           * @brief   Checks to see if Data Type is Analog
   3009           *
   3010           * @param   dataType - data type
   3011           *
   3012           * @return  TRUE if data type is analog
   3013           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3014          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   3015          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   3016            uint8 analog;
   3017          
   3018            switch ( dataType )
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclAnalogDataType>_0`:
   \   000008   03           DB        3
   \   000009   20           DB        32
   \   00000A   2F           DB        47
   \   00000B   ....         DW        ??zclAnalogDataType_0
   \   00000D   38           DB        56
   \   00000E   3A           DB        58
   \   00000F   ....         DW        ??zclAnalogDataType_0
   \   000011   E0           DB        224
   \   000012   E2           DB        226
   \   000013   ....         DW        ??zclAnalogDataType_0
   \   000015   00           DB        0
   \   000016   ....         DW        ??zclAnalogDataType_1
   3019            {
   3020              case ZCL_DATATYPE_UINT8:
   3021              case ZCL_DATATYPE_UINT16:
   3022              case ZCL_DATATYPE_UINT24:
   3023              case ZCL_DATATYPE_UINT32:
   3024              case ZCL_DATATYPE_UINT40:
   3025              case ZCL_DATATYPE_UINT48:
   3026              case ZCL_DATATYPE_UINT56:
   3027              case ZCL_DATATYPE_UINT64:
   3028              case ZCL_DATATYPE_INT8:
   3029              case ZCL_DATATYPE_INT16:
   3030              case ZCL_DATATYPE_INT24:
   3031              case ZCL_DATATYPE_INT32:
   3032              case ZCL_DATATYPE_INT40:
   3033              case ZCL_DATATYPE_INT48:
   3034              case ZCL_DATATYPE_INT56:
   3035              case ZCL_DATATYPE_INT64:
   3036              case ZCL_DATATYPE_SEMI_PREC:
   3037              case ZCL_DATATYPE_SINGLE_PREC:
   3038              case ZCL_DATATYPE_DOUBLE_PREC:
   3039              case ZCL_DATATYPE_TOD:
   3040              case ZCL_DATATYPE_DATE:
   3041              case ZCL_DATATYPE_UTC:
   3042                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   000018   7901         MOV     R1,#0x1
   3043                break;
   \   00001A   8002         SJMP    ??zclAnalogDataType_2
   3044          
   3045              default:
   3046                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   00001C   7900         MOV     R1,#0x0
   3047                break;
   3048            }
   3049          
   3050            return ( analog );
   \                     ??zclAnalogDataType_2:
   \   00001E   02....       LJMP    ?Subroutine0 & 0xFFFF
   3051          }
   3052          
   3053          /*********************************************************************
   3054           * @fn      zclIsLittleEndianMachine
   3055           *
   3056           * @brief   Verifies endianness in system.
   3057           *
   3058           * @param   none
   3059           *
   3060           * @return  MSB-00 or LSB-01 depending on endianness in the system
   3061           */
   3062          static int zclIsLittleEndianMachine(void)
   3063          {
   3064            uint16 test = 0x0001;
   3065          
   3066            return (*((uint8 *)(&test)));
   3067          }
   3068          
   3069          /*********************************************************************
   3070           * @fn      zcl_BuildAnalogData
   3071           *
   3072           * @brief   Build an analog arribute out of sequential bytes.
   3073           *
   3074           * @param   dataType - type of data
   3075           * @param   pData - pointer to data
   3076           * @param   pBuf - where to put the data
   3077           *
   3078           * @return  none
   3079           */
   3080          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   3081          {
   3082            int current_byte_index;
   3083            int remaining_bytes;
   3084            int step;
   3085          
   3086            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   3087          
   3088            // decide if move forward or backwards to copy data
   3089            if ( zclIsLittleEndianMachine() )
   3090            {
   3091              step = 1;
   3092              current_byte_index = 0;
   3093            }
   3094            else
   3095            {
   3096              step = -1;
   3097              current_byte_index = remaining_bytes - 1;
   3098            }
   3099          
   3100            while ( remaining_bytes-- )
   3101            {
   3102              pData[current_byte_index] = *(pBuf++);
   3103              current_byte_index += step;
   3104            }
   3105          }
   3106          #endif
   3107          
   3108          /*********************************************************************
   3109           * @fn      zclGetDataTypeLength
   3110           *
   3111           * @brief   Return the length of the datatype in octet.
   3112           *
   3113           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   3114           *                ZCL_DATATYPE_CHAR_STR data types.
   3115           *
   3116           * @param   dataType - data type
   3117           *
   3118           * @return  length of data
   3119           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3120          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   3121          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   3122            uint8 len;
   3123          
   3124            switch ( dataType )
   \   000001   24F8         ADD     A,#-0x8
   \   000003   6078         JZ      ??zclGetDataTypeLength_0
   \   000005   14           DEC     A
   \   000006   6079         JZ      ??zclGetDataTypeLength_1
   \   000008   14           DEC     A
   \   000009   607A         JZ      ??zclGetDataTypeLength_2
   \   00000B   14           DEC     A
   \   00000C   607B         JZ      ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   606B         JZ      ??zclGetDataTypeLength_0
   \   000012   24F8         ADD     A,#-0x8
   \   000014   6067         JZ      ??zclGetDataTypeLength_0
   \   000016   14           DEC     A
   \   000017   6068         JZ      ??zclGetDataTypeLength_1
   \   000019   14           DEC     A
   \   00001A   6069         JZ      ??zclGetDataTypeLength_2
   \   00001C   14           DEC     A
   \   00001D   606A         JZ      ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD     A,#-0x5
   \   000021   605A         JZ      ??zclGetDataTypeLength_0
   \   000023   14           DEC     A
   \   000024   605B         JZ      ??zclGetDataTypeLength_1
   \   000026   14           DEC     A
   \   000027   605C         JZ      ??zclGetDataTypeLength_2
   \   000029   14           DEC     A
   \   00002A   605D         JZ      ??zclGetDataTypeLength_3
   \   00002C   14           DEC     A
   \   00002D   605E         JZ      ??zclGetDataTypeLength_4
   \   00002F   14           DEC     A
   \   000030   605F         JZ      ??zclGetDataTypeLength_5
   \   000032   14           DEC     A
   \   000033   6060         JZ      ??zclGetDataTypeLength_6
   \   000035   14           DEC     A
   \   000036   6061         JZ      ??zclGetDataTypeLength_7
   \   000038   14           DEC     A
   \   000039   6042         JZ      ??zclGetDataTypeLength_0
   \   00003B   14           DEC     A
   \   00003C   6043         JZ      ??zclGetDataTypeLength_1
   \   00003E   14           DEC     A
   \   00003F   6044         JZ      ??zclGetDataTypeLength_2
   \   000041   14           DEC     A
   \   000042   6045         JZ      ??zclGetDataTypeLength_3
   \   000044   14           DEC     A
   \   000045   6046         JZ      ??zclGetDataTypeLength_4
   \   000047   14           DEC     A
   \   000048   6047         JZ      ??zclGetDataTypeLength_5
   \   00004A   14           DEC     A
   \   00004B   6048         JZ      ??zclGetDataTypeLength_6
   \   00004D   14           DEC     A
   \   00004E   6049         JZ      ??zclGetDataTypeLength_7
   \   000050   14           DEC     A
   \   000051   602A         JZ      ??zclGetDataTypeLength_0
   \   000053   14           DEC     A
   \   000054   602B         JZ      ??zclGetDataTypeLength_1
   \   000056   24F9         ADD     A,#-0x7
   \   000058   6027         JZ      ??zclGetDataTypeLength_1
   \   00005A   14           DEC     A
   \   00005B   602C         JZ      ??zclGetDataTypeLength_3
   \   00005D   14           DEC     A
   \   00005E   6039         JZ      ??zclGetDataTypeLength_7
   \   000060   245A         ADD     A,#0x5a
   \   000062   6025         JZ      ??zclGetDataTypeLength_3
   \   000064   14           DEC     A
   \   000065   6022         JZ      ??zclGetDataTypeLength_3
   \   000067   14           DEC     A
   \   000068   601F         JZ      ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD     A,#-0x6
   \   00006C   6013         JZ      ??zclGetDataTypeLength_1
   \   00006E   14           DEC     A
   \   00006F   6010         JZ      ??zclGetDataTypeLength_1
   \   000071   14           DEC     A
   \   000072   6015         JZ      ??zclGetDataTypeLength_3
   \   000074   24FA         ADD     A,#-0x6
   \   000076   6021         JZ      ??zclGetDataTypeLength_7
   \   000078   14           DEC     A
   \   000079   6022         JZ      ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP    ??zclGetDataTypeLength_9
   3125            {
   3126              case ZCL_DATATYPE_DATA8:
   3127              case ZCL_DATATYPE_BOOLEAN:
   3128              case ZCL_DATATYPE_BITMAP8:
   3129              case ZCL_DATATYPE_INT8:
   3130              case ZCL_DATATYPE_UINT8:
   3131              case ZCL_DATATYPE_ENUM8:
   3132                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV     R1,#0x1
   3133                break;
   \   00007F   8022         SJMP    ??zclGetDataTypeLength_10
   3134          
   3135              case ZCL_DATATYPE_DATA16:
   3136              case ZCL_DATATYPE_BITMAP16:
   3137              case ZCL_DATATYPE_UINT16:
   3138              case ZCL_DATATYPE_INT16:
   3139              case ZCL_DATATYPE_ENUM16:
   3140              case ZCL_DATATYPE_SEMI_PREC:
   3141              case ZCL_DATATYPE_CLUSTER_ID:
   3142              case ZCL_DATATYPE_ATTR_ID:
   3143                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV     R1,#0x2
   3144                break;
   \   000083   801E         SJMP    ??zclGetDataTypeLength_10
   3145          
   3146              case ZCL_DATATYPE_DATA24:
   3147              case ZCL_DATATYPE_BITMAP24:
   3148              case ZCL_DATATYPE_UINT24:
   3149              case ZCL_DATATYPE_INT24:
   3150                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV     R1,#0x3
   3151                break;
   \   000087   801A         SJMP    ??zclGetDataTypeLength_10
   3152          
   3153              case ZCL_DATATYPE_DATA32:
   3154              case ZCL_DATATYPE_BITMAP32:
   3155              case ZCL_DATATYPE_UINT32:
   3156              case ZCL_DATATYPE_INT32:
   3157              case ZCL_DATATYPE_SINGLE_PREC:
   3158              case ZCL_DATATYPE_TOD:
   3159              case ZCL_DATATYPE_DATE:
   3160              case ZCL_DATATYPE_UTC:
   3161              case ZCL_DATATYPE_BAC_OID:
   3162                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV     R1,#0x4
   3163                break;
   \   00008B   8016         SJMP    ??zclGetDataTypeLength_10
   3164          
   3165             case ZCL_DATATYPE_UINT40:
   3166             case ZCL_DATATYPE_INT40:
   3167                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV     R1,#0x5
   3168                 break;
   \   00008F   8012         SJMP    ??zclGetDataTypeLength_10
   3169          
   3170             case ZCL_DATATYPE_UINT48:
   3171             case ZCL_DATATYPE_INT48:
   3172                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV     R1,#0x6
   3173                 break;
   \   000093   800E         SJMP    ??zclGetDataTypeLength_10
   3174          
   3175             case ZCL_DATATYPE_UINT56:
   3176             case ZCL_DATATYPE_INT56:
   3177                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV     R1,#0x7
   3178                 break;
   \   000097   800A         SJMP    ??zclGetDataTypeLength_10
   3179          
   3180             case ZCL_DATATYPE_DOUBLE_PREC:
   3181             case ZCL_DATATYPE_IEEE_ADDR:
   3182             case ZCL_DATATYPE_UINT64:
   3183             case ZCL_DATATYPE_INT64:
   3184               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV     R1,#0x8
   3185               break;
   \   00009B   8006         SJMP    ??zclGetDataTypeLength_10
   3186          
   3187              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   3188               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV     R1,#0x10
   3189               break;
   \   00009F   8002         SJMP    ??zclGetDataTypeLength_10
   3190          
   3191              case ZCL_DATATYPE_NO_DATA:
   3192              case ZCL_DATATYPE_UNKNOWN:
   3193                // Fall through
   3194          
   3195              default:
   3196                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV     R1,#0x0
   3197                break;
   3198            }
   3199          
   3200            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP    ?BRET
   3201          }
   3202          
   3203          /*********************************************************************
   3204           * @fn      zclGetAttrDataLength
   3205           *
   3206           * @brief   Return the length of the attribute.
   3207           *
   3208           * @param   dataType - data type
   3209           * @param   pData - pointer to data
   3210           *
   3211           * @return  returns atrribute length
   3212           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3213          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   3214          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   3215            uint16 dataLen = 0;
   3216          
   3217            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV     A,#0x44
   \   000009   6E           XRL     A,R6
   \   00000A   6005         JZ      ??zclGetAttrDataLength_0
   \   00000C   7443         MOV     A,#0x43
   \   00000E   6E           XRL     A,R6
   \   00000F   700C         JNZ     ??zclGetAttrDataLength_1
   3218            {
   3219              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   12....       LCALL   ?Subroutine92 & 0xFFFF
   3220            }
   \                     ??CrossCallReturnLabel_157:
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   39           ADDC    A,R1
   \   00001B   8015         SJMP    ??zclGetAttrDataLength_2
   3221            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001D   7442         MOV     A,#0x42
   \   00001F   6E           XRL     A,R6
   \   000020   6005         JZ      ??zclGetAttrDataLength_3
   \   000022   7441         MOV     A,#0x41
   \   000024   6E           XRL     A,R6
   \   000025   700E         JNZ     ??zclGetAttrDataLength_4
   3222            {
   3223              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   2401         ADD     A,#0x1
   \   00002E   FA           MOV     R2,A
   \   00002F   E4           CLR     A
   \   000030   3400         ADDC    A,#0x0
   \                     ??zclGetAttrDataLength_2:
   \   000032   FB           MOV     R3,A
   \   000033   8007         SJMP    ??zclGetAttrDataLength_5
   3224            }
   3225            else
   3226            {
   3227              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000035                ; Setup parameters for call to function zclGetDataTypeLength
   \   000035   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000038   E9           MOV     A,R1
   \   000039   FA           MOV     R2,A
   \   00003A   7B00         MOV     R3,#0x0
   3228            }
   3229          
   3230            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003C   02....       LJMP    ??Subroutine165_0 & 0xFFFF
   3231          }
   3232          
   3233          #ifdef ZCL_READ
   3234          /*********************************************************************
   3235           * @fn      zclReadAttrData
   3236           *
   3237           * @brief   Read the attribute's current value into pAttrData.
   3238           *          NOTE - Not compatible with application's attributes callbacks.
   3239           *
   3240           * @param   pAttrData - where to put attribute data
   3241           * @param   pAttr - pointer to attribute
   3242           * @param   pDataLen - where to put attribute data length
   3243           *
   3244           * @return Success
   3245           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3246          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   3247          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3248            uint16 dataLen;
   3249          
   3250            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   3D           ADDC    A,R5
   \   00000F   F9           MOV     R1,A
   \   000010   88..         MOV     ?V0,R0
   \   000012   89..         MOV     ?V1,R1
   \   000014   8882         MOV     DPL,R0
   \   000016   F583         MOV     DPH,A
   \   000018   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   00001B   7004         JNZ     ??zclReadAttrData_0
   3251            {
   3252              return ( ZCL_STATUS_FAILURE );
   \   00001D   7901         MOV     R1,#0x1
   \   00001F   804C         SJMP    ??zclReadAttrData_1
   3253            }
   3254          
   3255            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000021                ; Setup parameters for call to function zclGetAttrDataLength
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00002E   8A..         MOV     ?V2,R2
   \   000030   8B..         MOV     ?V3,R3
   3256            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000032                ; Setup parameters for call to function osal_memcpy
   \   000032   85..82       MOV     DPL,?V0
   \   000035   85..83       MOV     DPH,?V1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   85....       MOV     ?V4,?V0
   \   000040   F5..         MOV     ?V5,A
   \   000042   75..00       MOV     ?V6,#0x0
   \   000045   78..         MOV     R0,#?V4
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004A   AC..         MOV     R4,?V2
   \   00004C   AD..         MOV     R5,?V3
   \   00004E   EE           MOV     A,R6
   \   00004F   FA           MOV     R2,A
   \   000050   EF           MOV     A,R7
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000055   7403         MOV     A,#0x3
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   740F         MOV     A,#0xf
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   12....       LCALL   ??Subroutine158_0 & 0xFFFF
   3257          
   3258            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_309:
   \   000062   6007         JZ      ??zclReadAttrData_2
   3259            {
   3260              *pDataLen = dataLen;
   \   000064   E5..         MOV     A,?V2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E5..         MOV     A,?V3
   \   00006A   F0           MOVX    @DPTR,A
   3261            }
   3262          
   3263            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   00006B   7900         MOV     R1,#0x0
   \                     ??zclReadAttrData_1:
   \   00006D   02....       LJMP    ?Subroutine9 & 0xFFFF
   3264          }
   3265          
   3266          /*********************************************************************
   3267           * @fn      zcl_ReadAttrData
   3268           *
   3269           * @brief   Read the attribute's current value into pAttrData.
   3270           *          Use application's callback function if assigned to this attribute.
   3271           *
   3272           * @param   endpoint - application's endpoint
   3273           * @param   clusterId - cluster that attribute belongs to
   3274           * @param   attrId - attribute id
   3275           * @param   pAttrData - where to put attribute data
   3276           * @param   pDataLen - where to put attribute data length
   3277           *
   3278           * @return  Successful if data was read
   3279           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3280          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   3281                                                   uint8 *pAttrData, uint16 *pDataLen )
   3282          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V2,R1
   \   00000C   8A..         MOV     ?V0,R2
   \   00000E   8B..         MOV     ?V1,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   3283            zclAttrRec_t attrRec;
   3284          
   3285            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   000014                ; Setup parameters for call to function zclFindAttrRec
   \   000014   A8..         MOV     R0,?XSP + 0
   \   000016   A9..         MOV     R1,?XSP + 1
   \   000018   88..         MOV     ?V4,R0
   \   00001A   89..         MOV     ?V5,R1
   \   00001C   78..         MOV     R0,#?V4
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   A9..         MOV     R1,?V2
   \   000023   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000026   7402         MOV     A,#0x2
   \   000028   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002B   E9           MOV     A,R1
   \   00002C   7004         JNZ     ??zcl_ReadAttrData_0
   3286            {
   3287              return ( ZCL_STATUS_FAILURE );
   \   00002E   7901         MOV     R1,#0x1
   \   000030   804C         SJMP    ??zcl_ReadAttrData_1
   3288            }
   \                     ??zcl_ReadAttrData_0:
   \   000032   7418         MOV     A,#0x18
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ??Subroutine170_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_362:
   \   00003A   741A         MOV     A,#0x1a
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine71 & 0xFFFF
   3289          
   3290            if ( attrRec.attr.dataPtr != NULL )
   \                     ??CrossCallReturnLabel_117:
   \   000042   7406         MOV     A,#0x6
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_351:
   \   00004A   78..         MOV     R0,#?V4
   \   00004C   6016         JZ      ??zcl_ReadAttrData_2
   3291            {
   3292              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   00004E                ; Setup parameters for call to function zclReadAttrData
   \   00004E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?XSTACK_DISP102_8
   \   000056   AA..         MOV     R2,?V6
   \   000058   AB..         MOV     R3,?V7
   \   00005A   12....       LCALL   `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   801A         SJMP    ??zcl_ReadAttrData_1
   3293            }
   3294            else
   3295            {
   3296              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   000064                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   78..         MOV     R0,#?V6
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   EE           MOV     A,R6
   \   00006D   FC           MOV     R4,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FD           MOV     R5,A
   \   000070   AA..         MOV     R2,?V0
   \   000072   AB..         MOV     R3,?V1
   \   000074   A9..         MOV     R1,?V2
   \   000076   12....       LCALL   `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   000079   7404         MOV     A,#0x4
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zcl_ReadAttrData_1:
   \   00007E   7408         MOV     A,#0x8
   3297            }
   \   000080   02....       LJMP    ?Subroutine8 & 0xFFFF
   3298          }
   3299          
   3300          /*********************************************************************
   3301           * @fn      zclGetAttrDataLengthUsingCB
   3302           *
   3303           * @brief   Use application's callback to get the length of the attribute's
   3304           *          current value stored in the database.
   3305           *
   3306           * @param   endpoint - application's endpoint
   3307           * @param   clusterId - cluster that attribute belongs to
   3308           * @param   attrId - attribute id
   3309           *
   3310           * @return  returns attribute length
   3311           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3312          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3313          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3314            uint16 dataLen = 0;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   E4           CLR     A
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   3315            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001C                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001C   12....       LCALL   `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   00001F   8A..         MOV     ?V0,R2
   \   000021   8B..         MOV     ?V1,R3
   3316          
   3317            if ( pfnReadWriteCB != NULL )
   \   000023   EA           MOV     A,R2
   \   000024   45..         ORL     A,?V1
   \   000026   602F         JZ      ??zclGetAttrDataLengthUsingCB_0
   3318            {
   3319              // Only get the attribute length
   3320              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000028                ; Setup parameters for indirect call
   \   000028   A8..         MOV     R0,?XSP + 0
   \   00002A   A9..         MOV     R1,?XSP + 1
   \   00002C   88..         MOV     ?V6,R0
   \   00002E   89..         MOV     ?V7,R1
   \   000030   78..         MOV     R0,#?V6
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   E4           CLR     A
   \   000036   F5..         MOV     ?V6,A
   \   000038   F5..         MOV     ?V7,A
   \   00003A   78..         MOV     R0,#?V6
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   7900         MOV     R1,#0x0
   \   000041   EE           MOV     A,R6
   \   000042   FC           MOV     R4,A
   \   000043   EF           MOV     A,R7
   \   000044   FD           MOV     R5,A
   \   000045   AA..         MOV     R2,?V4
   \   000047   AB..         MOV     R3,?V5
   \   000049   85..82       MOV     DPL,?V0
   \   00004C   85..83       MOV     DPH,?V1
   \   00004F   12....       LCALL   ?CALL_IND
   \   000052   7404         MOV     A,#0x4
   \   000054   12....       LCALL   ?DEALLOC_XSTACK8
   3321            }
   3322          
   3323            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_377:
   \   000060   7402         MOV     A,#0x2
   \   000062   02....       LJMP    ?Subroutine8 & 0xFFFF
   3324          }
   3325          
   3326          /*********************************************************************
   3327           * @fn      zclReadAttrDataUsingCB
   3328           *
   3329           * @brief   Use application's callback to read the attribute's current
   3330           *          value stored in the database.
   3331           *
   3332           * @param   endpoint - application's endpoint
   3333           * @param   clusterId - cluster that attribute belongs to
   3334           * @param   attrId - attribute id
   3335           * @param   pAttrData - where to put attribute data
   3336           * @param   pDataLen - where to put attribute data length
   3337           *
   3338           * @return  Successful if data was read
   3339           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3340          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3341                                                   uint8 *pAttrData, uint16 *pDataLen )
   3342          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   3343            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000D                ; Setup parameters for call to function zclGetReadWriteCB
   \   00000D   12....       LCALL   `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000010   8A..         MOV     ?V2,R2
   \   000012   8B..         MOV     ?V3,R3
   \   000014   7412         MOV     A,#0x12
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   12....       LCALL   ??Subroutine170_0 & 0xFFFF
   3344          
   3345            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_363:
   \   00001C   E5..         MOV     A,?V6
   \   00001E   45..         ORL     A,?V7
   \   000020   600A         JZ      ??zclReadAttrDataUsingCB_0
   3346            {
   3347              *pDataLen = 0; // Always initialize it to 0
   \   000022   85..82       MOV     DPL,?V6
   \   000025   85..83       MOV     DPH,?V7
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   F0           MOVX    @DPTR,A
   3348            }
   3349          
   3350            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00002C   EA           MOV     A,R2
   \   00002D   45..         ORL     A,?V3
   \   00002F   6027         JZ      ??zclReadAttrDataUsingCB_1
   3351            {
   3352              // Read the attribute value and its length
   3353              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000031                ; Setup parameters for indirect call
   \   000031   78..         MOV     R0,#?V6
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   7412         MOV     A,#0x12
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003E   7901         MOV     R1,#0x1
   \   000040   EE           MOV     A,R6
   \   000041   FC           MOV     R4,A
   \   000042   EF           MOV     A,R7
   \   000043   FD           MOV     R5,A
   \   000044   AA..         MOV     R2,?V0
   \   000046   AB..         MOV     R3,?V1
   \   000048   85..82       MOV     DPL,?V2
   \   00004B   85..83       MOV     DPH,?V3
   \   00004E   12....       LCALL   ?CALL_IND
   \   000051   7404         MOV     A,#0x4
   \   000053   12....       LCALL   ?DEALLOC_XSTACK8
   \   000056   8002         SJMP    ??zclReadAttrDataUsingCB_2
   3354            }
   3355          
   3356            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000058   79C1         MOV     R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   00005A   02....       LJMP    ??Subroutine166_0 & 0xFFFF
   3357          }
   3358          
   3359          /*********************************************************************
   3360           * @fn      zclAuthorizeRead
   3361           *
   3362           * @brief   Use application's callback to authorize a Read operation
   3363           *          on a given attribute.
   3364           *
   3365           * @param   endpoint - application's endpoint
   3366           * @param   srcAddr - source Address
   3367           * @param   pAttr - pointer to attribute
   3368           *
   3369           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3370           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3371           */
   3372          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3373          {
   3374            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3375            {
   3376              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3377          
   3378              if ( pfnAuthorizeCB != NULL )
   3379              {
   3380                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3381              }
   3382            }
   3383          
   3384            return ( ZCL_STATUS_SUCCESS );
   3385          }
   3386          #endif // ZCL_READ
   3387          
   3388          #ifdef ZCL_WRITE
   3389          /*********************************************************************
   3390           * @fn      zclWriteAttrData
   3391           *
   3392           * @brief   Write the received data.
   3393           *
   3394           * @param   endpoint - application's endpoint
   3395           * @param   pAttr - where to write data to
   3396           * @param   pWriteRec - data to be written
   3397           *
   3398           * @return  Successful if data was written
   3399           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3400          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3401                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3402          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   3403            uint8 status;
   3404          
   3405            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   A2E1         MOV     C,0xE0 /* A   */.1
   \   000015   5077         JNC     ??zclWriteAttrData_0
   3406            {
   3407              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000017                ; Setup parameters for call to function zclAuthorizeWrite
   \   000017   12....       LCALL   `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001A   E9           MOV     A,R1
   \   00001B   F5..         MOV     ?V2,A
   3408              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7072         JNZ     ??zclWriteAttrData_1
   \   00001F   740F         MOV     A,#0xf
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine73 & 0xFFFF
   3409              {
   3410                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \                     ??CrossCallReturnLabel_120:
   \   000027   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00002A   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_352:
   \   00002D   6013         JZ      ??zclWriteAttrData_2
   \   00002F                ; Setup parameters for indirect call
   \   00002F   AC..         MOV     R4,?V0
   \   000031   AD..         MOV     R5,?V1
   \   000033   EE           MOV     A,R6
   \   000034   FA           MOV     R2,A
   \   000035   EF           MOV     A,R7
   \   000036   FB           MOV     R3,A
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F583         MOV     DPH,A
   \   00003A   8882         MOV     DPL,R0
   \   00003C   12....       LCALL   ?CALL_IND
   \   00003F   E9           MOV     A,R1
   \   000040   6047         JZ      ??zclWriteAttrData_3
   3411                {
   3412                  // Write the attribute value
   3413                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000042   E5..         MOV     A,?V0
   \   000044   2403         ADD     A,#0x3
   \   000046   F8           MOV     R0,A
   \   000047   E4           CLR     A
   \   000048   35..         ADDC    A,?V1
   \   00004A   F9           MOV     R1,A
   \   00004B   88..         MOV     ?V0,R0
   \   00004D   89..         MOV     ?V1,R1
   \   00004F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00004F   8882         MOV     DPL,R0
   \   000051   F583         MOV     DPH,A
   \   000053   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_378:
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000063   8A..         MOV     ?V4,R2
   \   000065   8B..         MOV     ?V5,R3
   \   000067   AC..         MOV     R4,?V4
   \   000069   AD..         MOV     R5,?V5
   3414                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00006B                ; Setup parameters for call to function osal_memcpy
   \   00006B   85..82       MOV     DPL,?V0
   \   00006E   85..83       MOV     DPH,?V1
   \   000071   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000077   8E82         MOV     DPL,R6
   \   000079   8F83         MOV     DPH,R7
   \   00007B   A3           INC     DPTR
   \   00007C   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_387:
   \   00007F   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000082   7403         MOV     A,#0x3
   \   000084   12....       LCALL   ?DEALLOC_XSTACK8
   3415          
   3416                  status = ZCL_STATUS_SUCCESS;
   \   000087   8008         SJMP    ??zclWriteAttrData_1
   3417                }
   3418                else
   3419                {
   3420                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   000089   75..87       MOV     ?V2,#-0x79
   \   00008C   8003         SJMP    ??zclWriteAttrData_1
   3421                }
   3422              }
   3423            }
   3424            else
   3425            {
   3426              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   00008E   75..88       MOV     ?V2,#-0x78
   3427            }
   3428          
   3429            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000091   A9..         MOV     R1,?V2
   \   000093   02....       LJMP    ?Subroutine9 & 0xFFFF
   3430          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V1,A
   \   000007   22           RET
   3431          
   3432          /*********************************************************************
   3433           * @fn      zclWriteAttrDataUsingCB
   3434           *
   3435           * @brief   Use application's callback to write the attribute's current
   3436           *          value stored in the database.
   3437           *
   3438           * @param   endpoint - application's endpoint
   3439           * @param   pAttr - where to write data to
   3440           * @param   pAttrData - data to be written
   3441           *
   3442           * @return  Successful if data was written
   3443           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3444          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3445                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3446          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   EC           MOV     A,R4
   \   000008   FE           MOV     R6,A
   \   000009   ED           MOV     A,R5
   \   00000A   FF           MOV     R7,A
   3447            uint8 status;
   3448          
   3449            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000B   8E82         MOV     DPL,R6
   \   00000D   8F83         MOV     DPH,R7
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   A2E1         MOV     C,0xE0 /* A   */.1
   \   000017   504D         JNC     ??zclWriteAttrDataUsingCB_0
   3450            {
   3451              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000019                ; Setup parameters for call to function zclAuthorizeWrite
   \   000019   12....       LCALL   `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001C   E9           MOV     A,R1
   \   00001D   F9           MOV     R1,A
   3452              if ( status == ZCL_STATUS_SUCCESS )
   \   00001E   7048         JNZ     ??zclWriteAttrDataUsingCB_1
   3453              {
   3454                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000020                ; Setup parameters for call to function zclGetReadWriteCB
   \   000020   A9..         MOV     R1,?V0
   \   000022   12....       LCALL   `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000025   8A..         MOV     ?V2,R2
   \   000027   8B..         MOV     ?V3,R3
   3455                if ( pfnReadWriteCB != NULL )
   \   000029   EA           MOV     A,R2
   \   00002A   45..         ORL     A,?V3
   \   00002C   6034         JZ      ??zclWriteAttrDataUsingCB_2
   3456                {
   3457                  // Write the attribute value
   3458                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3459                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   00002E                ; Setup parameters for indirect call
   \   00002E   E4           CLR     A
   \   00002F   F5..         MOV     ?V4,A
   \   000031   F5..         MOV     ?V5,A
   \   000033   78..         MOV     R0,#?V4
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   7410         MOV     A,#0x10
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000040   7902         MOV     R1,#0x2
   \   000042   8E82         MOV     DPL,R6
   \   000044   8F83         MOV     DPH,R7
   \   000046   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   3460                }
   \                     ??CrossCallReturnLabel_431:
   \   000049   8E82         MOV     DPL,R6
   \   00004B   8F83         MOV     DPH,R7
   \   00004D   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_379:
   \   000050   85..82       MOV     DPL,?V2
   \   000053   85..83       MOV     DPH,?V3
   \   000056   12....       LCALL   ?CALL_IND
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005E   E9           MOV     A,R1
   \   00005F   F9           MOV     R1,A
   \   000060   8006         SJMP    ??zclWriteAttrDataUsingCB_1
   3461                else
   3462                {
   3463                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   000062   79C1         MOV     R1,#-0x3f
   \   000064   8002         SJMP    ??zclWriteAttrDataUsingCB_1
   3464                }
   3465              }
   3466            }
   3467            else
   3468            {
   3469              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   000066   7988         MOV     R1,#-0x78
   3470            }
   3471          
   3472            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000068   02....       LJMP    ?Subroutine4 & 0xFFFF
   3473          }
   3474          
   3475          /*********************************************************************
   3476           * @fn      zclAuthorizeWrite
   3477           *
   3478           * @brief   Use application's callback to authorize a Write operation
   3479           *          on a given attribute.
   3480           *
   3481           * @param   endpoint - application's endpoint
   3482           * @param   srcAddr - source Address
   3483           * @param   pAttr - pointer to attribute
   3484           *
   3485           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3486           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3488          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3489          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
   3490            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000D   8C82         MOV     DPL,R4
   \   00000F   8D83         MOV     DPH,R5
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E5         MOV     C,0xE0 /* A   */.5
   \   000019   501C         JNC     ??zclAuthorizeWrite_0
   3491            {
   3492              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001B                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001B   12....       LCALL   `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   3493          
   3494              if ( pfnAuthorizeCB != NULL )
   \   000022   E582         MOV     A,DPL
   \   000024   4583         ORL     A,DPH
   \   000026   600F         JZ      ??zclAuthorizeWrite_0
   3495              {
   3496                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000028                ; Setup parameters for indirect call
   \   000028   7902         MOV     R1,#0x2
   \   00002A   AC..         MOV     R4,?V0
   \   00002C   AD..         MOV     R5,?V1
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   EF           MOV     A,R7
   \   000031   FB           MOV     R3,A
   \   000032   12....       LCALL   ?CALL_IND
   \   000035   8002         SJMP    ??zclAuthorizeWrite_1
   3497              }
   3498            }
   3499          
   3500            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000037   7900         MOV     R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000039   02....       LJMP    ?Subroutine4 & 0xFFFF
   3501          }
   3502          #endif // ZCL_WRITE
   3503          
   3504          #ifdef ZCL_READ
   3505          /*********************************************************************
   3506           * @fn      zclParseInReadCmd
   3507           *
   3508           * @brief   Parse the "Profile" Read Commands
   3509           *
   3510           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3511           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3512           *
   3513           * @param   pCmd - pointer to incoming data to parse
   3514           *
   3515           * @return  pointer to the parsed command structure
   3516           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3517          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3518          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3519            zclReadCmd_t *readCmd;
   3520            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine81 & 0xFFFF
   3521          
   3522            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_139:
   \   000008   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   00000B   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3523            if ( readCmd != NULL )
   \   00000E   EA           MOV     A,R2
   \   00000F   4B           ORL     A,R3
   \   000010   604B         JZ      ??zclParseInReadCmd_0
   3524            {
   3525              uint8 i;
   3526              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   000012   85..82       MOV     DPL,?V0
   \   000015   85..83       MOV     DPH,?V1
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   C3           CLR     C
   \   00001D   13           RRC     A
   \   00001E   E8           MOV     A,R0
   \   00001F   13           RRC     A
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   F0           MOVX    @DPTR,A
   3527              for ( i = 0; i < readCmd->numAttr; i++ )
   \   000025   75..00       MOV     ?V0,#0x0
   \   000028   802A         SJMP    ??zclParseInReadCmd_1
   3528              {
   3529                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_2:
   \   00002A   8E82         MOV     DPL,R6
   \   00002C   8F83         MOV     DPH,R7
   \   00002E   12....       LCALL   ?Subroutine130 & 0xFFFF
   3530                pBuf += 2;
   3531              }
   \                     ??CrossCallReturnLabel_233:
   \   000031   F8           MOV     R0,A
   \   000032   E4           CLR     A
   \   000033   C8           XCH     A,R0
   \   000034   F9           MOV     R1,A
   \   000035   EC           MOV     A,R4
   \   000036   28           ADD     A,R0
   \   000037   E4           CLR     A
   \   000038   39           ADDC    A,R1
   \   000039   FD           MOV     R5,A
   \   00003A   A8..         MOV     R0,?V0
   \   00003C   E8           MOV     A,R0
   \   00003D   28           ADD     A,R0
   \   00003E   F8           MOV     R0,A
   \   00003F   E4           CLR     A
   \   000040   33           RLC     A
   \   000041   F9           MOV     R1,A
   \   000042   EA           MOV     A,R2
   \   000043   28           ADD     A,R0
   \   000044   F582         MOV     DPL,A
   \   000046   EB           MOV     A,R3
   \   000047   39           ADDC    A,R1
   \   000048   F583         MOV     DPH,A
   \   00004A   A3           INC     DPTR
   \   00004B   EC           MOV     A,R4
   \   00004C   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00004F   5001         JNC     ??zclParseInReadCmd_3
   \   000051   0F           INC     R7
   \                     ??zclParseInReadCmd_3:
   \   000052   05..         INC     ?V0
   \                     ??zclParseInReadCmd_1:
   \   000054   8A82         MOV     DPL,R2
   \   000056   8B83         MOV     DPH,R3
   \   000058   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   3532            }
   \                     ??CrossCallReturnLabel_302:
   \   00005B   40CD         JC      ??zclParseInReadCmd_2
   3533          
   3534            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   00005D   02....       LJMP    ?Subroutine1 & 0xFFFF
   3535          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0,DPL
   \   000008   8583..       MOV     ?V1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   ED           MOV     A,R5
   \   000003   F0           MOVX    @DPTR,A
   \   000004   EE           MOV     A,R6
   \   000005   2402         ADD     A,#0x2
   \   000007   FE           MOV     R6,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_359:
   \   00000A   FE           MOV     R6,A
   \   00000B   E9           MOV     A,R1
   \   00000C   FF           MOV     R7,A
   \   00000D   22           RET
   3536          
   3537          /*********************************************************************
   3538           * @fn      zclParseInReadRspCmd
   3539           *
   3540           * @brief   Parse the "Profile" Read Response Commands
   3541           *
   3542           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3543           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3544           *
   3545           * @param   pCmd - pointer to incoming data to parse
   3546           *
   3547           * @return  pointer to the parsed command structure
   3548           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3549          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3550          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V8,R2
   \   000007   8B..         MOV     ?V9,R3
   3551            zclReadRspCmd_t *readRspCmd;
   3552            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V4,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V9
   \   000011   F5..         MOV     ?V5,A
   \   000013   85..82       MOV     DPL,?V4
   \   000016   F583         MOV     DPH,A
   \   000018   12....       LCALL   ?Subroutine94 & 0xFFFF
   3553            uint8 *dataPtr;
   3554            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_160:
   \   00001B   75..00       MOV     ?V2,#0x0
   3555            uint8 hdrLen;
   3556            uint16 dataLen = 0;
   \   00001E   75..00       MOV     ?V6,#0x0
   \   000021   75..00       MOV     ?V7,#0x0
   \   000024   8049         SJMP    ??zclParseInReadRspCmd_0
   3557            uint16 attrDataLen;
   3558          
   3559            // find out the number of attributes and the length of attribute data
   3560            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3561            {
   3562              uint8 status;
   3563          
   3564              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   000026   05..         INC     ?V2
   3565              pBuf += 2; // move pass attribute id
   3566          
   3567              status = *pBuf++;
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F8           MOV     R0,A
   \   000030   EE           MOV     A,R6
   \   000031   2403         ADD     A,#0x3
   \   000033   FE           MOV     R6,A
   \   000034   5001         JNC     ??zclParseInReadRspCmd_2
   \   000036   0F           INC     R7
   3568              if ( status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_2:
   \   000037   E8           MOV     A,R0
   \   000038   7035         JNZ     ??zclParseInReadRspCmd_0
   3569              {
   3570                uint8 dataType = *pBuf++;
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F9           MOV     R1,A
   \   000040   A3           INC     DPTR
   \   000041   AE82         MOV     R6,DPL
   \   000043   AF83         MOV     R7,DPH
   3571          
   3572                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000045                ; Setup parameters for call to function zclGetAttrDataLength
   \   000045   EE           MOV     A,R6
   \   000046   FA           MOV     R2,A
   \   000047   EF           MOV     A,R7
   \   000048   FB           MOV     R3,A
   \   000049   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00004C   8A..         MOV     ?V0,R2
   \   00004E   8B..         MOV     ?V1,R3
   3573                pBuf += attrDataLen; // move pass attribute data
   \   000050   EE           MOV     A,R6
   \   000051   2A           ADD     A,R2
   \   000052   FE           MOV     R6,A
   \   000053   EF           MOV     A,R7
   \   000054   35..         ADDC    A,?V1
   \   000056   FF           MOV     R7,A
   3574          
   3575                // add padding if needed
   3576                if ( PADDING_NEEDED( attrDataLen ) )
   \   000057   EA           MOV     A,R2
   \   000058   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005A   5007         JNC     ??zclParseInReadRspCmd_3
   3577                {
   3578                  attrDataLen++;
   \   00005C   05..         INC     ?V0
   \   00005E   04           INC     A
   \   00005F   7002         JNZ     ??zclParseInReadRspCmd_3
   \   000061   05..         INC     ?V1
   3579                }
   3580          
   3581                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_3:
   \   000063   E5..         MOV     A,?V6
   \   000065   25..         ADD     A,?V0
   \   000067   F5..         MOV     ?V6,A
   \   000069   E5..         MOV     A,?V7
   \   00006B   35..         ADDC    A,?V1
   \   00006D   F5..         MOV     ?V7,A
   3582              }
   3583            }
   \                     ??zclParseInReadRspCmd_0:
   \   00006F   85..82       MOV     DPL,?V8
   \   000072   85..83       MOV     DPH,?V9
   \   000075   A3           INC     DPTR
   \   000076   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_402:
   \   000079   85..82       MOV     DPL,?V4
   \   00007C   85..83       MOV     DPH,?V5
   \   00007F   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000082   40A2         JC      ??zclParseInReadRspCmd_1
   3584          
   3585            // calculate the length of the response header
   3586            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000084   75F006       MOV     B,#0x6
   \   000087   E5..         MOV     A,?V2
   \   000089   A4           MUL     AB
   \   00008A   04           INC     A
   \   00008B   F5..         MOV     ?V0,A
   3587          
   3588            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   00008D                ; Setup parameters for call to function osal_mem_alloc
   \   00008D   25..         ADD     A,?V6
   \   00008F   FA           MOV     R2,A
   \   000090   E4           CLR     A
   \   000091   35..         ADDC    A,?V7
   \   000093   FB           MOV     R3,A
   \   000094   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000097   8A..         MOV     ?V10,R2
   \   000099   8B..         MOV     ?V11,R3
   3589            if ( readRspCmd != NULL )
   \   00009B   EA           MOV     A,R2
   \   00009C   45..         ORL     A,?V11
   \   00009E   7003         JNZ     $+5
   \   0000A0   02....       LJMP    ??zclParseInReadRspCmd_4 & 0xFFFF
   3590            {
   3591              uint8 i;
   3592              pBuf = pCmd->pData;
   \   0000A3   85..82       MOV     DPL,?V4
   \   0000A6   85..83       MOV     DPH,?V5
   \   0000A9   12....       LCALL   ?Subroutine94 & 0xFFFF
   3593              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_161:
   \   0000AC   A8..         MOV     R0,?V0
   \   0000AE   EA           MOV     A,R2
   \   0000AF   28           ADD     A,R0
   \   0000B0   F5..         MOV     ?V8,A
   \   0000B2   E4           CLR     A
   \   0000B3   3B           ADDC    A,R3
   \   0000B4   F5..         MOV     ?V9,A
   3594          
   3595              readRspCmd->numAttr = numAttr;
   \   0000B6   8A82         MOV     DPL,R2
   \   0000B8   8B83         MOV     DPH,R3
   \   0000BA   E5..         MOV     A,?V2
   \   0000BC   F0           MOVX    @DPTR,A
   3596              for ( i = 0; i < numAttr; i++ )
   \   0000BD   75..00       MOV     ?V3,#0x0
   \   0000C0   02....       LJMP    ??zclParseInReadRspCmd_5 & 0xFFFF
   3597              {
   3598                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   0000C3   E5..         MOV     A,?V3
   \   0000C5   75F006       MOV     B,#0x6
   \   0000C8   12....       LCALL   ?Subroutine102 & 0xFFFF
   3599          
   3600                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_183:
   \   0000CB   8E82         MOV     DPL,R6
   \   0000CD   8F83         MOV     DPH,R7
   \   0000CF   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   0000D2   F0           MOVX    @DPTR,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E9           MOV     A,R1
   \   0000D5   12....       LCALL   ?Subroutine30 & 0xFFFF
   3601                pBuf += 2;
   3602          
   3603                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_31:
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   F8           MOV     R0,A
   \   0000DC   85..82       MOV     DPL,?V12
   \   0000DF   85..83       MOV     DPH,?V13
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   F0           MOVX    @DPTR,A
   \   0000E5   EE           MOV     A,R6
   \   0000E6   2403         ADD     A,#0x3
   \   0000E8   FE           MOV     R6,A
   \   0000E9   5001         JNC     ??zclParseInReadRspCmd_7
   \   0000EB   0F           INC     R7
   3604                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_7:
   \   0000EC   E8           MOV     A,R0
   \   0000ED   7064         JNZ     ??zclParseInReadRspCmd_8
   3605                {
   3606                  statusRec->dataType = *pBuf++;
   \   0000EF   8E82         MOV     DPL,R6
   \   0000F1   8F83         MOV     DPH,R7
   \   0000F3   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   0000F6   A3           INC     DPTR
   \   0000F7   12....       LCALL   ?Subroutine26 & 0xFFFF
   3607          
   3608                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_22:
   \   0000FA                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000FA   EE           MOV     A,R6
   \   0000FB   FA           MOV     R2,A
   \   0000FC   EF           MOV     A,R7
   \   0000FD   FB           MOV     R3,A
   \   0000FE   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000101   8A..         MOV     ?V0,R2
   \   000103   8B..         MOV     ?V1,R3
   3609                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   000105                ; Setup parameters for call to function osal_memcpy
   \   000105   8E..         MOV     ?V4,R6
   \   000107   8F..         MOV     ?V5,R7
   \   000109   75..00       MOV     ?V6,#0x0
   \   00010C   78..         MOV     R0,#?V4
   \   00010E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000111   AC..         MOV     R4,?V0
   \   000113   AD..         MOV     R5,?V1
   \   000115   AA..         MOV     R2,?V8
   \   000117   AB..         MOV     R3,?V9
   \   000119   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00011C   7403         MOV     A,#0x3
   \   00011E   12....       LCALL   ?DEALLOC_XSTACK8
   3610                  statusRec->data = dataPtr;
   \   000121   85..82       MOV     DPL,?V12
   \   000124   85..83       MOV     DPH,?V13
   \   000127   A3           INC     DPTR
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   A3           INC     DPTR
   \   00012B   E5..         MOV     A,?V8
   \   00012D   F0           MOVX    @DPTR,A
   \   00012E   A3           INC     DPTR
   \   00012F   E5..         MOV     A,?V9
   \   000131   F0           MOVX    @DPTR,A
   3611          
   3612                  pBuf += attrDataLen; // move pass attribute data
   \   000132   EE           MOV     A,R6
   \   000133   25..         ADD     A,?V0
   \   000135   FE           MOV     R6,A
   \   000136   EF           MOV     A,R7
   \   000137   35..         ADDC    A,?V1
   \   000139   FF           MOV     R7,A
   3613          
   3614                  // advance attribute data pointer
   3615                  if ( PADDING_NEEDED( attrDataLen ) )
   \   00013A   E5..         MOV     A,?V0
   \   00013C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00013E   5007         JNC     ??zclParseInReadRspCmd_9
   3616                  {
   3617                    attrDataLen++;
   \   000140   05..         INC     ?V0
   \   000142   04           INC     A
   \   000143   7002         JNZ     ??zclParseInReadRspCmd_9
   \   000145   05..         INC     ?V1
   3618                  }
   3619          
   3620                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_9:
   \   000147   E5..         MOV     A,?V8
   \   000149   25..         ADD     A,?V0
   \   00014B   F5..         MOV     ?V8,A
   \   00014D   E5..         MOV     A,?V9
   \   00014F   35..         ADDC    A,?V1
   \   000151   F5..         MOV     ?V9,A
   3621                }
   3622              }
   \                     ??zclParseInReadRspCmd_8:
   \   000153   05..         INC     ?V3
   \                     ??zclParseInReadRspCmd_5:
   \   000155   E5..         MOV     A,?V3
   \   000157   C3           CLR     C
   \   000158   95..         SUBB    A,?V2
   \   00015A   5003         JNC     $+5
   \   00015C   02....       LJMP    ??zclParseInReadRspCmd_6 & 0xFFFF
   3623            }
   3624          
   3625            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   00015F                REQUIRE ?Subroutine10
   \   00015F                ; // Fall through to label ?Subroutine10
   3626          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   AA..         MOV     R2,?V10
   \   000002   AB..         MOV     R3,?V11
   \   000004   02....       LJMP    ??Subroutine156_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V10
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V11
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   A3           INC     DPTR
   \   00000F   8582..       MOV     ?V12,DPL
   \   000012   8583..       MOV     ?V13,DPH
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   EA           MOV     A,R2
   \   000006   85..82       MOV     DPL,?V12
   \   000009   85..83       MOV     DPH,?V13
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   000003   C3           CLR     C
   \   000004   EE           MOV     A,R6
   \   000005   98           SUBB    A,R0
   \   000006   EF           MOV     A,R7
   \   000007   99           SUBB    A,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   85..82       MOV     DPL,?V12
   \   000005   85..83       MOV     DPH,?V13
   \   000008   22           RET
   3627          #endif // ZCL_READ
   3628          
   3629          #ifdef ZCL_WRITE
   3630          /*********************************************************************
   3631           * @fn      zclParseInWriteCmd
   3632           *
   3633           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3634           *          Response Commands
   3635           *
   3636           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3637           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3638           *
   3639           * @param   pCmd - pointer to incoming data to parse
   3640           *
   3641           * @return  pointer to the parsed command structure
   3642           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3643          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3644          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V8,R2
   \   000007   8B..         MOV     ?V9,R3
   3645            zclWriteCmd_t *writeCmd;
   3646            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V2,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V9
   \   000011   F5..         MOV     ?V3,A
   \   000013   85..82       MOV     DPL,?V2
   \   000016   F583         MOV     DPH,A
   \   000018   12....       LCALL   ?Subroutine73 & 0xFFFF
   3647            uint16 attrDataLen;
   3648            uint8 *dataPtr;
   3649            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_121:
   \   00001B   75..00       MOV     ?V7,#0x0
   3650            uint8 hdrLen;
   3651            uint16 dataLen = 0;
   \   00001E   75..00       MOV     ?V4,#0x0
   \   000021   75..00       MOV     ?V5,#0x0
   \   000024   8042         SJMP    ??zclParseInWriteCmd_0
   3652          
   3653            // find out the number of attributes and the length of attribute data
   3654            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3655            {
   3656              uint8 dataType;
   3657          
   3658              numAttr++;
   \                     ??zclParseInWriteCmd_1:
   \   000026   05..         INC     ?V7
   3659              pBuf += 2; // move pass attribute id
   3660          
   3661              dataType = *pBuf++;
   \   000028   85..82       MOV     DPL,?V0
   \   00002B   85..83       MOV     DPH,?V1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   E5..         MOV     A,?V0
   \   000034   2403         ADD     A,#0x3
   \   000036   F5..         MOV     ?V0,A
   \   000038   5002         JNC     ??zclParseInWriteCmd_2
   \   00003A   05..         INC     ?V1
   3662          
   3663              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??zclParseInWriteCmd_2:
   \   00003C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003C   FA           MOV     R2,A
   \   00003D   AB..         MOV     R3,?V1
   \   00003F   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000042   8A..         MOV     ?V10,R2
   \   000044   8B..         MOV     ?V11,R3
   \   000046   AE..         MOV     R6,?V10
   \   000048   AF..         MOV     R7,?V11
   3664              pBuf += attrDataLen; // move pass attribute data
   \   00004A   E5..         MOV     A,?V0
   \   00004C   2A           ADD     A,R2
   \   00004D   F5..         MOV     ?V0,A
   \   00004F   E5..         MOV     A,?V1
   \   000051   3F           ADDC    A,R7
   \   000052   F5..         MOV     ?V1,A
   3665          
   3666              // add padding if needed
   3667              if ( PADDING_NEEDED( attrDataLen ) )
   \   000054   EE           MOV     A,R6
   \   000055   A2E0         MOV     C,0xE0 /* A   */.0
   \   000057   5005         JNC     ??zclParseInWriteCmd_3
   3668              {
   3669                attrDataLen++;
   \   000059   0E           INC     R6
   \   00005A   04           INC     A
   \   00005B   7001         JNZ     ??zclParseInWriteCmd_3
   \   00005D   0F           INC     R7
   3670              }
   3671          
   3672              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_3:
   \   00005E   E5..         MOV     A,?V4
   \   000060   2E           ADD     A,R6
   \   000061   F5..         MOV     ?V4,A
   \   000063   E5..         MOV     A,?V5
   \   000065   3F           ADDC    A,R7
   \   000066   F5..         MOV     ?V5,A
   3673            }
   \                     ??zclParseInWriteCmd_0:
   \   000068   85..82       MOV     DPL,?V8
   \   00006B   85..83       MOV     DPH,?V9
   \   00006E   A3           INC     DPTR
   \   00006F   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000072   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   000075   C3           CLR     C
   \   000076   E5..         MOV     A,?V0
   \   000078   98           SUBB    A,R0
   \   000079   E5..         MOV     A,?V1
   \   00007B   99           SUBB    A,R1
   \   00007C   40A8         JC      ??zclParseInWriteCmd_1
   3674          
   3675            // calculate the length of the response header
   3676            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   00007E   75F005       MOV     B,#0x5
   \   000081   E5..         MOV     A,?V7
   \   000083   A4           MUL     AB
   \   000084   04           INC     A
   \   000085   FE           MOV     R6,A
   3677          
   3678            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000086                ; Setup parameters for call to function osal_mem_alloc
   \   000086   25..         ADD     A,?V4
   \   000088   FA           MOV     R2,A
   \   000089   E4           CLR     A
   \   00008A   35..         ADDC    A,?V5
   \   00008C   FB           MOV     R3,A
   \   00008D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000090   8A..         MOV     ?V10,R2
   \   000092   8B..         MOV     ?V11,R3
   3679            if ( writeCmd != NULL )
   \   000094   EA           MOV     A,R2
   \   000095   45..         ORL     A,?V11
   \   000097   7003         JNZ     $+5
   \   000099   02....       LJMP    ??zclParseInWriteCmd_4 & 0xFFFF
   3680            {
   3681              uint8 i;
   3682              pBuf = pCmd->pData;
   \   00009C   85..82       MOV     DPL,?V2
   \   00009F   85..83       MOV     DPH,?V3
   \   0000A2   12....       LCALL   ?Subroutine73 & 0xFFFF
   3683              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   \                     ??CrossCallReturnLabel_122:
   \   0000A5   EA           MOV     A,R2
   \   0000A6   2E           ADD     A,R6
   \   0000A7   F5..         MOV     ?V2,A
   \   0000A9   E4           CLR     A
   \   0000AA   3B           ADDC    A,R3
   \   0000AB   F5..         MOV     ?V3,A
   3684          
   3685              writeCmd->numAttr = numAttr;
   \   0000AD   8A82         MOV     DPL,R2
   \   0000AF   8B83         MOV     DPH,R3
   \   0000B1   E5..         MOV     A,?V7
   \   0000B3   F0           MOVX    @DPTR,A
   3686              for ( i = 0; i < numAttr; i++ )
   \   0000B4   75..00       MOV     ?V8,#0x0
   \   0000B7   02....       LJMP    ??zclParseInWriteCmd_5 & 0xFFFF
   3687              {
   3688                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_6:
   \   0000BA   E5..         MOV     A,?V8
   \   0000BC   75F005       MOV     B,#0x5
   \   0000BF   12....       LCALL   ?Subroutine102 & 0xFFFF
   3689          
   3690                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_184:
   \   0000C2   85..82       MOV     DPL,?V0
   \   0000C5   85..83       MOV     DPH,?V1
   \   0000C8   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   0000CB   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   3691                pBuf += 2;
   3692                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_253:
   \   0000CE   85..82       MOV     DPL,?V0
   \   0000D1   85..83       MOV     DPH,?V1
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   0000D9   F0           MOVX    @DPTR,A
   \   0000DA   E5..         MOV     A,?V0
   \   0000DC   2403         ADD     A,#0x3
   \   0000DE   F5..         MOV     ?V0,A
   \   0000E0   5002         JNC     ??zclParseInWriteCmd_7
   \   0000E2   05..         INC     ?V1
   3693          
   3694                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??zclParseInWriteCmd_7:
   \   0000E4                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000E4   FA           MOV     R2,A
   \   0000E5   AB..         MOV     R3,?V1
   \   0000E7   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000EA   8A..         MOV     ?V4,R2
   \   0000EC   8B..         MOV     ?V5,R3
   \   0000EE   AE..         MOV     R6,?V4
   \   0000F0   AF..         MOV     R7,?V5
   3695                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000F2                ; Setup parameters for call to function osal_memcpy
   \   0000F2   85....       MOV     ?V4,?V0
   \   0000F5   85....       MOV     ?V5,?V1
   \   0000F8   75..00       MOV     ?V6,#0x0
   \   0000FB   78..         MOV     R0,#?V4
   \   0000FD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000100   EE           MOV     A,R6
   \   000101   FC           MOV     R4,A
   \   000102   EF           MOV     A,R7
   \   000103   FD           MOV     R5,A
   \   000104   AA..         MOV     R2,?V2
   \   000106   AB..         MOV     R3,?V3
   \   000108   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00010B   7403         MOV     A,#0x3
   \   00010D   12....       LCALL   ?DEALLOC_XSTACK8
   3696                statusRec->attrData = dataPtr;
   \   000110   85..82       MOV     DPL,?V12
   \   000113   85..83       MOV     DPH,?V13
   \   000116   A3           INC     DPTR
   \   000117   A3           INC     DPTR
   \   000118   A3           INC     DPTR
   \   000119   E5..         MOV     A,?V2
   \   00011B   F0           MOVX    @DPTR,A
   \   00011C   A3           INC     DPTR
   \   00011D   E5..         MOV     A,?V3
   \   00011F   F0           MOVX    @DPTR,A
   3697          
   3698                pBuf += attrDataLen; // move pass attribute data
   \   000120   E5..         MOV     A,?V0
   \   000122   2E           ADD     A,R6
   \   000123   F5..         MOV     ?V0,A
   \   000125   E5..         MOV     A,?V1
   \   000127   3F           ADDC    A,R7
   \   000128   F5..         MOV     ?V1,A
   3699          
   3700                // advance attribute data pointer
   3701                if ( PADDING_NEEDED( attrDataLen ) )
   \   00012A   EE           MOV     A,R6
   \   00012B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00012D   5005         JNC     ??zclParseInWriteCmd_8
   3702                {
   3703                  attrDataLen++;
   \   00012F   0E           INC     R6
   \   000130   04           INC     A
   \   000131   7001         JNZ     ??zclParseInWriteCmd_8
   \   000133   0F           INC     R7
   3704                }
   3705          
   3706                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_8:
   \   000134   E5..         MOV     A,?V2
   \   000136   2E           ADD     A,R6
   \   000137   F5..         MOV     ?V2,A
   \   000139   E5..         MOV     A,?V3
   \   00013B   3F           ADDC    A,R7
   \   00013C   F5..         MOV     ?V3,A
   3707              }
   \   00013E   05..         INC     ?V8
   \                     ??zclParseInWriteCmd_5:
   \   000140   E5..         MOV     A,?V8
   \   000142   C3           CLR     C
   \   000143   95..         SUBB    A,?V7
   \   000145   5003         JNC     $+5
   \   000147   02....       LJMP    ??zclParseInWriteCmd_6 & 0xFFFF
   3708            }
   3709          
   3710            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_4:
   \   00014A   02....       LJMP    ?Subroutine10 & 0xFFFF
   3711          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine181_0
   \   000003                ; // Fall through to label ??Subroutine181_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine181_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000002                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000002   85..82       MOV     DPL,?V2
   \   000005   85..83       MOV     DPH,?V3
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_442:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET
   3712          
   3713          /*********************************************************************
   3714           * @fn      zclParseInWriteRspCmd
   3715           *
   3716           * @brief   Parse the "Profile" Write Response Commands
   3717           *
   3718           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3719           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3720           *
   3721           * @param   pCmd - pointer to incoming data to parse
   3722           *
   3723           * @return  pointer to the parsed command structure
   3724           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3725          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3726          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   3727            zclWriteRspCmd_t *writeRspCmd;
   3728            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2403         ADD     A,#0x3
   \   000008   F5..         MOV     ?V2,A
   \   00000A   E4           CLR     A
   \   00000B   3B           ADDC    A,R3
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   12....       LCALL   ?Subroutine93 & 0xFFFF
   3729            uint8 i = 0;
   3730          
   3731            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_158:
   \   000014   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000017   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3732            if ( writeRspCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   6050         JZ      ??zclParseInWriteRspCmd_0
   3733            {
   3734              if ( pCmd->dataLen == 1 )
   \   00001E   85..82       MOV     DPL,?V0
   \   000021   85..83       MOV     DPH,?V1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6401         XRL     A,#0x1
   \   000027   7002         JNZ     ??zclParseInWriteRspCmd_1
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_1:
   \   00002B   702C         JNZ     ??zclParseInWriteRspCmd_2
   3735              {
   3736                // special case when all writes were successfull
   3737                writeRspCmd->attrList[i++].status = *pBuf;
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   12....       LCALL   ?Subroutine85 & 0xFFFF
   3738              }
   \                     ??CrossCallReturnLabel_146:
   \   000034   F0           MOVX    @DPTR,A
   \   000035   75..01       MOV     ?V4,#0x1
   \   000038   802D         SJMP    ??zclParseInWriteRspCmd_3
   3739              else
   3740              {
   3741                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3742                {
   3743                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   00003A   E5..         MOV     A,?V4
   \   00003C   12....       LCALL   ?Subroutine15 & 0xFFFF
   3744                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_394:
   \   00003F   F5..         MOV     ?V6,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FD           MOV     R5,A
   \   000044   E5..         MOV     A,?V6
   \   000046   8882         MOV     DPL,R0
   \   000048   8983         MOV     DPH,R1
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   ED           MOV     A,R5
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   05..         INC     ?V4
   3745                  pBuf += 2;
   \   000052   EE           MOV     A,R6
   \   000053   2402         ADD     A,#0x2
   \   000055   FE           MOV     R6,A
   \   000056   5001         JNC     ??zclParseInWriteRspCmd_2
   \   000058   0F           INC     R7
   3746                }
   \                     ??zclParseInWriteRspCmd_2:
   \   000059   85..82       MOV     DPL,?V0
   \   00005C   85..83       MOV     DPH,?V1
   \   00005F   12....       LCALL   ?Subroutine66 & 0xFFFF
   3747              }
   \                     ??CrossCallReturnLabel_107:
   \   000062   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000065   40D3         JC      ??zclParseInWriteRspCmd_4
   3748          
   3749              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   000067   8A82         MOV     DPL,R2
   \   000069   8B83         MOV     DPH,R3
   \   00006B   E5..         MOV     A,?V4
   \   00006D   F0           MOVX    @DPTR,A
   3750            }
   3751          
   3752            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   00006E   02....       LJMP    ??Subroutine166_0 & 0xFFFF
   3753          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   75F003       MOV     B,#0x3
   \   000003   A4           MUL     AB
   \   000004   F8           MOV     R0,A
   \   000005   A9F0         MOV     R1,B
   \   000007   EA           MOV     A,R2
   \   000008   28           ADD     A,R0
   \   000009   F8           MOV     R0,A
   \   00000A   EB           MOV     A,R3
   \   00000B   39           ADDC    A,R1
   \   00000C   F9           MOV     R1,A
   \   00000D   8E82         MOV     DPL,R6
   \   00000F   8F83         MOV     DPH,R7
   \   000011   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000014                REQUIRE ??Subroutine174_0
   \   000014                ; // Fall through to label ??Subroutine174_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine174_0:
   \   000000   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_398:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   F583         MOV     DPH,A
   \   000002   E0           MOVX    A,@DPTR
   \   000003   FE           MOV     R6,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   FF           MOV     R7,A
   \   000007   75..00       MOV     ?V4,#0x0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_443:
   \   000003   22           RET
   3754          #endif // ZCL_WRITE
   3755          
   3756          #ifdef ZCL_REPORTING_DEVICE
   3757          /*********************************************************************
   3758           * @fn      zclParseInConfigReportCmd
   3759           *
   3760           * @brief   Parse the "Profile" Configure Reporting Command
   3761           *
   3762           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3763           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3764           *
   3765           * @param   pCmd - pointer to incoming data to parse
   3766           *
   3767           * @return  pointer to the parsed command structure
   3768           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine161_0
   \   000002                ; // Fall through to label ??Subroutine161_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3769          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   3770          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   3771            zclCfgReportCmd_t *cfgReportCmd;
   3772            uint8 *pBuf = pCmd->pData;
   \   00000E   EA           MOV     A,R2
   \   00000F   2403         ADD     A,#0x3
   \   000011   F5..         MOV     ?V0,A
   \   000013   E4           CLR     A
   \   000014   35..         ADDC    A,?V3
   \   000016   F5..         MOV     ?V1,A
   \   000018   85..82       MOV     DPL,?V0
   \   00001B   12....       LCALL   ?Subroutine93 & 0xFFFF
   3773            uint8 *dataPtr;
   3774            uint8 numAttr = 0;
   3775            uint8 dataType;
   3776            uint8 hdrLen;
   3777            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_159:
   \   00001E   75..00       MOV     ?V6,#0x0
   \   000021   75..00       MOV     ?V7,#0x0
   \   000024   8007         SJMP    ??zclParseInConfigReportCmd_0
   3778            uint8 reportChangeLen; // length of Reportable Change field
   3779          
   3780            // Calculate the length of the Request command
   3781            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3782            {
   3783              uint8 direction;
   3784          
   3785              numAttr++;
   3786              direction = *pBuf++;
   3787              pBuf += 2; // move pass the attribute ID
   3788          
   3789              // Is there a Reportable Change field?
   3790              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3791              {
   3792                dataType = *pBuf++;
   3793                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3794          
   3795                // For attributes of 'discrete' data types this field is omitted
   3796                if ( zclAnalogDataType( dataType ) )
   3797                {
   3798                  reportChangeLen = zclGetDataTypeLength( dataType );
   3799                  pBuf += reportChangeLen;
   3800          
   3801                  // add padding if needed
   3802                  if ( PADDING_NEEDED( reportChangeLen ) )
   3803                  {
   3804                    reportChangeLen++;
   3805                  }
   3806          
   3807                  dataLen += reportChangeLen;
   3808                }
   3809                else
   3810                {
   3811                  pBuf++; // move past reportable change field
   3812                }
   3813              }
   3814              else
   3815              {
   3816                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_1:
   \   000026   EE           MOV     A,R6
   \   000027   2405         ADD     A,#0x5
   \   000029   FE           MOV     R6,A
   \   00002A   5001         JNC     ??zclParseInConfigReportCmd_0
   \   00002C   0F           INC     R7
   3817              }
   \                     ??zclParseInConfigReportCmd_0:
   \   00002D   85..82       MOV     DPL,?V2
   \   000030   85..83       MOV     DPH,?V3
   \   000033   A3           INC     DPTR
   \   000034   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_403:
   \   000037   85..82       MOV     DPL,?V0
   \   00003A   85..83       MOV     DPH,?V1
   \   00003D   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000040   5039         JNC     ??zclParseInConfigReportCmd_2
   \   000042   05..         INC     ?V4
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   E0           MOVX    A,@DPTR
   \   000049   70DB         JNZ     ??zclParseInConfigReportCmd_1
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F5..         MOV     ?V5,A
   \   000051   EE           MOV     A,R6
   \   000052   2408         ADD     A,#0x8
   \   000054   FE           MOV     R6,A
   \   000055   5001         JNC     ??zclParseInConfigReportCmd_3
   \   000057   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_3:
   \   000058                ; Setup parameters for call to function zclAnalogDataType
   \   000058   A9..         MOV     R1,?V5
   \   00005A   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00005D   E9           MOV     A,R1
   \   00005E   6010         JZ      ??zclParseInConfigReportCmd_4
   \   000060                ; Setup parameters for call to function zclGetDataTypeLength
   \   000060   A9..         MOV     R1,?V5
   \   000062   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000065   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000068   5001         JNC     ??zclParseInConfigReportCmd_5
   \   00006A   0A           INC     R2
   \                     ??zclParseInConfigReportCmd_5:
   \   00006B   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   00006E   80BD         SJMP    ??zclParseInConfigReportCmd_0
   \                     ??zclParseInConfigReportCmd_4:
   \   000070   8E82         MOV     DPL,R6
   \   000072   8F83         MOV     DPH,R7
   \   000074   A3           INC     DPTR
   \   000075   AE82         MOV     R6,DPL
   \   000077   AF83         MOV     R7,DPH
   \   000079   80B2         SJMP    ??zclParseInConfigReportCmd_0
   3818            } // while loop
   3819          
   3820            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_2:
   \   00007B   75F00C       MOV     B,#0xc
   \   00007E   E5..         MOV     A,?V4
   \   000080   A4           MUL     AB
   \   000081   04           INC     A
   \   000082   F5..         MOV     ?V2,A
   3821          
   3822            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000084                ; Setup parameters for call to function osal_mem_alloc
   \   000084   25..         ADD     A,?V6
   \   000086   FA           MOV     R2,A
   \   000087   E4           CLR     A
   \   000088   35..         ADDC    A,?V7
   \   00008A   FB           MOV     R3,A
   \   00008B   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00008E   8A..         MOV     ?V8,R2
   \   000090   8B..         MOV     ?V9,R3
   3823            if ( cfgReportCmd != NULL )
   \   000092   EA           MOV     A,R2
   \   000093   45..         ORL     A,?V9
   \   000095   7003         JNZ     $+5
   \   000097   02....       LJMP    ??zclParseInConfigReportCmd_6 & 0xFFFF
   3824            {
   3825              uint8 i;
   3826              pBuf = pCmd->pData;
   \   00009A   85..82       MOV     DPL,?V0
   \   00009D   85..83       MOV     DPH,?V1
   \   0000A0   12....       LCALL   ?Subroutine94 & 0xFFFF
   3827              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   \                     ??CrossCallReturnLabel_162:
   \   0000A3   A8..         MOV     R0,?V2
   \   0000A5   EA           MOV     A,R2
   \   0000A6   28           ADD     A,R0
   \   0000A7   F5..         MOV     ?V6,A
   \   0000A9   E4           CLR     A
   \   0000AA   3B           ADDC    A,R3
   \   0000AB   F5..         MOV     ?V7,A
   3828          
   3829              cfgReportCmd->numAttr = numAttr;
   \   0000AD   8A82         MOV     DPL,R2
   \   0000AF   8B83         MOV     DPH,R3
   \   0000B1   E5..         MOV     A,?V4
   \   0000B3   F0           MOVX    @DPTR,A
   3830              for ( i = 0; i < numAttr; i++ )
   \   0000B4   75..00       MOV     ?V5,#0x0
   \   0000B7   8018         SJMP    ??zclParseInConfigReportCmd_7
   3831              {
   3832                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3833          
   3834                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3835          
   3836                reportRec->direction = *pBuf++;
   3837                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3838                pBuf += 2;
   3839                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3840                {
   3841                  // Attribute to be reported
   3842                  reportRec->dataType = *pBuf++;
   3843                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3844                  pBuf += 2;
   3845                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3846                  pBuf += 2;
   3847          
   3848                  // For attributes of 'discrete' data types this field is omitted
   3849                  if ( zclAnalogDataType( reportRec->dataType ) )
   3850                  {
   3851                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3852                    reportRec->reportableChange = dataPtr;
   3853          
   3854                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3855                    pBuf += reportChangeLen;
   3856          
   3857                    // advance attribute data pointer
   3858                    if ( PADDING_NEEDED( reportChangeLen ) )
   3859                    {
   3860                      reportChangeLen++;
   3861                    }
   3862          
   3863                    dataPtr += reportChangeLen;
   3864                  }
   3865                }
   3866                else
   3867                {
   3868                  // Attribute reports to be received
   3869                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_8:
   \   0000B9   8882         MOV     DPL,R0
   \   0000BB   8983         MOV     DPH,R1
   \   0000BD   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   3870                  pBuf += 2;
   \                     ??CrossCallReturnLabel_254:
   \   0000CB   0E           INC     R6
   \   0000CC   0E           INC     R6
   \   0000CD   ED           MOV     A,R5
   \   0000CE   FF           MOV     R7,A
   3871                }
   \                     ??zclParseInConfigReportCmd_9:
   \   0000CF   05..         INC     ?V5
   \                     ??zclParseInConfigReportCmd_7:
   \   0000D1   E5..         MOV     A,?V5
   \   0000D3   C3           CLR     C
   \   0000D4   95..         SUBB    A,?V4
   \   0000D6   4003         JC      $+5
   \   0000D8   02....       LJMP    ??zclParseInConfigReportCmd_6 & 0xFFFF
   \   0000DB   E5..         MOV     A,?V5
   \   0000DD   75F00C       MOV     B,#0xc
   \   0000E0   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   0000E3   8582..       MOV     ?V0,DPL
   \   0000E6   8583..       MOV     ?V1,DPH
   \   0000E9                ; Setup parameters for call to function osal_memset
   \   0000E9   7C0C         MOV     R4,#0xc
   \   0000EB   7D00         MOV     R5,#0x0
   \   0000ED   7900         MOV     R1,#0x0
   \   0000EF   AA..         MOV     R2,?V0
   \   0000F1   AB..         MOV     R3,?V1
   \   0000F3   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   \   0000F6   8E82         MOV     DPL,R6
   \   0000F8   8F83         MOV     DPH,R7
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   FB           MOV     R3,A
   \   0000FC   85..82       MOV     DPL,?V0
   \   0000FF   85..83       MOV     DPH,?V1
   \   000102   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_396:
   \   000105   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000108   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   00010B   5001         JNC     ??zclParseInConfigReportCmd_10
   \   00010D   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_10:
   \   00010E   2402         ADD     A,#0x2
   \   000110   FC           MOV     R4,A
   \   000111   E4           CLR     A
   \   000112   3F           ADDC    A,R7
   \   000113   FD           MOV     R5,A
   \   000114   8E82         MOV     DPL,R6
   \   000116   8F83         MOV     DPH,R7
   \   000118   A3           INC     DPTR
   \   000119   A882         MOV     R0,DPL
   \   00011B   A983         MOV     R1,DPH
   \   00011D   8E82         MOV     DPL,R6
   \   00011F   8F83         MOV     DPH,R7
   \   000121   E0           MOVX    A,@DPTR
   \   000122   FA           MOV     R2,A
   \   000123   EB           MOV     A,R3
   \   000124   7093         JNZ     ??zclParseInConfigReportCmd_8
   \   000126   E5..         MOV     A,?V0
   \   000128   2403         ADD     A,#0x3
   \   00012A   F5..         MOV     ?V12,A
   \   00012C   E4           CLR     A
   \   00012D   35..         ADDC    A,?V1
   \   00012F   F5..         MOV     ?V13,A
   \   000131   EA           MOV     A,R2
   \   000132   85..82       MOV     DPL,?V12
   \   000135   85..83       MOV     DPH,?V13
   \   000138   F0           MOVX    @DPTR,A
   \   000139   0E           INC     R6
   \   00013A   E9           MOV     A,R1
   \   00013B   FF           MOV     R7,A
   \   00013C   8E82         MOV     DPL,R6
   \   00013E   8F83         MOV     DPH,R7
   \   000140   E0           MOVX    A,@DPTR
   \   000141   F5..         MOV     ?V2,A
   \   000143   8C82         MOV     DPL,R4
   \   000145   8D83         MOV     DPH,R5
   \   000147   E0           MOVX    A,@DPTR
   \   000148   F9           MOV     R1,A
   \   000149   E5..         MOV     A,?V2
   \   00014B   85..82       MOV     DPL,?V0
   \   00014E   85..83       MOV     DPH,?V1
   \   000151   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000154   5001         JNC     ??zclParseInConfigReportCmd_11
   \   000156   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_11:
   \   000157   8E82         MOV     DPL,R6
   \   000159   8F83         MOV     DPH,R7
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   00015F   A3           INC     DPTR
   \   000160   A3           INC     DPTR
   \   000161   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   000164   5001         JNC     ??zclParseInConfigReportCmd_12
   \   000166   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_12:
   \   000167                ; Setup parameters for call to function zclAnalogDataType
   \   000167   EA           MOV     A,R2
   \   000168   F9           MOV     R1,A
   \   000169   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00016C   E9           MOV     A,R1
   \   00016D   7003         JNZ     $+5
   \   00016F   02....       LJMP    ??zclParseInConfigReportCmd_9 & 0xFFFF
   \   000172   8E..         MOV     ?V2,R6
   \   000174   8F..         MOV     ?V3,R7
   \   000176                ; Setup parameters for call to function zclGetAttrDataLength
   \   000176   AA..         MOV     R2,?V6
   \   000178   AB..         MOV     R3,?V7
   \   00017A   85..82       MOV     DPL,?V12
   \   00017D   85..83       MOV     DPH,?V13
   \   000180   E0           MOVX    A,@DPTR
   \   000181   F9           MOV     R1,A
   \   000182   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000185   8A..         MOV     ?V10,R2
   \   000187   8B..         MOV     ?V11,R3
   \   000189   A8..         MOV     R0,?V10
   \   00018B   A9..         MOV     R1,?V11
   \   00018D   85..82       MOV     DPL,?XSP + 0
   \   000190   85..83       MOV     DPH,?XSP + 1
   \   000193   7401         MOV     A,#0x1
   \   000195   F0           MOVX    @DPTR,A
   \   000196   A3           INC     DPTR
   \   000197   E4           CLR     A
   \   000198   F0           MOVX    @DPTR,A
   \   000199   85..82       MOV     DPL,?XSP + 0
   \   00019C   85..83       MOV     DPH,?XSP + 1
   \   00019F   E0           MOVX    A,@DPTR
   \   0001A0   600C         JZ      ??zclParseInConfigReportCmd_13
   \   0001A2   75..01       MOV     ?V10,#0x1
   \   0001A5   75..00       MOV     ?V11,#0x0
   \   0001A8   7A00         MOV     R2,#0x0
   \   0001AA   7B00         MOV     R3,#0x0
   \   0001AC   8036         SJMP    ??zclParseInConfigReportCmd_14
   \                     ??zclParseInConfigReportCmd_13:
   \   0001AE   75..FF       MOV     ?V10,#-0x1
   \   0001B1   75..FF       MOV     ?V11,#-0x1
   \   0001B4   E8           MOV     A,R0
   \   0001B5   24FF         ADD     A,#-0x1
   \   0001B7   1A           DEC     R2
   \   0001B8   E9           MOV     A,R1
   \   0001B9   34FF         ADDC    A,#-0x1
   \   0001BB   8026         SJMP    ??zclParseInConfigReportCmd_15
   \                     ??zclParseInConfigReportCmd_16:
   \   0001BD   85..82       MOV     DPL,?V2
   \   0001C0   85..83       MOV     DPH,?V3
   \   0001C3   E0           MOVX    A,@DPTR
   \   0001C4   C0E0         PUSH    A
   \   0001C6   E5..         MOV     A,?V6
   \   0001C8   2A           ADD     A,R2
   \   0001C9   F582         MOV     DPL,A
   \   0001CB   E5..         MOV     A,?V7
   \   0001CD   3B           ADDC    A,R3
   \   0001CE   F583         MOV     DPH,A
   \   0001D0   D0E0         POP     A
   \   0001D2   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   0001D5   A3           INC     DPTR
   \   0001D6   8582..       MOV     ?V2,DPL
   \   0001D9   8583..       MOV     ?V3,DPH
   \   0001DC   EA           MOV     A,R2
   \   0001DD   25..         ADD     A,?V10
   \   0001DF   FA           MOV     R2,A
   \   0001E0   EB           MOV     A,R3
   \   0001E1   35..         ADDC    A,?V11
   \                     ??zclParseInConfigReportCmd_15:
   \   0001E3   FB           MOV     R3,A
   \                     ??zclParseInConfigReportCmd_14:
   \   0001E4   E8           MOV     A,R0
   \   0001E5   FC           MOV     R4,A
   \   0001E6   E9           MOV     A,R1
   \   0001E7   FD           MOV     R5,A
   \   0001E8   EC           MOV     A,R4
   \   0001E9   24FF         ADD     A,#-0x1
   \   0001EB   18           DEC     R0
   \   0001EC   ED           MOV     A,R5
   \   0001ED   34FF         ADDC    A,#-0x1
   \   0001EF   F9           MOV     R1,A
   \   0001F0   EC           MOV     A,R4
   \   0001F1   4D           ORL     A,R5
   \   0001F2   70C9         JNZ     ??zclParseInConfigReportCmd_16
   \   0001F4   85..82       MOV     DPL,?V0
   \   0001F7   85..83       MOV     DPH,?V1
   \   0001FA   A3           INC     DPTR
   \   0001FB   A3           INC     DPTR
   \   0001FC   A3           INC     DPTR
   \   0001FD   A3           INC     DPTR
   \   0001FE   A3           INC     DPTR
   \   0001FF   A3           INC     DPTR
   \   000200   A3           INC     DPTR
   \   000201   A3           INC     DPTR
   \   000202   A3           INC     DPTR
   \   000203   A3           INC     DPTR
   \   000204   E5..         MOV     A,?V6
   \   000206   F0           MOVX    @DPTR,A
   \   000207   A3           INC     DPTR
   \   000208   E5..         MOV     A,?V7
   \   00020A   F0           MOVX    @DPTR,A
   \   00020B                ; Setup parameters for call to function zclGetDataTypeLength
   \   00020B   85..82       MOV     DPL,?V12
   \   00020E   85..83       MOV     DPH,?V13
   \   000211   E0           MOVX    A,@DPTR
   \   000212   F9           MOV     R1,A
   \   000213   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000216   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000219   5001         JNC     ??zclParseInConfigReportCmd_17
   \   00021B   0A           INC     R2
   \                     ??zclParseInConfigReportCmd_17:
   \   00021C   12....       LCALL   ?Subroutine107 & 0xFFFF
   3872              } // while loop
   3873            }
   \                     ??CrossCallReturnLabel_194:
   \   00021F   02....       LJMP    ??zclParseInConfigReportCmd_9 & 0xFFFF
   3874          
   3875            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_6:
   \   000222   AA..         MOV     R2,?V8
   \   000224   AB..         MOV     R3,?V9
   \   000226   02....       LJMP    ?Subroutine7 & 0xFFFF
   3876          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   E9           MOV     A,R1
   \   000001   FA           MOV     R2,A
   \   000002   EE           MOV     A,R6
   \   000003   29           ADD     A,R1
   \   000004   FE           MOV     R6,A
   \   000005   E4           CLR     A
   \   000006   3F           ADDC    A,R7
   \   000007   FF           MOV     R7,A
   \   000008   EA           MOV     A,R2
   \   000009   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   E5..         MOV     A,?V6
   \   000002   2A           ADD     A,R2
   \   000003   F5..         MOV     ?V6,A
   \   000005   E4           CLR     A
   \   000006   35..         ADDC    A,?V7
   \   000008   F5..         MOV     ?V7,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   FC           MOV     R4,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   85..82       MOV     DPL,?V0
   \   000008   85..83       MOV     DPH,?V1
   \   00000B   22           RET
   3877          #endif
   3878          
   3879          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   3880          /*********************************************************************
   3881           * @fn      zclParseInConfigReportRspCmd
   3882           *
   3883           * @brief   Parse the "Profile" Configure Reporting Response Command
   3884           *
   3885           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3886           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3887           *
   3888           * @param   pCmd - pointer to incoming data to parse
   3889           *
   3890           * @return  pointer to the parsed command structure
   3891           */
   3892          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   3893          {
   3894            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3895            uint8 *pBuf = pCmd->pData;
   3896            uint8 numAttr;
   3897          
   3898            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   3899          
   3900            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3901                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   3902            if ( cfgReportRspCmd != NULL )
   3903            {
   3904              uint8 i;
   3905              cfgReportRspCmd->numAttr = numAttr;
   3906              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   3907              {
   3908                cfgReportRspCmd->attrList[i].status = *pBuf++;
   3909                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3910                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3911                pBuf += 2;
   3912              }
   3913            }
   3914          
   3915            return ( (void *)cfgReportRspCmd );
   3916          }
   3917          #endif
   3918          
   3919          #ifdef ZCL_REPORTING_DEVICE
   3920          /*********************************************************************
   3921           * @fn      zclParseInReadReportCfgCmd
   3922           *
   3923           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3924           *
   3925           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3926           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3927           *
   3928           * @param   pCmd - pointer to incoming data to parse
   3929           *
   3930           * @return  pointer to the parsed command structure
   3931           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3932          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   3933          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3934            zclReadReportCfgCmd_t *readReportCfgCmd;
   3935            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine94 & 0xFFFF
   3936            uint8 numAttr;
   3937          
   3938            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \                     ??CrossCallReturnLabel_163:
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   A3           INC     DPTR
   \   000014   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_404:
   \   000017   7A03         MOV     R2,#0x3
   \   000019   7B00         MOV     R3,#0x0
   \   00001B   12....       LCALL   ?US_DIV_MOD
   \   00001E   E8           MOV     A,R0
   \   00001F   F5..         MOV     ?V0,A
   3939          
   3940            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3941                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   000021                ; Setup parameters for call to function osal_mem_alloc
   \   000021   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_445:
   \   000024   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3942            if ( readReportCfgCmd != NULL )
   \   000027   EA           MOV     A,R2
   \   000028   4B           ORL     A,R3
   \   000029   602F         JZ      ??zclParseInReadReportCfgCmd_0
   3943            {
   3944              uint8 i;
   3945              readReportCfgCmd->numAttr = numAttr;
   \   00002B   8A82         MOV     DPL,R2
   \   00002D   8B83         MOV     DPH,R3
   \   00002F   E5..         MOV     A,?V0
   \   000031   F0           MOVX    @DPTR,A
   3946              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   \   000032   75..00       MOV     ?V2,#0x0
   \   000035   801A         SJMP    ??zclParseInReadReportCfgCmd_1
   3947              {
   3948                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \                     ??zclParseInReadReportCfgCmd_2:
   \   000037   E5..         MOV     A,?V2
   \   000039   12....       LCALL   ?Subroutine15 & 0xFFFF
   3949                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3950                pBuf += 2;
   3951              }
   \                     ??CrossCallReturnLabel_395:
   \   00003C   F5..         MOV     ?V0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FD           MOV     R5,A
   \   000041   E5..         MOV     A,?V0
   \   000043   8882         MOV     DPL,R0
   \   000045   8983         MOV     DPH,R1
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   00004C   5001         JNC     ??zclParseInReadReportCfgCmd_3
   \   00004E   0F           INC     R7
   \                     ??zclParseInReadReportCfgCmd_3:
   \   00004F   05..         INC     ?V2
   \                     ??zclParseInReadReportCfgCmd_1:
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   3952            }
   \                     ??CrossCallReturnLabel_414:
   \   000058   40DD         JC      ??zclParseInReadReportCfgCmd_2
   3953          
   3954            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_0:
   \   00005A   02....       LJMP    ?Subroutine1 & 0xFFFF
   3955          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine136:
   \   000000   75F003       MOV     B,#0x3
   \   000003                REQUIRE ??Subroutine182_0
   \   000003                ; // Fall through to label ??Subroutine182_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine182_0:
   \   000000   A4           MUL     AB
   \   000001   A9F0         MOV     R1,B
   \   000003   2401         ADD     A,#0x1
   \   000005   FA           MOV     R2,A
   \   000006   E4           CLR     A
   \   000007   39           ADDC    A,R1
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   3956          #endif
   3957          
   3958          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   3959          /*********************************************************************
   3960           * @fn      zclParseInReadReportCfgRspCmd
   3961           *
   3962           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3963           *
   3964           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3965           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3966           *
   3967           * @param   pCmd - pointer to incoming data to parse
   3968           *
   3969           * @return  pointer to the parsed command structure
   3970           */
   3971          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   3972          {
   3973            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3974            uint8 reportChangeLen;
   3975            uint8 *pBuf = pCmd->pData;
   3976            uint8 *dataPtr;
   3977            uint8 numAttr = 0;
   3978            uint8 hdrLen;
   3979            uint16 dataLen = 0;
   3980          
   3981            // Calculate the length of the response command
   3982            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3983            {
   3984              uint8 status;
   3985              uint8 direction;
   3986          
   3987              numAttr++;
   3988              status = *pBuf++;
   3989              direction = *pBuf++;
   3990              pBuf += 2; // move pass the attribute ID
   3991          
   3992              if ( status == ZCL_STATUS_SUCCESS )
   3993              {
   3994                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3995                {
   3996                  uint8 dataType = *pBuf++;
   3997                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3998          
   3999                  // For attributes of 'discrete' data types this field is omitted
   4000                  if ( zclAnalogDataType( dataType ) )
   4001                  {
   4002                    reportChangeLen = zclGetDataTypeLength( dataType );
   4003                    pBuf += reportChangeLen;
   4004          
   4005                    // add padding if needed
   4006                    if ( PADDING_NEEDED( reportChangeLen ) )
   4007                    {
   4008                      reportChangeLen++;
   4009                    }
   4010          
   4011                    dataLen += reportChangeLen;
   4012                  }
   4013                }
   4014                else
   4015                {
   4016                  pBuf += 2; // move pass the Timeout field
   4017                }
   4018              }
   4019            } // while loop
   4020          
   4021            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   4022          
   4023            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   4024            if ( readReportCfgRspCmd != NULL )
   4025            {
   4026              uint8 i;
   4027              pBuf = pCmd->pData;
   4028              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   4029          
   4030              readReportCfgRspCmd->numAttr = numAttr;
   4031              for ( i = 0; i < numAttr; i++ )
   4032              {
   4033                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   4034          
   4035                reportRspRec->status = *pBuf++;
   4036                reportRspRec->direction = *pBuf++;
   4037                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4038                pBuf += 2;
   4039          
   4040                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   4041                {
   4042                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   4043                  {
   4044                    reportRspRec->dataType = *pBuf++;
   4045                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   4046                    pBuf += 2;
   4047                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   4048                    pBuf += 2;
   4049          
   4050                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   4051                    {
   4052                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   4053                      reportRspRec->reportableChange = dataPtr;
   4054          
   4055                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   4056                      pBuf += reportChangeLen;
   4057          
   4058                      // advance attribute data pointer
   4059                      if ( PADDING_NEEDED( reportChangeLen ) )
   4060                      {
   4061                        reportChangeLen++;
   4062                      }
   4063          
   4064                      dataPtr += reportChangeLen;
   4065                    }
   4066                  }
   4067                  else
   4068                  {
   4069                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   4070                    pBuf += 2;
   4071                  }
   4072                }
   4073              }
   4074            }
   4075          
   4076            return ( (void *)readReportCfgRspCmd );
   4077          }
   4078          #endif
   4079          
   4080          #ifdef ZCL_REPORT_DESTINATION_DEVICE
   4081          /*********************************************************************
   4082           * @fn      zclParseInReportCmd
   4083           *
   4084           * @brief   Parse the "Profile" Report Command
   4085           *
   4086           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4087           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4088           *
   4089           * @param   pCmd - pointer to incoming data to parse
   4090           *
   4091           * @return  pointer to the parsed command structure
   4092           */
   4093          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   4094          {
   4095            zclReportCmd_t *reportCmd;
   4096            uint8 *pBuf = pCmd->pData;
   4097            uint16 attrDataLen;
   4098            uint8 *dataPtr;
   4099            uint8 numAttr = 0;
   4100            uint8 hdrLen;
   4101            uint16 dataLen = 0;
   4102          
   4103            // find out the number of attributes and the length of attribute data
   4104            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   4105            {
   4106              uint8 dataType;
   4107          
   4108              numAttr++;
   4109              pBuf += 2; // move pass attribute id
   4110          
   4111              dataType = *pBuf++;
   4112          
   4113              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   4114              pBuf += attrDataLen; // move pass attribute data
   4115          
   4116              // add padding if needed
   4117              if ( PADDING_NEEDED( attrDataLen ) )
   4118              {
   4119                attrDataLen++;
   4120              }
   4121          
   4122              dataLen += attrDataLen;
   4123            }
   4124          
   4125            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   4126          
   4127            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   4128            if (reportCmd != NULL )
   4129            {
   4130              uint8 i;
   4131              pBuf = pCmd->pData;
   4132              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   4133          
   4134              reportCmd->numAttr = numAttr;
   4135              for ( i = 0; i < numAttr; i++ )
   4136              {
   4137                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   4138          
   4139                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4140                pBuf += 2;
   4141                reportRec->dataType = *pBuf++;
   4142          
   4143                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   4144                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   4145                reportRec->attrData = dataPtr;
   4146          
   4147                pBuf += attrDataLen; // move pass attribute data
   4148          
   4149                // advance attribute data pointer
   4150                if ( PADDING_NEEDED( attrDataLen ) )
   4151                {
   4152                  attrDataLen++;
   4153                }
   4154          
   4155                dataPtr += attrDataLen;
   4156              }
   4157            }
   4158          
   4159            return ( (void *)reportCmd );
   4160          }
   4161          #endif
   4162          
   4163          /*********************************************************************
   4164           * @fn      zclParseInDefaultRspCmd
   4165           *
   4166           * @brief   Parse the "Profile" Default Response Command
   4167           *
   4168           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4169           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4170           *
   4171           * @param   pCmd - pointer to incoming data to parse
   4172           *
   4173           * @return  pointer to the parsed command structure
   4174           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4175          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   4176          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4177            zclDefaultRspCmd_t *defaultRspCmd;
   4178            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine81 & 0xFFFF
   4179          
   4180            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_140:
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A02         MOV     R2,#0x2
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   4181            if ( defaultRspCmd != NULL )
   \   00000F   EA           MOV     A,R2
   \   000010   4B           ORL     A,R3
   \   000011   6009         JZ      ??zclParseInDefaultRspCmd_0
   4182            {
   4183              defaultRspCmd->commandID = *pBuf++;
   \   000013   12....       LCALL   ?Subroutine24 & 0xFFFF
   4184              defaultRspCmd->statusCode = *pBuf;
   4185            }
   \                     ??CrossCallReturnLabel_344:
   \   000016   8A82         MOV     DPL,R2
   \   000018   8B83         MOV     DPH,R3
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   4186          
   4187            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   00001C   02....       LJMP    ?Subroutine3 & 0xFFFF
   4188          }
   4189          
   4190          #ifdef ZCL_DISCOVER
   4191          /*********************************************************************
   4192           * @fn      zclParseInDiscAttrsCmd
   4193           *
   4194           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   4195           *
   4196           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4197           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4198           *
   4199           * @param   pCmd - pointer to incoming data to parse
   4200           *
   4201           * @return  pointer to the parsed command structure
   4202           */
   4203          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   4204          {
   4205            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4206            uint8 *pBuf = pCmd->pData;
   4207          
   4208            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   4209            if ( pDiscoverCmd != NULL )
   4210            {
   4211              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   4212              pBuf += 2;
   4213              pDiscoverCmd->maxAttrIDs = *pBuf;
   4214            }
   4215          
   4216            return ( (void *)pDiscoverCmd );
   4217          }
   4218          
   4219          /*********************************************************************
   4220           * @fn      zclParseInDiscAttrsRspCmd
   4221           *
   4222           * @brief   Parse the "Profile" Discovery Response Commands
   4223           *
   4224           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4225           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4226           *
   4227           * @param   pCmd - pointer to incoming data to parse
   4228           *
   4229           * @return  pointer to the parsed command structure
   4230           */
   4231          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4232          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   4233          {
   4234            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   4235            uint8 *pBuf = pCmd->pData;
   4236            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   4237          
   4238            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   4239                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   4240          
   4241            if ( pDiscoverRspCmd != NULL )
   4242            {
   4243              uint8 i;
   4244          
   4245              pDiscoverRspCmd->discComplete = *pBuf++;
   4246              pDiscoverRspCmd->numAttr = numAttr;
   4247          
   4248              for ( i = 0; i < numAttr; i++ )
   4249              {
   4250                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4251                pBuf += 2;
   4252                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   4253              }
   4254            }
   4255          
   4256            return ( (void *)pDiscoverRspCmd );
   4257          }
   4258          
   4259          /*********************************************************************
   4260           * @fn      zclParseInDiscCmdsCmd
   4261           *
   4262           * @brief   Parse the "Profile" Discovery Commands
   4263           *
   4264           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4265           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4266           *
   4267           * @param   pCmd - pointer to incoming data to parse
   4268           *
   4269           * @return  pointer to the parsed command structure
   4270           */
   4271          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   4272          {
   4273            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4274            uint8 *pBuf = pCmd->pData;
   4275          
   4276            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   4277            if ( pDiscoverCmd != NULL )
   4278            {
   4279              pDiscoverCmd->startCmdID = *pBuf++;
   4280              pDiscoverCmd->maxCmdID = *pBuf++;
   4281            }
   4282          
   4283            return ( (void *)pDiscoverCmd );
   4284          }
   4285          
   4286          /*********************************************************************
   4287           * @fn      zclParseInDiscCmdsRspCmd
   4288           *
   4289           * @brief   Parse the Discover Commands Response Command
   4290           *
   4291           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4292           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4293           *
   4294           * @param   pCmd - pointer to incoming data to parse
   4295           *
   4296           * @return  pointer to the parsed command structure
   4297           */
   4298          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4299          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   4300          {
   4301            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   4302            uint8 *pBuf = pCmd->pData;
   4303            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   4304          
   4305              // allocate memory for size of structure plus variable array
   4306            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   4307                              ( numCmds * sizeof(uint8) ) );
   4308            if ( pDiscoverRspCmd != NULL )
   4309            {
   4310              uint8 i;
   4311              pDiscoverRspCmd->discComplete = *pBuf++;
   4312              pDiscoverRspCmd->numCmd = numCmds;
   4313          
   4314              for ( i = 0; i < numCmds; i++ )
   4315              {
   4316                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   4317              }
   4318            }
   4319          
   4320            return ( (void *)pDiscoverRspCmd );
   4321          }
   4322          
   4323          /*********************************************************************
   4324           * @fn      zclParseInDiscAttrsExtRspCmd
   4325           *
   4326           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4327           *
   4328           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4329           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4330           *
   4331           * @param   pCmd - pointer to incoming data to parse
   4332           *
   4333           * @return  pointer to the parsed command structure
   4334           */
   4335          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4336          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   4337          {
   4338            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4339            uint8 i;
   4340            uint8 *pBuf = pCmd->pData;
   4341            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   4342          
   4343            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4344                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   4345          
   4346            if ( pDiscoverRspCmd != NULL )
   4347            {
   4348              pDiscoverRspCmd->discComplete = *pBuf++;
   4349              pDiscoverRspCmd->numAttr = numAttrs;
   4350          
   4351              for ( i = 0; i < numAttrs; i++ )
   4352              {
   4353                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4354                pBuf += 2;
   4355                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4356                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   4357              }
   4358            }
   4359          
   4360            return ( (void *)pDiscoverRspCmd );
   4361          }
   4362          #endif // ZCL_DISCOVER
   4363          
   4364          #ifdef ZCL_READ
   4365          /*********************************************************************
   4366           * @fn      zclProcessInReadCmd
   4367           *
   4368           * @brief   Process the "Profile" Read Command
   4369           *
   4370           * @param   pInMsg - incoming message to process
   4371           *
   4372           * @return  TRUE if command processed. FALSE, otherwise.
   4373           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine144_0
   \   000002                ; // Fall through to label ??Subroutine144_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine159_0
   \   000006                ; // Fall through to label ??Subroutine159_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4374          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4375          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   4376            zclReadCmd_t *readCmd;
   4377            zclReadRspCmd_t *readRspCmd;
   4378            zclAttrRec_t attrRec;
   4379            uint16 len;
   4380            uint8 i;
   4381            uint8 attrFound;
   4382          
   4383            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F583         MOV     DPH,A
   \   000017   12....       LCALL   ?Subroutine44 & 0xFFFF
   4384          
   4385            // calculate the length of the response status record
   4386            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4387          
   4388            readRspCmd = zcl_mem_alloc( len );
   \                     ??CrossCallReturnLabel_52:
   \   00001A                ; Setup parameters for call to function osal_mem_alloc
   \   00001A   85..82       MOV     DPL,?V8
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   75F006       MOV     B,#0x6
   \   000023   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_444:
   \   000026   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000029   8A..         MOV     ?V4,R2
   \   00002B   8B..         MOV     ?V5,R3
   4389            if ( readRspCmd == NULL )
   \   00002D   EA           MOV     A,R2
   \   00002E   45..         ORL     A,?V5
   \   000030   7005         JNZ     ??zclProcessInReadCmd_0
   4390            {
   4391              return FALSE; // EMBEDDED RETURN
   \   000032   7900         MOV     R1,#0x0
   \   000034   02....       LJMP    ??zclProcessInReadCmd_1 & 0xFFFF
   4392            }
   4393          
   4394            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   000037   85..82       MOV     DPL,?V8
   \   00003A   85..83       MOV     DPH,?V9
   \   00003D   12....       LCALL   ??Subroutine149_0 & 0xFFFF
   4395            for ( i = 0; i < readCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_283:
   \   000040   75..00       MOV     ?V0,#0x0
   \   000043   EE           MOV     A,R6
   \   000044   2402         ADD     A,#0x2
   \   000046   F5..         MOV     ?V14,A
   \   000048   E4           CLR     A
   \   000049   3F           ADDC    A,R7
   \   00004A   F5..         MOV     ?V15,A
   \   00004C   800B         SJMP    ??zclProcessInReadCmd_2
   4396            {
   4397              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4398          
   4399              statusRec->attrID = readCmd->attrID[i];
   4400              
   4401              attrFound = zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec );
   4402            
   4403              if ( ( GET_BIT( &attrRec.attr.accessControl, ACCESS_CONTROL_MASK ) == pInMsg->hdr.fc.direction ) && ( attrFound == TRUE ) )
   4404              {
   4405                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4406                {
   4407                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4408                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4409                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4410                  {
   4411                    statusRec->data = attrRec.attr.dataPtr;
   4412                    statusRec->dataType = attrRec.attr.dataType;
   4413                  }
   4414                }
   4415                else
   4416                {
   4417                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4418                }
   4419              }
   4420              else
   4421              {
   4422                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_3:
   \   00004E   85..82       MOV     DPL,?V2
   \   000051   85..83       MOV     DPH,?V3
   \   000054   7486         MOV     A,#-0x7a
   \                     ??zclProcessInReadCmd_4:
   \   000056   F0           MOVX    @DPTR,A
   4423              }
   \                     ??zclProcessInReadCmd_5:
   \   000057   05..         INC     ?V0
   \                     ??zclProcessInReadCmd_2:
   \   000059   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   00005C   4003         JC      $+5
   \   00005E   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   000061   A8..         MOV     R0,?V0
   \   000063   E8           MOV     A,R0
   \   000064   75F006       MOV     B,#0x6
   \   000067   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   00006A   8582..       MOV     ?V6,DPL
   \   00006D   8583..       MOV     ?V7,DPH
   \   000070   E8           MOV     A,R0
   \   000071   28           ADD     A,R0
   \   000072   F8           MOV     R0,A
   \   000073   E4           CLR     A
   \   000074   33           RLC     A
   \   000075   F9           MOV     R1,A
   \   000076   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000079   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   00007C   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_418:
   \   00007F   F5..         MOV     ?V2,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F5..         MOV     ?V3,A
   \   000085                ; Setup parameters for call to function zclFindAttrRec
   \   000085   A8..         MOV     R0,?XSP + 0
   \   000087   A9..         MOV     R1,?XSP + 1
   \   000089   88..         MOV     ?V10,R0
   \   00008B   89..         MOV     ?V11,R1
   \   00008D   78..         MOV     R0,#?V10
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000092   8A82         MOV     DPL,R2
   \   000094   8B83         MOV     DPH,R3
   \   000096   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_428:
   \   000099   85..82       MOV     DPL,?V2
   \   00009C   85..83       MOV     DPH,?V3
   \   00009F   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_382:
   \   0000A2   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   0000A5   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000A8   7402         MOV     A,#0x2
   \   0000AA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AD   E9           MOV     A,R1
   \   0000AE   F8           MOV     R0,A
   \   0000AF   E5..         MOV     A,?V6
   \   0000B1   2402         ADD     A,#0x2
   \   0000B3   F5..         MOV     ?V2,A
   \   0000B5   E4           CLR     A
   \   0000B6   35..         ADDC    A,?V7
   \   0000B8   F5..         MOV     ?V3,A
   \   0000BA   85..82       MOV     DPL,?V14
   \   0000BD   85..83       MOV     DPH,?V15
   \   0000C0   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   0000C3   7405         MOV     A,#0x5
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   A2E7         MOV     C,0xE0 /* A   */.7
   \   0000CB   20F001       JB      B.0,??zclProcessInReadCmd_7
   \   0000CE   B3           CPL     C
   \                     ??zclProcessInReadCmd_7:
   \   0000CF   4003         JC      $+5
   \   0000D1   02....       LJMP    ??zclProcessInReadCmd_3 & 0xFFFF
   \   0000D4   7401         MOV     A,#0x1
   \   0000D6   68           XRL     A,R0
   \   0000D7   6003         JZ      $+5
   \   0000D9   02....       LJMP    ??zclProcessInReadCmd_3 & 0xFFFF
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000DF   5061         JNC     ??zclProcessInReadCmd_8
   \   0000E1   8E82         MOV     DPL,R6
   \   0000E3   8F83         MOV     DPH,R7
   \   0000E5   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   0000E8   2406         ADD     A,#0x6
   \   0000EA   F5..         MOV     ?V10,A
   \   0000EC   E4           CLR     A
   \   0000ED   39           ADDC    A,R1
   \   0000EE   F5..         MOV     ?V11,A
   \   0000F0   7405         MOV     A,#0x5
   \   0000F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000F8   5020         JNC     ??zclProcessInReadCmd_9
   \   0000FA                ; Setup parameters for call to function zclGetAuthorizeCB
   \   0000FA   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   0000FD   12....       LCALL   `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   000100   8A82         MOV     DPL,R2
   \   000102   8B83         MOV     DPH,R3
   \   000104   E582         MOV     A,DPL
   \   000106   4583         ORL     A,DPH
   \   000108   6010         JZ      ??zclProcessInReadCmd_9
   \   00010A                ; Setup parameters for indirect call
   \   00010A   7901         MOV     R1,#0x1
   \   00010C   AC..         MOV     R4,?XSP + 0
   \   00010E   AD..         MOV     R5,?XSP + 1
   \   000110   AA..         MOV     R2,?V10
   \   000112   AB..         MOV     R3,?V11
   \   000114   12....       LCALL   ?CALL_IND
   \   000117   E9           MOV     A,R1
   \   000118   8002         SJMP    ??zclProcessInReadCmd_10
   \                     ??zclProcessInReadCmd_9:
   \   00011A   7400         MOV     A,#0x0
   4424            }
   \                     ??zclProcessInReadCmd_10:
   \   00011C   85..82       MOV     DPL,?V2
   \   00011F   85..83       MOV     DPH,?V3
   \   000122   F0           MOVX    @DPTR,A
   \   000123   6003         JZ      $+5
   \   000125   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   \   000128   7406         MOV     A,#0x6
   \   00012A   12....       LCALL   ?XSTACK_DISP0_8
   \   00012D   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   000130   A3           INC     DPTR
   \   000131   A3           INC     DPTR
   \   000132   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   000135   7404         MOV     A,#0x4
   \   000137   12....       LCALL   ?XSTACK_DISP0_8
   \   00013A   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   00013D   A3           INC     DPTR
   \   00013E   A3           INC     DPTR
   \   00013F   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   \                     ??zclProcessInReadCmd_8:
   \   000142   85..82       MOV     DPL,?V2
   \   000145   85..83       MOV     DPH,?V3
   \   000148   748F         MOV     A,#-0x71
   \   00014A   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   4425          
   4426            // Build and send Read Response command
   4427            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4428                             readRspCmd, !pInMsg->hdr.fc.direction,
   4429                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   00014D   8E82         MOV     DPL,R6
   \   00014F   8F83         MOV     DPH,R7
   \   000151   E0           MOVX    A,@DPTR
   \   000152   F5..         MOV     ?V2,A
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   F5..         MOV     ?V3,A
   \   000158                ; Setup parameters for call to function zcl_SendReadRsp
   \   000158   8E82         MOV     DPL,R6
   \   00015A   8F83         MOV     DPH,R7
   \   00015C   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   00015F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000162   75..01       MOV     ?V0,#0x1
   \   000165   78..         MOV     R0,#?V0
   \   000167   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016A   85..82       MOV     DPL,?V14
   \   00016D   85..83       MOV     DPH,?V15
   \   000170   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000173   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000176   78..         MOV     R0,#?V4
   \   000178   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017B   85..82       MOV     DPL,?V2
   \   00017E   85..83       MOV     DPH,?V3
   \   000181   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_434:
   \   000184   E5..         MOV     A,?V2
   \   000186   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_435:
   \   000189   35..         ADDC    A,?V3
   \   00018B   FB           MOV     R3,A
   \   00018C   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   00018F   12....       LCALL   `??zcl_SendReadRsp::?relay`; Banked call to: zcl_SendReadRsp
   \   000192   7405         MOV     A,#0x5
   \   000194   12....       LCALL   ?DEALLOC_XSTACK8
   4430            zcl_mem_free( readRspCmd );
   \   000197                ; Setup parameters for call to function osal_mem_free
   \   000197   AA..         MOV     R2,?V4
   \   000199   AB..         MOV     R3,?V5
   \   00019B   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4431          
   4432            return TRUE;
   \   00019E   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   0001A0   7408         MOV     A,#0x8
   \   0001A2                REQUIRE ?Subroutine5
   \   0001A2                ; // Fall through to label ?Subroutine5
   4433          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   E5..         MOV     A,?V2
   \   000002   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000005   35..         ADDC    A,?V3
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_408:
   \   000003   85..82       MOV     DPL,?V6
   \   000006   85..83       MOV     DPH,?V7
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   A2E0         MOV     C,0xE0 /* A   */.0
   \   000008   92F0         MOV     B.0,C
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000003   F5..         MOV     ?V0,A
   \   000005   78..         MOV     R0,#?V0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine180_0:
   \   000000   2406         ADD     A,#0x6
   \   000002   FA           MOV     R2,A
   \   000003   E4           CLR     A
   \   000004   22           RET
   4434          #endif // ZCL_READ
   4435          
   4436          #ifdef ZCL_WRITE
   4437          /*********************************************************************
   4438           * @fn      processInWriteCmd
   4439           *
   4440           * @brief   Process the "Profile" Write and Write No Response Commands
   4441           *
   4442           * @param   pInMsg - incoming message to process
   4443           *
   4444           * @return  TRUE if command processed. FALSE, otherwise.
   4445           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   7E00         MOV     R6,#0x0
   \   000002   EA           MOV     A,R2
   \   000003   240C         ADD     A,#0xc
   \   000005   F582         MOV     DPL,A
   \   000007   E4           CLR     A
   \   000008   35..         ADDC    A,?V5
   \   00000A   F583         MOV     DPH,A
   \   00000C                REQUIRE ??Subroutine175_0
   \   00000C                ; // Fall through to label ??Subroutine175_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4446          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4447          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4448            zclWriteCmd_t *writeCmd;
   4449            zclWriteRspCmd_t *writeRspCmd;
   4450            uint8 sendRsp = FALSE;
   \   00000E   7F00         MOV     R7,#0x0
   4451            uint8 j = 0;
   \   000010   12....       LCALL   ?Subroutine83 & 0xFFFF
   4452            uint8 i;
   4453          
   4454            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_399:
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   E8           MOV     A,R0
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   E9           MOV     A,R1
   \   00001D   12....       LCALL   ?Subroutine20 & 0xFFFF
   4455            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \                     ??CrossCallReturnLabel_13:
   \   000020   6402         XRL     A,#0x2
   \   000022   701C         JNZ     ??zclProcessInWriteCmd_0
   4456            {
   4457              // We need to send a response back - allocate space for it
   4458              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4459                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000024                ; Setup parameters for call to function osal_mem_alloc
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00002D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000030   8A..         MOV     ?V2,R2
   \   000032   8B..         MOV     ?V3,R3
   4460              if ( writeRspCmd == NULL )
   \   000034   EA           MOV     A,R2
   \   000035   45..         ORL     A,?V3
   \   000037   7005         JNZ     ??zclProcessInWriteCmd_1
   4461              {
   4462                return FALSE; // EMBEDDED RETURN
   \   000039   7900         MOV     R1,#0x0
   \   00003B   02....       LJMP    ??zclProcessInWriteCmd_2 & 0xFFFF
   4463              }
   4464          
   4465              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   00003E   7F01         MOV     R7,#0x1
   4466            }
   4467          
   4468            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   000040   75..00       MOV     ?V6,#0x0
   \   000043   8012         SJMP    ??zclProcessInWriteCmd_3
   4469            {
   4470              zclAttrRec_t attrRec;
   4471              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4472          
   4473              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4474                                   statusRec->attrID, &attrRec ) )
   4475              {
   4476                if ( GET_BIT( &attrRec.attr.accessControl, ACCESS_CONTROLEXT_MASK ) != pInMsg->hdr.fc.direction )
   4477                {
   4478                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4479                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4480                  break;
   4481                }
   4482                if ( statusRec->dataType == attrRec.attr.dataType )
   4483                {
   4484                  uint8 status;
   4485          
   4486                  // Write the new attribute value
   4487                  if ( attrRec.attr.dataPtr != NULL )
   4488                  {
   4489                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4490                                               &attrRec, statusRec );
   4491                  }
   4492                  else // Use CB
   4493                  {
   4494                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4495                                                      &attrRec, statusRec->attrData );
   4496                  }
   4497          
   4498                  // If successful, a write attribute status record shall NOT be generated
   4499                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4500                  {
   4501                    // Attribute is read only - move on to the next write attribute record
   4502                    writeRspCmd->attrList[j].status = status;
   4503                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4504                  }
   4505                }
   4506                else
   4507                {
   4508                  // Attribute data type is incorrect - move on to the next write attribute record
   4509                  if ( sendRsp )
   4510                  {
   4511                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4512                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4513                  }
   4514                }
   4515              }
   4516              else
   4517              {
   4518                // Attribute is not supported - move on to the next write attribute record
   4519                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   000045   EF           MOV     A,R7
   \   000046   A2E0         MOV     C,0xE0 /* A   */.0
   \   000048   500B         JNC     ??CrossCallReturnLabel_2
   4520                {
   4521                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   00004A   85..82       MOV     DPL,?V14
   \   00004D   85..83       MOV     DPH,?V15
   \   000050   7486         MOV     A,#-0x7a
   4522                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4523                }
   4524              }
   \                     ??zclProcessInWriteCmd_5:
   \   000052   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000055   05..         INC     ?V6
   \                     ??zclProcessInWriteCmd_3:
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   000060   E5..         MOV     A,?V6
   \   000062   C3           CLR     C
   \   000063   98           SUBB    A,R0
   \   000064   4003         JC      $+5
   \   000066   02....       LJMP    ??CrossCallReturnLabel_3 & 0xFFFF
   \   000069   E5..         MOV     A,?V6
   \   00006B   75F005       MOV     B,#0x5
   \   00006E   A4           MUL     AB
   \   00006F   F8           MOV     R0,A
   \   000070   A9F0         MOV     R1,B
   \   000072   85..82       MOV     DPL,?XSP + 0
   \   000075   85..83       MOV     DPH,?XSP + 1
   \   000078   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   00007B   8582..       MOV     ?V0,DPL
   \   00007E   8583..       MOV     ?V1,DPH
   \   000081   EE           MOV     A,R6
   \   000082   75F003       MOV     B,#0x3
   \   000085   A4           MUL     AB
   \   000086   F8           MOV     R0,A
   \   000087   A9F0         MOV     R1,B
   \   000089   E5..         MOV     A,?V2
   \   00008B   28           ADD     A,R0
   \   00008C   F582         MOV     DPL,A
   \   00008E   E5..         MOV     A,?V3
   \   000090   39           ADDC    A,R1
   \   000091   F583         MOV     DPH,A
   \   000093   E582         MOV     A,DPL
   \   000095   2402         ADD     A,#0x2
   \   000097   F5..         MOV     ?V12,A
   \   000099   E4           CLR     A
   \   00009A   3583         ADDC    A,DPH
   \   00009C   F5..         MOV     ?V13,A
   \   00009E   A3           INC     DPTR
   \   00009F   8582..       MOV     ?V14,DPL
   \   0000A2   8583..       MOV     ?V15,DPH
   \   0000A5   85..82       MOV     DPL,?V4
   \   0000A8   85..83       MOV     DPH,?V5
   \   0000AB   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0000AE                ; Setup parameters for call to function zclFindAttrRec
   \   0000AE   7402         MOV     A,#0x2
   \   0000B0   12....       LCALL   ?XSTACK_DISP100_8
   \   0000B3   88..         MOV     ?V10,R0
   \   0000B5   89..         MOV     ?V11,R1
   \   0000B7   78..         MOV     R0,#?V10
   \   0000B9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BC   85..82       MOV     DPL,?V0
   \   0000BF   85..83       MOV     DPH,?V1
   \   0000C2   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_429:
   \   0000C5   85..82       MOV     DPL,?V8
   \   0000C8   85..83       MOV     DPH,?V9
   \   0000CB   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_383:
   \   0000CE   E5..         MOV     A,?V8
   \   0000D0   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   0000D3   35..         ADDC    A,?V9
   \   0000D5   F583         MOV     DPH,A
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   F9           MOV     R1,A
   \   0000D9   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000DC   7402         MOV     A,#0x2
   \   0000DE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E1   E9           MOV     A,R1
   \   0000E2   7003         JNZ     $+5
   \   0000E4   02....       LJMP    ??zclProcessInWriteCmd_4 & 0xFFFF
   \   0000E7   85..82       MOV     DPL,?V4
   \   0000EA   85..83       MOV     DPH,?V5
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   0000F2   7407         MOV     A,#0x7
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   A2E7         MOV     C,0xE0 /* A   */.7
   \   0000FA   20F001       JB      B.0,??zclProcessInWriteCmd_6
   \   0000FD   B3           CPL     C
   \                     ??zclProcessInWriteCmd_6:
   \   0000FE   405E         JC      ??zclProcessInWriteCmd_7
   \   000100   85..82       MOV     DPL,?V14
   \   000103   85..83       MOV     DPH,?V15
   \   000106   7486         MOV     A,#-0x7a
   \   000108   12....       LCALL   ?Subroutine13 & 0xFFFF
   4525            } // for loop
   4526          
   4527            if ( sendRsp )
   \                     ??CrossCallReturnLabel_3:
   \   00010B   EF           MOV     A,R7
   \   00010C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00010E   5047         JNC     ??zclProcessInWriteCmd_8
   4528            {
   4529              writeRspCmd->numAttr = j;
   \   000110   EE           MOV     A,R6
   \   000111   85..82       MOV     DPL,?V2
   \   000114   85..83       MOV     DPH,?V3
   \   000117   F0           MOVX    @DPTR,A
   4530              if ( writeRspCmd->numAttr == 0 )
   \   000118   7007         JNZ     ??zclProcessInWriteCmd_9
   4531              {
   4532                // Since all records were written successful, include a single status record
   4533                // in the resonse command with the status field set to SUCCESS and the
   4534                // attribute ID field omitted.
   4535                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   00011A   A3           INC     DPTR
   \   00011B   E4           CLR     A
   \   00011C   12....       LCALL   ?Subroutine112 & 0xFFFF
   4536                writeRspCmd->numAttr = 1;
   4537              }
   \                     ??CrossCallReturnLabel_201:
   \   00011F   04           INC     A
   \   000120   F0           MOVX    @DPTR,A
   4538          
   4539              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4540                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4541                                true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteCmd_9:
   \   000121   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000124   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000127   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00012A   75..01       MOV     ?V0,#0x1
   \   00012D   78..         MOV     R0,#?V0
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000132   85..82       MOV     DPL,?V4
   \   000135   85..83       MOV     DPH,?V5
   \   000138   A3           INC     DPTR
   \   000139   A3           INC     DPTR
   \   00013A   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   00013D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000140   78..         MOV     R0,#?V2
   \   000142   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000145   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000148   12....       LCALL   `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   00014B   7405         MOV     A,#0x5
   \   00014D   12....       LCALL   ?DEALLOC_XSTACK8
   4542              zcl_mem_free( writeRspCmd );
   \   000150                ; Setup parameters for call to function osal_mem_free
   \   000150   AA..         MOV     R2,?V2
   \   000152   AB..         MOV     R3,?V3
   \   000154   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4543            }
   4544          
   4545            return TRUE;
   \                     ??zclProcessInWriteCmd_8:
   \   000157   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   000159   740A         MOV     A,#0xa
   \   00015B   02....       LJMP    ?Subroutine5 & 0xFFFF
   \                     ??zclProcessInWriteCmd_7:
   \   00015E   85..82       MOV     DPL,?V0
   \   000161   85..83       MOV     DPH,?V1
   \   000164   A3           INC     DPTR
   \   000165   A3           INC     DPTR
   \   000166   E0           MOVX    A,@DPTR
   \   000167   F8           MOV     R0,A
   \   000168   7406         MOV     A,#0x6
   \   00016A   12....       LCALL   ?XSTACK_DISP0_8
   \   00016D   E0           MOVX    A,@DPTR
   \   00016E   68           XRL     A,R0
   \   00016F   7071         JNZ     ??zclProcessInWriteCmd_10
   \   000171   85..82       MOV     DPL,?V4
   \   000174   85..83       MOV     DPH,?V5
   \   000177   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   00017A   2414         ADD     A,#0x14
   \   00017C   F5..         MOV     ?V8,A
   \   00017E   E4           CLR     A
   \   00017F   39           ADDC    A,R1
   \   000180   F5..         MOV     ?V9,A
   \   000182   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_439:
   \   000185   39           ADDC    A,R1
   \   000186   FB           MOV     R3,A
   \   000187   7408         MOV     A,#0x8
   \   000189   12....       LCALL   ?XSTACK_DISP0_8
   \   00018C   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_353:
   \   00018F   6017         JZ      ??zclProcessInWriteCmd_11
   \   000191                ; Setup parameters for call to function zclWriteAttrData
   \   000191   78..         MOV     R0,#?V0
   \   000193   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000196   7404         MOV     A,#0x4
   \   000198   12....       LCALL   ?XSTACK_DISP102_8
   \   00019B   85..82       MOV     DPL,?V8
   \   00019E   85..83       MOV     DPH,?V9
   \   0001A1   E0           MOVX    A,@DPTR
   \   0001A2   F9           MOV     R1,A
   \   0001A3   12....       LCALL   `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   0001A6   801C         SJMP    ??zclProcessInWriteCmd_12
   \                     ??zclProcessInWriteCmd_11:
   \   0001A8                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   0001A8   85..82       MOV     DPL,?V0
   \   0001AB   85..83       MOV     DPH,?V1
   \   0001AE   A3           INC     DPTR
   \   0001AF   A3           INC     DPTR
   \   0001B0   A3           INC     DPTR
   \   0001B1   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001B4   7404         MOV     A,#0x4
   \   0001B6   12....       LCALL   ?XSTACK_DISP102_8
   \   0001B9   85..82       MOV     DPL,?V8
   \   0001BC   85..83       MOV     DPH,?V9
   \   0001BF   E0           MOVX    A,@DPTR
   \   0001C0   F9           MOV     R1,A
   \   0001C1   12....       LCALL   `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteCmd_12:
   \   0001C4   7402         MOV     A,#0x2
   \   0001C6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C9   E9           MOV     A,R1
   \   0001CA   F8           MOV     R0,A
   \   0001CB   EF           MOV     A,R7
   \   0001CC   A2E0         MOV     C,0xE0 /* A   */.0
   \   0001CE   4003         JC      $+5
   \   0001D0   02....       LJMP    ??CrossCallReturnLabel_2 & 0xFFFF
   \   0001D3   E8           MOV     A,R0
   \   0001D4   7003         JNZ     $+5
   \   0001D6   02....       LJMP    ??CrossCallReturnLabel_2 & 0xFFFF
   \   0001D9   85..82       MOV     DPL,?V14
   \   0001DC   85..83       MOV     DPH,?V15
   \   0001DF   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \                     ??zclProcessInWriteCmd_10:
   \   0001E2   EF           MOV     A,R7
   \   0001E3   A2E0         MOV     C,0xE0 /* A   */.0
   \   0001E5   4003         JC      $+5
   \   0001E7   02....       LJMP    ??CrossCallReturnLabel_2 & 0xFFFF
   \   0001EA   85..82       MOV     DPL,?V14
   \   0001ED   85..83       MOV     DPH,?V15
   \   0001F0   748D         MOV     A,#-0x73
   \   0001F2   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   4546          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V2
   \   000004   85..83       MOV     DPH,?V3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   00000D   E8           MOV     A,R0
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   E9           MOV     A,R1
   \   000011   F0           MOVX    @DPTR,A
   \   000012   0E           INC     R6
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine137:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine180_0
   \   000001                ; // Fall through to label ??Subroutine180_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FE           MOV     R6,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FF           MOV     R7,A
   \   00000B                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00000B                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00000B   85..82       MOV     DPL,?V4
   \   00000E   85..83       MOV     DPH,?V5
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   8A82         MOV     DPL,R2
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_446:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_449:
   \   000007   EE           MOV     A,R6
   \   000008   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_438:
   \   00000B   3F           ADDC    A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   EE           MOV     A,R6
   \   00000E   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000011   3F           ADDC    A,R7
   \   000012   F583         MOV     DPH,A
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   22           RET
   4547          
   4548          /*********************************************************************
   4549           * @fn      zclRevertWriteUndividedCmd
   4550           *
   4551           * @brief   Revert the "Profile" Write Undevided Command
   4552           *
   4553           * @param   pInMsg - incoming message to process
   4554           * @param   curWriteRec - old data
   4555           * @param   numAttr - number of attributes to be reverted
   4556           *
   4557           * @return  none
   4558           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4559          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4560                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4561          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V10,R4
   \   000010   8D..         MOV     ?V11,R5
   4562            uint8 i;
   4563          
   4564            for ( i = 0; i < numAttr; i++ )
   \   000012   75..00       MOV     ?V0,#0x0
   \   000015   741C         MOV     A,#0x1c
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00001D   8030         SJMP    ??zclRevertWriteUndividedCmd_0
   4565            {
   4566              zclAttrRec_t attrRec;
   4567              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4568          
   4569              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4570                                    statusRec->attrID, &attrRec ) )
   4571              {
   4572                break; // should never happen
   4573              }
   4574          
   4575              if ( attrRec.attr.dataPtr != NULL )
   4576              {
   4577                // Just copy the old data back - no need to validate the data
   4578                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4579                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4580              }
   4581              else // Use CB
   4582              {
   4583                // Write the old data back
   4584                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4585                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_1:
   \   00001F   85..82       MOV     DPL,?V2
   \   000022   85..83       MOV     DPH,?V3
   \   000025   12....       LCALL   ?Subroutine94 & 0xFFFF
   4586              }
   \                     ??CrossCallReturnLabel_164:
   \   000028                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000028   8A..         MOV     ?V4,R2
   \   00002A   8B..         MOV     ?V5,R3
   \   00002C   78..         MOV     R0,#?V4
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP102_8
   \   000036   EE           MOV     A,R6
   \   000037   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_436:
   \   00003A   3F           ADDC    A,R7
   \   00003B   FB           MOV     R3,A
   \   00003C   EE           MOV     A,R6
   \   00003D   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000040   3F           ADDC    A,R7
   \   000041   F583         MOV     DPH,A
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclRevertWriteUndividedCmd_2:
   \   00004D   05..         INC     ?V0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00004F   C3           CLR     C
   \   000050   E5..         MOV     A,?V0
   \   000052   95..         SUBB    A,?V8
   \   000054   E4           CLR     A
   \   000055   95..         SUBB    A,?V9
   \   000057   4003         JC      $+5
   \   000059   02....       LJMP    ??zclRevertWriteUndividedCmd_3 & 0xFFFF
   \   00005C   E5..         MOV     A,?V0
   \   00005E   75F005       MOV     B,#0x5
   \   000061   A4           MUL     AB
   \   000062   F8           MOV     R0,A
   \   000063   A9F0         MOV     R1,B
   \   000065   E5..         MOV     A,?V10
   \   000067   28           ADD     A,R0
   \   000068   FE           MOV     R6,A
   \   000069   E5..         MOV     A,?V11
   \   00006B   39           ADDC    A,R1
   \   00006C   FF           MOV     R7,A
   \   00006D   85..82       MOV     DPL,?V2
   \   000070   85..83       MOV     DPH,?V3
   \   000073   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_405:
   \   000076   88..         MOV     ?V4,R0
   \   000078   89..         MOV     ?V5,R1
   \   00007A                ; Setup parameters for call to function zclFindAttrRec
   \   00007A   A8..         MOV     R0,?XSP + 0
   \   00007C   A9..         MOV     R1,?XSP + 1
   \   00007E   88..         MOV     ?V6,R0
   \   000080   89..         MOV     ?V7,R1
   \   000082   78..         MOV     R0,#?V6
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   8E82         MOV     DPL,R6
   \   000089   8F83         MOV     DPH,R7
   \   00008B   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_430:
   \   00008E   85..82       MOV     DPL,?V4
   \   000091   85..83       MOV     DPH,?V5
   \   000094   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_384:
   \   000097   E5..         MOV     A,?V4
   \   000099   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   00009C   35..         ADDC    A,?V5
   \   00009E   F583         MOV     DPH,A
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   F9           MOV     R1,A
   \   0000A2   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000A5   7402         MOV     A,#0x2
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   6045         JZ      ??zclRevertWriteUndividedCmd_3
   \   0000AD   EE           MOV     A,R6
   \   0000AE   2403         ADD     A,#0x3
   \   0000B0   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   0000B3   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_380:
   \   0000B6   7406         MOV     A,#0x6
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   0000BE   EE           MOV     A,R6
   \   0000BF   4F           ORL     A,R7
   \   0000C0   7003         JNZ     $+5
   \   0000C2   02....       LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   \   0000C5                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000C5   7404         MOV     A,#0x4
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   F9           MOV     R1,A
   \   0000CC   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000CF   8A..         MOV     ?V6,R2
   \   0000D1   8B..         MOV     ?V7,R3
   \   0000D3   AC..         MOV     R4,?V6
   \   0000D5   AD..         MOV     R5,?V7
   \   0000D7                ; Setup parameters for call to function osal_memcpy
   \   0000D7   85..82       MOV     DPL,?V4
   \   0000DA   85..83       MOV     DPH,?V5
   \   0000DD   12....       LCALL   ?Subroutine47 & 0xFFFF
   4587            } // for loop
   \                     ??CrossCallReturnLabel_62:
   \   0000E0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E3   EE           MOV     A,R6
   \   0000E4   FA           MOV     R2,A
   \   0000E5   EF           MOV     A,R7
   \   0000E6   FB           MOV     R3,A
   \   0000E7   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000EA   7403         MOV     A,#0x3
   \   0000EC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EF   02....       LJMP    ??zclRevertWriteUndividedCmd_2 & 0xFFFF
   4588          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   0000F2   7408         MOV     A,#0x8
   \   0000F4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F7   02....       LJMP    ??Subroutine150_0 & 0xFFFF
   4589          
   4590          /*********************************************************************
   4591           * @fn      zclProcessInWriteUndividedCmd
   4592           *
   4593           * @brief   Process the "Profile" Write Undivided Command
   4594           *
   4595           * @param   pInMsg - incoming message to process
   4596           *
   4597           * @return  TRUE if command processed. FALSE, otherwise.
   4598           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine170_0
   \   000006                ; // Fall through to label ??Subroutine170_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4599          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4600          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4601            zclWriteCmd_t *writeCmd;
   4602            zclWriteRspCmd_t *writeRspCmd;
   4603            zclAttrRec_t attrRec;
   4604            uint16 dataLen;
   4605            uint16 curLen = 0;
   \   00000E   75..00       MOV     ?V8,#0x0
   \   000011   75..00       MOV     ?V9,#0x0
   4606            uint8 j = 0;
   \   000014   12....       LCALL   ?Subroutine83 & 0xFFFF
   4607            uint8 i;
   4608          
   4609            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_400:
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   4610          
   4611            // Allocate space for Write Response Command
   4612            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4613                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_260:
   \   00001F                ; Setup parameters for call to function osal_mem_alloc
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000027   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   4614            if ( writeRspCmd == NULL )
   \   00002E   EA           MOV     A,R2
   \   00002F   45..         ORL     A,?V1
   \   000031   7003         JNZ     $+5
   \   000033   02....       LJMP    ??zclProcessInWriteUndividedCmd_0 & 0xFFFF
   4615            {
   4616              return FALSE; // EMBEDDED RETURN
   4617            }
   4618          
   4619            // If any attribute cannot be written, no attribute values are changed. Hence,
   4620            // make sure all the attributes are supported and writable
   4621            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000036   7F00         MOV     R7,#0x0
   \   000038   803D         SJMP    ??zclProcessInWriteUndividedCmd_1
   4622            {
   4623              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4624          
   4625              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4626                                    statusRec->attrID, &attrRec ) )
   4627              {
   4628                // Attribute is not supported - stop here
   4629                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4630                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4631                break;
   4632              }
   4633          
   4634              if ( statusRec->dataType != attrRec.attr.dataType )
   4635              {
   4636                // Attribute data type is incorrect - stope here
   4637                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4638                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4639                break;
   4640              }
   4641          
   4642              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4643              {
   4644                // Attribute is not writable - stop here
   4645                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4646                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4647                break;
   4648              }
   4649          
   4650              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4651              {
   4652                // Not authorized to write - stop here
   4653                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4654                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4655                break;
   4656              }
   4657          
   4658              // Attribute Data length
   4659              if ( attrRec.attr.dataPtr != NULL )
   4660              {
   4661                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4662              }
   4663              else // Use CB
   4664              {
   4665                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4666                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   00003A   85..82       MOV     DPL,?V4
   \   00003D   85..83       MOV     DPH,?V5
   \   000040   12....       LCALL   ?Subroutine63 & 0xFFFF
   4667              }
   \                     ??CrossCallReturnLabel_104:
   \   000043   FC           MOV     R4,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   FD           MOV     R5,A
   \   000047   8882         MOV     DPL,R0
   \   000049   8983         MOV     DPH,R1
   \   00004B   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_385:
   \   00004E   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000051   12....       LCALL   `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   000054   12....       LCALL   ?Subroutine29 & 0xFFFF
   4668          
   4669              // add padding if needed
   4670              if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_332:
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000060   5003         JNC     ??CrossCallReturnLabel_197
   4671              {
   4672                dataLen++;
   \   000062   12....       LCALL   ?Subroutine109 & 0xFFFF
   4673              }
   4674          
   4675              curLen += dataLen;
   \                     ??CrossCallReturnLabel_197:
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   25..         ADD     A,?V8
   \   00006E   F5..         MOV     ?V8,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   35..         ADDC    A,?V9
   \   000074   F5..         MOV     ?V9,A
   \   000076   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000077   7402         MOV     A,#0x2
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   00007F   5048         JNC     ??zclProcessInWriteUndividedCmd_4
   \   000081   EF           MOV     A,R7
   \   000082   75F005       MOV     B,#0x5
   \   000085   A4           MUL     AB
   \   000086   F8           MOV     R0,A
   \   000087   A9F0         MOV     R1,B
   \   000089   7402         MOV     A,#0x2
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000091   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000094   12....       LCALL   ?XSTACK_DISP100_8
   \   000097   88..         MOV     ?V10,R0
   \   000099   89..         MOV     ?V11,R1
   \   00009B   78..         MOV     R0,#?V10
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A0   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   0000A3   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AB   E9           MOV     A,R1
   \   0000AC   704C         JNZ     ??zclProcessInWriteUndividedCmd_5
   \   0000AE   85..82       MOV     DPL,?V0
   \   0000B1   85..83       MOV     DPH,?V1
   \   0000B4   A3           INC     DPTR
   \   0000B5   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   0000B7   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0000BA   F8           MOV     R0,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   85..82       MOV     DPL,?V0
   \   0000C1   85..83       MOV     DPH,?V1
   \   0000C4   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   0000C7   7E01         MOV     R6,#0x1
   4676            } // for loop
   4677          
   4678            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   0000C9   EE           MOV     A,R6
   \   0000CA   85..82       MOV     DPL,?V0
   \   0000CD   85..83       MOV     DPH,?V1
   \   0000D0   F0           MOVX    @DPTR,A
   4679            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000D1   6003         JZ      $+5
   \   0000D3   02....       LJMP    ??zclProcessInWriteUndividedCmd_7 & 0xFFFF
   4680            {
   4681              uint8 *curDataPtr;
   4682              zclWriteRec_t *curWriteRec;
   4683          
   4684              // calculate the length of the current data header
   4685              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   0000D6   75F005       MOV     B,#0x5
   \   0000D9   A4           MUL     AB
   \   0000DA   FF           MOV     R7,A
   4686          
   4687              // Allocate space to keep a copy of the current data
   4688              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   0000DB                ; Setup parameters for call to function osal_mem_alloc
   \   0000DB   25..         ADD     A,?V8
   \   0000DD   FA           MOV     R2,A
   \   0000DE   E4           CLR     A
   \   0000DF   35..         ADDC    A,?V9
   \   0000E1   FB           MOV     R3,A
   \   0000E2   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000E5   8A..         MOV     ?V14,R2
   \   0000E7   8B..         MOV     ?V15,R3
   4689              if ( curWriteRec == NULL )
   \   0000E9   EA           MOV     A,R2
   \   0000EA   45..         ORL     A,?V15
   \   0000EC   705C         JNZ     ??zclProcessInWriteUndividedCmd_8
   4690              {
   4691                zcl_mem_free(writeRspCmd );
   \   0000EE                ; Setup parameters for call to function osal_mem_free
   \   0000EE   AA..         MOV     R2,?V0
   \   0000F0   AB..         MOV     R3,?V1
   \   0000F2   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4692                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   0000F5   7900         MOV     R1,#0x0
   \   0000F7   02....       LJMP    ??zclProcessInWriteUndividedCmd_9 & 0xFFFF
   4693              }
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   0000FA   7408         MOV     A,#0x8
   \   0000FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FF   12....       LCALL   ??Subroutine181_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_441:
   \   000102   A3           INC     DPTR
   \   000103   A3           INC     DPTR
   \   000104   E0           MOVX    A,@DPTR
   \   000105   69           XRL     A,R1
   \   000106   600B         JZ      ??zclProcessInWriteUndividedCmd_10
   \   000108   85..82       MOV     DPL,?V0
   \   00010B   85..83       MOV     DPH,?V1
   \   00010E   A3           INC     DPTR
   \   00010F   748D         MOV     A,#-0x73
   \   000111   80A4         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   000113   7409         MOV     A,#0x9
   \   000115   12....       LCALL   ?XSTACK_DISP0_8
   \   000118   E0           MOVX    A,@DPTR
   \   000119   A2E1         MOV     C,0xE0 /* A   */.1
   \   00011B   400B         JC      ??zclProcessInWriteUndividedCmd_11
   \   00011D   85..82       MOV     DPL,?V0
   \   000120   85..83       MOV     DPH,?V1
   \   000123   A3           INC     DPTR
   \   000124   7488         MOV     A,#-0x78
   \   000126   808F         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000128   A2E5         MOV     C,0xE0 /* A   */.5
   \   00012A   500B         JNC     ??zclProcessInWriteUndividedCmd_12
   \   00012C   85..82       MOV     DPL,?V0
   \   00012F   85..83       MOV     DPH,?V1
   \   000132   A3           INC     DPTR
   \   000133   747E         MOV     A,#0x7e
   \   000135   8080         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   000137   740A         MOV     A,#0xa
   \   000139   12....       LCALL   ?XSTACK_DISP0_8
   \   00013C   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   00013F   7003         JNZ     $+5
   \   000141   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   \   000144                ; Setup parameters for call to function zclGetAttrDataLength
   \   000144   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000147   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4694          
   4695              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   00014A   EA           MOV     A,R2
   \   00014B   2F           ADD     A,R7
   \   00014C   F5..         MOV     ?V8,A
   \   00014E   E4           CLR     A
   \   00014F   3B           ADDC    A,R3
   \   000150   F5..         MOV     ?V9,A
   4696          
   4697              // Write the new data over
   4698              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000152   7F00         MOV     R7,#0x0
   \   000154   8022         SJMP    ??zclProcessInWriteUndividedCmd_13
   4699              {
   4700                uint8 status;
   4701                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4702                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4703          
   4704                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4705                                      statusRec->attrID, &attrRec ) )
   4706                {
   4707                  break; // should never happen
   4708                }
   4709          
   4710                // Keep a copy of the current data before before writing the new data over
   4711                curStatusRec->attrID = statusRec->attrID;
   4712                curStatusRec->attrData = curDataPtr;
   4713          
   4714                if ( attrRec.attr.dataPtr != NULL )
   4715                {
   4716                  // Read the current value
   4717                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4718          
   4719                  // Write the new attribute value
   4720                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4721                                             &attrRec, statusRec );
   4722                }
   4723                else // Use CBs
   4724                {
   4725                  // Read the current value
   4726                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4727                                          statusRec->attrID, curDataPtr, &dataLen );
   4728                  // Write the new attribute value
   4729                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4730                                                    &attrRec, statusRec->attrData );
   4731                }
   4732          
   4733                // If successful, a write attribute status record shall NOT be generated
   4734                if ( status != ZCL_STATUS_SUCCESS )
   4735                {
   4736                  writeRspCmd->attrList[j].status = status;
   4737                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4738          
   4739                  // Since this write failed, we need to revert all the pervious writes
   4740                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4741                  break;
   4742                }
   4743          
   4744                // add padding if needed
   4745                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000156   85..82       MOV     DPL,?XSP + 0
   \   000159   85..83       MOV     DPH,?XSP + 1
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00015F   5003         JNC     ??CrossCallReturnLabel_198
   4746                {
   4747                  dataLen++;
   \   000161   12....       LCALL   ?Subroutine109 & 0xFFFF
   4748                }
   4749          
   4750                curDataPtr += dataLen;
   \                     ??CrossCallReturnLabel_198:
   \   000164   85..82       MOV     DPL,?XSP + 0
   \   000167   85..83       MOV     DPH,?XSP + 1
   \   00016A   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_406:
   \   00016D   E5..         MOV     A,?V8
   \   00016F   28           ADD     A,R0
   \   000170   F5..         MOV     ?V8,A
   \   000172   E5..         MOV     A,?V9
   \   000174   39           ADDC    A,R1
   \   000175   F5..         MOV     ?V9,A
   \   000177   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   000178   7402         MOV     A,#0x2
   \   00017A   12....       LCALL   ?XSTACK_DISP0_8
   \   00017D   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000180   4003         JC      $+5
   \   000182   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   000185   EF           MOV     A,R7
   \   000186   75F005       MOV     B,#0x5
   \   000189   A4           MUL     AB
   \   00018A   F8           MOV     R0,A
   \   00018B   A9F0         MOV     R1,B
   \   00018D   7402         MOV     A,#0x2
   \   00018F   12....       LCALL   ?XSTACK_DISP0_8
   \   000192   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000195   E5..         MOV     A,?V14
   \   000197   28           ADD     A,R0
   \   000198   F5..         MOV     ?V12,A
   \   00019A   E5..         MOV     A,?V15
   \   00019C   39           ADDC    A,R1
   \   00019D   F5..         MOV     ?V13,A
   \   00019F   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   0001A2   12....       LCALL   ?XSTACK_DISP100_8
   \   0001A5   88..         MOV     ?V10,R0
   \   0001A7   89..         MOV     ?V11,R1
   \   0001A9   78..         MOV     R0,#?V10
   \   0001AB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001AE   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   0001B1   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0001B4   7402         MOV     A,#0x2
   \   0001B6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B9   E9           MOV     A,R1
   \   0001BA   7003         JNZ     $+5
   \   0001BC   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   0001BF   85..82       MOV     DPL,?V2
   \   0001C2   85..83       MOV     DPH,?V3
   \   0001C5   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_407:
   \   0001C8   85..82       MOV     DPL,?V12
   \   0001CB   85..83       MOV     DPH,?V13
   \   0001CE   E8           MOV     A,R0
   \   0001CF   F0           MOVX    @DPTR,A
   \   0001D0   A3           INC     DPTR
   \   0001D1   E9           MOV     A,R1
   \   0001D2   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   0001D5   E5..         MOV     A,?V8
   \   0001D7   F0           MOVX    @DPTR,A
   \   0001D8   A3           INC     DPTR
   \   0001D9   E5..         MOV     A,?V9
   \   0001DB   F0           MOVX    @DPTR,A
   \   0001DC   740A         MOV     A,#0xa
   \   0001DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E1   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_354:
   \   0001E4   6043         JZ      ??zclProcessInWriteUndividedCmd_16
   \   0001E6                ; Setup parameters for call to function zclReadAttrData
   \   0001E6   A8..         MOV     R0,?XSP + 0
   \   0001E8   A9..         MOV     R1,?XSP + 1
   \   0001EA   88..         MOV     ?V6,R0
   \   0001EC   89..         MOV     ?V7,R1
   \   0001EE   78..         MOV     R0,#?V6
   \   0001F0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001F3   7406         MOV     A,#0x6
   \   0001F5   12....       LCALL   ?XSTACK_DISP102_8
   \   0001F8   AA..         MOV     R2,?V8
   \   0001FA   AB..         MOV     R3,?V9
   \   0001FC   12....       LCALL   `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   0001FF   7402         MOV     A,#0x2
   \   000201   12....       LCALL   ?DEALLOC_XSTACK8
   \   000204   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_364:
   \   000207                ; Setup parameters for call to function zclWriteAttrData
   \   000207   78..         MOV     R0,#?V2
   \   000209   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00020C   7406         MOV     A,#0x6
   \   00020E   12....       LCALL   ?XSTACK_DISP102_8
   \   000211   E5..         MOV     A,?V6
   \   000213   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_437:
   \   000216   35..         ADDC    A,?V7
   \   000218   FB           MOV     R3,A
   \   000219   E5..         MOV     A,?V6
   \   00021B   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   00021E   35..         ADDC    A,?V7
   \   000220   F583         MOV     DPH,A
   \   000222   E0           MOVX    A,@DPTR
   \   000223   F9           MOV     R1,A
   \   000224   12....       LCALL   `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   000227   803F         SJMP    ??zclProcessInWriteUndividedCmd_17
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   000229   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_365:
   \   00022C                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   00022C   A8..         MOV     R0,?XSP + 0
   \   00022E   A9..         MOV     R1,?XSP + 1
   \   000230   88..         MOV     ?V10,R0
   \   000232   89..         MOV     ?V11,R1
   \   000234   78..         MOV     R0,#?V10
   \   000236   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000239   78..         MOV     R0,#?V8
   \   00023B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00023E   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000241   12....       LCALL   `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   000244   7404         MOV     A,#0x4
   \   000246   12....       LCALL   ?DEALLOC_XSTACK8
   \   000249   85..82       MOV     DPL,?V4
   \   00024C   85..83       MOV     DPH,?V5
   \   00024F   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000252   A3           INC     DPTR
   \   000253   A3           INC     DPTR
   \   000254   A3           INC     DPTR
   \   000255   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000258   7406         MOV     A,#0x6
   \   00025A   12....       LCALL   ?XSTACK_DISP102_8
   \   00025D   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_440:
   \   000260   39           ADDC    A,R1
   \   000261   FB           MOV     R3,A
   \   000262   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000265   12....       LCALL   `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000268   7402         MOV     A,#0x2
   \   00026A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00026D   E9           MOV     A,R1
   \   00026E   FA           MOV     R2,A
   \   00026F   EA           MOV     A,R2
   \   000270   7003         JNZ     $+5
   \   000272   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   000275   EE           MOV     A,R6
   \   000276   75F003       MOV     B,#0x3
   \   000279   A4           MUL     AB
   \   00027A   F8           MOV     R0,A
   \   00027B   A9F0         MOV     R1,B
   \   00027D   E5..         MOV     A,?V0
   \   00027F   28           ADD     A,R0
   \   000280   F8           MOV     R0,A
   \   000281   E5..         MOV     A,?V1
   \   000283   39           ADDC    A,R1
   \   000284   F9           MOV     R1,A
   \   000285   EA           MOV     A,R2
   \   000286   8882         MOV     DPL,R0
   \   000288   8983         MOV     DPH,R1
   \   00028A   A3           INC     DPTR
   \   00028B   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00028E   FA           MOV     R2,A
   \   00028F   A3           INC     DPTR
   \   000290   E0           MOVX    A,@DPTR
   \   000291   FB           MOV     R3,A
   \   000292   8882         MOV     DPL,R0
   \   000294   8983         MOV     DPH,R1
   \   000296   A3           INC     DPTR
   \   000297   A3           INC     DPTR
   \   000298   12....       LCALL   ??Subroutine160_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   00029B   0E           INC     R6
   \   00029C                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   00029C   8F..         MOV     ?V2,R7
   \   00029E   75..00       MOV     ?V3,#0x0
   \   0002A1   78..         MOV     R0,#?V2
   \   0002A3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002A6   AC..         MOV     R4,?V14
   \   0002A8   AD..         MOV     R5,?V15
   \   0002AA   AA..         MOV     R2,?V4
   \   0002AC   AB..         MOV     R3,?V5
   \   0002AE   12....       LCALL   `??zclRevertWriteUndividedCmd::?relay`; Banked call to: zclRevertWriteUndividedCmd
   \   0002B1   7402         MOV     A,#0x2
   \   0002B3   12....       LCALL   ?DEALLOC_XSTACK8
   4751              } // for loop
   4752          
   4753              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0002B6   EE           MOV     A,R6
   \   0002B7   85..82       MOV     DPL,?V0
   \   0002BA   85..83       MOV     DPH,?V1
   \   0002BD   F0           MOVX    @DPTR,A
   4754              if ( writeRspCmd->numAttr  == 0 )
   \   0002BE   700B         JNZ     ??zclProcessInWriteUndividedCmd_18
   4755              {
   4756                // Since all records were written successful, include a single status record
   4757                // in the resonse command with the status field set to SUCCESS and the
   4758                // attribute ID field omitted.
   4759                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0002C0   A3           INC     DPTR
   \   0002C1   E4           CLR     A
   \   0002C2   F0           MOVX    @DPTR,A
   4760                writeRspCmd->numAttr = 1;
   \   0002C3   85..82       MOV     DPL,?V0
   \   0002C6   85..83       MOV     DPH,?V1
   \   0002C9   04           INC     A
   \   0002CA   F0           MOVX    @DPTR,A
   4761              }
   4762          
   4763              zcl_mem_free( curWriteRec );
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   0002CB                ; Setup parameters for call to function osal_mem_free
   \   0002CB   AA..         MOV     R2,?V14
   \   0002CD   AB..         MOV     R3,?V15
   \   0002CF   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4764            }
   4765          
   4766            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4767                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4768                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0002D2   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   0002D5   A3           INC     DPTR
   \   0002D6   A3           INC     DPTR
   \   0002D7   A3           INC     DPTR
   \   0002D8   A3           INC     DPTR
   \   0002D9   A3           INC     DPTR
   \   0002DA   A3           INC     DPTR
   \   0002DB   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   0002DE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002E1   75..01       MOV     ?V2,#0x1
   \   0002E4   78..         MOV     R0,#?V2
   \   0002E6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002E9   85..82       MOV     DPL,?V4
   \   0002EC   85..83       MOV     DPH,?V5
   \   0002EF   A3           INC     DPTR
   \   0002F0   A3           INC     DPTR
   \   0002F1   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   0002F4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002F7   78..         MOV     R0,#?V0
   \   0002F9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002FC   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0002FF   12....       LCALL   `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   000302   7405         MOV     A,#0x5
   \   000304   12....       LCALL   ?DEALLOC_XSTACK8
   4769            zcl_mem_free( writeRspCmd );
   \   000307                ; Setup parameters for call to function osal_mem_free
   \   000307   AA..         MOV     R2,?V0
   \   000309   AB..         MOV     R3,?V1
   \   00030B   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4770          
   4771            return TRUE;
   \   00030E   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   000310   740C         MOV     A,#0xc
   \   000312   02....       LJMP    ?Subroutine5 & 0xFFFF
   4772          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   2401         ADD     A,#0x1
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3400         ADDC    A,#0x0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   E8           MOV     A,R0
   \   000001   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000004   39           ADDC    A,R1
   \   000005   F583         MOV     DPH,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V6,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F5..         MOV     ?V7,A
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D   7404         MOV     A,#0x4
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000003   EF           MOV     A,R7
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000003   8582..       MOV     ?V2,DPL
   \   000006   8583..       MOV     ?V3,DPH
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_447:
   \   000009   85..82       MOV     DPL,?V6
   \   00000C   85..83       MOV     DPH,?V7
   \   00000F   A3           INC     DPTR
   \   000010   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_390:
   \   000013   E5..         MOV     A,?V6
   \   000015   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000018   35..         ADDC    A,?V7
   \   00001A   F583         MOV     DPH,A
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F9           MOV     R1,A
   \   00001E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_event_loop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsgExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsgExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_addExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_addExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_HandleExternal::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getRawAFMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getParsedTransSeqNum::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerPlugin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerAttrList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerClusterOptionList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerValidateAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_DeviceOperational::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendCommand::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendRead::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRequest::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendConfigReportRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadReportCfgRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ProcessMessageMSG::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclBuildHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRecsList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAuthorizeCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAuthorizeCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSetSecurityOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSerializeData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclAnalogDataType::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAnalogDataType

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetDataTypeLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLengthUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLengthUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclAuthorizeWrite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInConfigReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadReportCfgCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclRevertWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclRevertWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd
   4773          #endif // ZCL_WRITE
   4774          
   4775          #ifdef ZCL_DISCOVER
   4776          /*********************************************************************
   4777           * @fn      zclProcessInDiscAttrs
   4778           *
   4779           * @brief   Process the "Profile" Discover Attributes Commands
   4780           *
   4781           * @param   pInMsg - incoming message to process
   4782           *
   4783           * @return  TRUE if command processed. FALSE, otherwise.
   4784           */
   4785          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   4786          {
   4787            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4788            zclAttrRec_t attrRec;
   4789            uint16 attrID;
   4790            uint8 numAttrs;
   4791            uint8 i;
   4792          
   4793            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   4794          
   4795            // Find out the number of attributes supported within the specified range
   4796            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   4797            {
   4798              // finds the next attribute on this endpoint/cluster after the range.
   4799              // attributes must be in numerical order in the list.
   4800              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4801              {
   4802                break;
   4803              }
   4804            }
   4805          
   4806            numAttrs = i;  // store range of attributes in buffer
   4807          
   4808              // Process message for either attributes or extended attributes
   4809            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   4810            {
   4811              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   4812            }
   4813            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   4814            {
   4815              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   4816            }
   4817          
   4818            return TRUE;
   4819          }
   4820          
   4821          /*********************************************************************
   4822           * @fn      zclProcessInDiscAttrsCmd
   4823           *
   4824           * @brief   Process the Discover Attributes Command
   4825           *
   4826           * @param   pInMsg - incoming message to process
   4827           *
   4828           * @param   pDiscoverCmd - structure from requesting command
   4829           *
   4830           * @param   attrLenBuf - describes the amount of attributes to be processed
   4831           *
   4832           * @return  none
   4833           */
   4834          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4835          {
   4836            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4837            uint8 discComplete = TRUE;
   4838            zclAttrRec_t attrRec;
   4839            uint16 attrID;
   4840            uint8 i;
   4841          
   4842            // Allocate space for the response command
   4843            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4844                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4845            if ( pDiscoverRsp == NULL )
   4846            {
   4847              return; // EMBEDDED RETURN
   4848            }
   4849          
   4850            if ( numAttrs != 0 )
   4851            {
   4852              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4853              {
   4854                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4855                {
   4856                  break; // should not happen, as numAttrs already calculated
   4857                }
   4858          
   4859                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4860                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4861              }
   4862          
   4863              // Are there more attributes to be discovered?
   4864              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4865              {
   4866                discComplete = FALSE;
   4867              }
   4868            }
   4869          
   4870            pDiscoverRsp->discComplete = discComplete;
   4871            pDiscoverRsp->numAttr = numAttrs;
   4872          
   4873            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4874                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4875                                         true, pInMsg->hdr.transSeqNum );
   4876            zcl_mem_free( pDiscoverRsp );
   4877          
   4878            return;
   4879          }
   4880          
   4881          /*********************************************************************
   4882           * @fn      zclProcessInDiscAttrsExtCmd
   4883           *
   4884           * @brief   Process the Discover Attributes Extended Command
   4885           *
   4886           * @param   pInMsg - incoming message to process
   4887           *
   4888           * @param   pDiscoverCmd - structure from requesting command
   4889           *
   4890           * @param   attrLenBuf - describes the amount of attributes to be processed
   4891           *
   4892           * @return  none
   4893           */
   4894          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4895          {
   4896            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4897            uint8 discComplete = TRUE;
   4898            zclAttrRec_t attrRec;
   4899            uint16 attrID;
   4900            uint8 i;
   4901          
   4902              // Allocate space for the response command
   4903            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4904                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   4905            if ( pDiscoverExtRsp == NULL )
   4906            {
   4907              return; // EMBEDDED RETURN
   4908            }
   4909          
   4910          
   4911            if ( numAttrs != 0 )
   4912            {
   4913              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4914              {
   4915                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4916                {
   4917                  break; // Should not happen, as numAttrs already calculated
   4918                }
   4919          
   4920                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   4921                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   4922                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   4923              }
   4924          
   4925              // Are there more attributes to be discovered?
   4926              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4927              {
   4928                discComplete = FALSE;
   4929              }
   4930            }
   4931          
   4932            pDiscoverExtRsp->discComplete = discComplete;
   4933            pDiscoverExtRsp->numAttr = numAttrs;
   4934          
   4935            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4936                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   4937                                         true, pInMsg->hdr.transSeqNum );
   4938          
   4939            zcl_mem_free( pDiscoverExtRsp );
   4940          
   4941            return;
   4942          }
   4943          
   4944          /*********************************************************************
   4945           * @fn      zclProcessInDiscCmd
   4946           *
   4947           * @brief   Process the "Profile" Discover Command
   4948           *
   4949           * @param   pInMsg - incoming message to process
   4950           *
   4951           * @return  TRUE if command processed. FALSE, otherwise.
   4952           */
   4953          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   4954          {
   4955            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4956            zclDiscoverCmdsCmdRsp_t cmdRsp;
   4957            ZStatus_t status;
   4958            zclCommandRec_t cmdRec;
   4959            uint8 cmdID;
   4960            uint8 i;
   4961            uint8 j;
   4962          
   4963            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   4964          
   4965            // Find out the number of commands supported within the specified range
   4966            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   4967            {
   4968              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4969              {
   4970                break;  // Command not supported
   4971              }
   4972            }
   4973          
   4974            // Allocate space for the response command
   4975            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   4976          
   4977            if ( cmdRsp.pCmdID == NULL )
   4978            {
   4979              return FALSE; // EMBEDDED RETURN
   4980            }
   4981          
   4982            if ( i != 0 )
   4983            {
   4984              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   4985              {
   4986                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4987                {
   4988                  break; // Attribute not supported
   4989                }
   4990          
   4991                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   4992              }
   4993            }
   4994          
   4995            // Are there more commands to be discovered?
   4996            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4997            {
   4998              cmdRsp.discComplete = FALSE;
   4999            }
   5000            else
   5001            {
   5002              cmdRsp.discComplete = TRUE;
   5003            }
   5004          
   5005            // pass the command requested
   5006            cmdRsp.cmdType = pInMsg->hdr.commandID;
   5007          
   5008            // store number of commands returned
   5009            cmdRsp.numCmd = j;
   5010          
   5011            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   5012                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   5013                                                true, pInMsg->hdr.transSeqNum );
   5014          
   5015            zcl_mem_free( cmdRsp.pCmdID );
   5016          
   5017            if ( status == ZSuccess )
   5018            {
   5019              return TRUE;
   5020            }
   5021            else
   5022            {
   5023              return FALSE;
   5024            }
   5025          }
   5026          
   5027          #endif // ZCL_DISCOVER
   5028          
   5029          
   5030          /*********************************************************************
   5031          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     26   zclAnalogDataType
      0     29   zclAuthorizeWrite
        0     14   -> zclGetAuthorizeCB
      1     39   zclBuildHdr
      2     54   zclFindAttrRec
        0     16   -> zclFindAttrRecsList
      2     16   zclFindAttrRecsList
      0     20   zclFindClusterOption
      0     45   zclGetAttrDataLength
        0      9   -> zclGetDataTypeLength
      0     58   zclGetAttrDataLengthUsingCB
        0     18   -> zclGetReadWriteCB
      0     42   zclGetAuthorizeCB
        0     10   -> zclFindAttrRecsList
      0     47   zclGetClusterOption
        0     10   -> zclFindClusterOption
      0     26   zclGetDataTypeLength
      0     28   zclGetReadWriteCB
        0     10   -> zclFindAttrRecsList
      1     49   zclParseHdr
        0     12   -> osal_memset
      1     24   zclParseInConfigReportCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_memset
        0     24   -> zclAnalogDataType
        0     24   -> zclGetAttrDataLength
        0     24   -> zclGetDataTypeLength
      1     10   zclParseInDefaultRspCmd
        0     10   -> osal_mem_alloc
      1     12   zclParseInReadCmd
        0     12   -> osal_mem_alloc
      1     12   zclParseInReadReportCfgCmd
        0     12   -> osal_mem_alloc
      1     25   zclParseInReadRspCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInWriteCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     16   zclParseInWriteRspCmd
        0     16   -> osal_mem_alloc
      1     37   zclProcessInReadCmd
        0     32   -> osal_mem_alloc
        0     32   -> osal_mem_free
        0     34   -> zclFindAttrRec
        0     32   -> zclGetAuthorizeCB
        0     37   -> zcl_SendReadRsp
      1     39   zclProcessInWriteCmd
        0     34   -> osal_mem_alloc
        0     34   -> osal_mem_free
        0     36   -> zclFindAttrRec
        0     36   -> zclWriteAttrData
        0     36   -> zclWriteAttrDataUsingCB
        0     39   -> zcl_SendWriteRsp
      1     41   zclProcessInWriteUndividedCmd
        0     36   -> osal_mem_alloc
        0     36   -> osal_mem_free
        0     38   -> zclFindAttrRec
        0     36   -> zclGetAttrDataLength
        0     36   -> zclGetAttrDataLengthUsingCB
        0     38   -> zclReadAttrData
        0     40   -> zclReadAttrDataUsingCB
        0     38   -> zclRevertWriteUndividedCmd
        0     38   -> zclWriteAttrData
        0     38   -> zclWriteAttrDataUsingCB
        0     41   -> zcl_SendWriteRsp
      0     56   zclReadAttrData
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      0     60   zclReadAttrDataUsingCB
        0     16   -> zclGetReadWriteCB
      0     69   zclRevertWriteUndividedCmd
        0     31   -> osal_memcpy
        0     30   -> zclFindAttrRec
        0     28   -> zclGetAttrDataLength
        0     30   -> zclWriteAttrDataUsingCB
      1     45   zclSerializeData
        0     19   -> osal_buffer_uint32
        0     18   -> osal_memcpy
      0     47   zclSetSecurityOption
        0     10   -> zclFindClusterOption
      0     56   zclWriteAttrData
        0     18   -> osal_memcpy
        0     15   -> zclAuthorizeWrite
        0     15   -> zclGetAttrDataLength
      0     56   zclWriteAttrDataUsingCB
        0     14   -> zclAuthorizeWrite
        0     14   -> zclGetReadWriteCB
      0     62   zcl_DeviceOperational
        0     23   -> zclFindAttrRec
        0     23   -> zclReadAttrData
      1     12   zcl_HandleExternal
        0     12   -> bdb_ProcessInConfigReportCmd
        0     12   -> bdb_ProcessInReadReportCfgCmd
        0     12   -> osal_msg_allocate
        0     12   -> osal_msg_send
        0     12   -> zcl_getExternalFoundationHandler
      2      0   zcl_Init
      1     56   zcl_ProcessMessageMSG
        0     37   -> afFindEndPointDesc
        0     37   -> osal_mem_free
        0     37   -> zclGetClusterOption
        0     37   -> zclParseHdr
        0     37   -> zclSetSecurityOption
        0     39   -> zcl_DeviceOperational
        0     44   -> zcl_SendDefaultRspCmd
      0     32   zcl_ReadAttrData
        0     26   -> zclFindAttrRec
        0     26   -> zclReadAttrData
        0     28   -> zclReadAttrDataUsingCB
      1     76   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     30   -> zclBuildHdr
        0     30   -> zclGetClusterOption
        0     32   -> zcl_DeviceOperational
      1     36   zcl_SendConfigReportRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     67   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      1     36   zcl_SendRead
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     42   zcl_SendReadReportCfgRspCmd
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     26   -> zclAnalogDataType
        0     26   -> zclGetDataTypeLength
        0     26   -> zclSerializeData
        0     37   -> zcl_SendCommand
      1     72   zcl_SendReadRsp
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclGetAttrDataLength
        0     24   -> zclGetAttrDataLengthUsingCB
        0     28   -> zclReadAttrDataUsingCB
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     38   zcl_SendReportCmd
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> zclGetAttrDataLength
        0     22   -> zclSerializeData
        0     33   -> zcl_SendCommand
      1     39   zcl_SendWriteRequest
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> zclGetAttrDataLength
        0     22   -> zclSerializeData
        0     33   -> zcl_SendCommand
      1     72   zcl_SendWriteRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     19   zcl_addExternalFoundationHandler
        0     10   -> osal_mem_alloc
      0     12   zcl_event_loop
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> osal_msg_send
        0     12   -> zcl_ProcessMessageMSG
        0     12   -> zcl_getExternalFoundationHandler
      2     12   zcl_getExternalFoundationHandler
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerAttrList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      0      9   zcl_registerForMsg
        0      9   -> zcl_addExternalFoundationHandler
      0      9   zcl_registerForMsgExt
        0      9   -> zcl_addExternalFoundationHandler
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      0     14   zcl_registerReadWriteCB
        0     14   -> zclFindAttrRecsList
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ??Subroutine144_0
       5  ??Subroutine145_0
       9  ??Subroutine146_0
       6  ??Subroutine147_0
       6  ??Subroutine148_0
       5  ??Subroutine149_0
       5  ??Subroutine150_0
       5  ??Subroutine151_0
       1  ??Subroutine152_0
       6  ??Subroutine153_0
       7  ??Subroutine154_0
       6  ??Subroutine155_0
       5  ??Subroutine156_0
       7  ??Subroutine157_0
       8  ??Subroutine158_0
       6  ??Subroutine159_0
       6  ??Subroutine160_0
       1  ??Subroutine161_0
      10  ??Subroutine162_0
       8  ??Subroutine163_0
       7  ??Subroutine164_0
       5  ??Subroutine165_0
       5  ??Subroutine166_0
       6  ??Subroutine167_0
       1  ??Subroutine168_0
       5  ??Subroutine169_0
       8  ??Subroutine170_0
       1  ??Subroutine171_0
       3  ??Subroutine172_0
       4  ??Subroutine173_0
       5  ??Subroutine174_0
       4  ??Subroutine175_0
       7  ??Subroutine176_0
       5  ??Subroutine177_0
       2  ??Subroutine178_0
       4  ??Subroutine179_0
       5  ??Subroutine180_0
       9  ??Subroutine181_0
      10  ??Subroutine182_0
       6  ??Subroutine183_0
       7  ?Subroutine0
       5  ?Subroutine1
       7  ?Subroutine10
      12  ?Subroutine100
      12  ?Subroutine101
      22  ?Subroutine102
      16  ?Subroutine103
       8  ?Subroutine104
      19  ?Subroutine105
       8  ?Subroutine106
      11  ?Subroutine107
      12  ?Subroutine108
       9  ?Subroutine109
       5  ?Subroutine11
      15  ?Subroutine110
       1  ?Subroutine111
       8  ?Subroutine112
       5  ?Subroutine113
       9  ?Subroutine114
       9  ?Subroutine115
       8  ?Subroutine116
       3  ?Subroutine117
       3  ?Subroutine118
       4  ?Subroutine119
      71  ?Subroutine12
       6  ?Subroutine120
       8  ?Subroutine121
      12  ?Subroutine122
       6  ?Subroutine123
       4  ?Subroutine124
      11  ?Subroutine125
       8  ?Subroutine126
       5  ?Subroutine127
       5  ?Subroutine128
       9  ?Subroutine129
      20  ?Subroutine13
       5  ?Subroutine130
       7  ?Subroutine131
       1  ?Subroutine132
      12  ?Subroutine133
      16  ?Subroutine134
       6  ?Subroutine135
       3  ?Subroutine136
       1  ?Subroutine137
       7  ?Subroutine138
       6  ?Subroutine139
      11  ?Subroutine14
       6  ?Subroutine140
       6  ?Subroutine141
       9  ?Subroutine142
       7  ?Subroutine143
      20  ?Subroutine15
       2  ?Subroutine16
      14  ?Subroutine17
      11  ?Subroutine18
      10  ?Subroutine19
       3  ?Subroutine2
      14  ?Subroutine20
       6  ?Subroutine21
       4  ?Subroutine22
       4  ?Subroutine23
       7  ?Subroutine24
       4  ?Subroutine25
       4  ?Subroutine26
       6  ?Subroutine27
       8  ?Subroutine28
       6  ?Subroutine29
       5  ?Subroutine3
       4  ?Subroutine30
       7  ?Subroutine31
       7  ?Subroutine32
       9  ?Subroutine33
       2  ?Subroutine34
       9  ?Subroutine35
       5  ?Subroutine36
      31  ?Subroutine37
       5  ?Subroutine38
       4  ?Subroutine39
       5  ?Subroutine4
       6  ?Subroutine40
      18  ?Subroutine41
       4  ?Subroutine42
      23  ?Subroutine43
       8  ?Subroutine44
      10  ?Subroutine45
       8  ?Subroutine46
       9  ?Subroutine47
       9  ?Subroutine48
       9  ?Subroutine49
       8  ?Subroutine5
       6  ?Subroutine50
       6  ?Subroutine51
      10  ?Subroutine52
       6  ?Subroutine53
       6  ?Subroutine54
      15  ?Subroutine55
       8  ?Subroutine56
       8  ?Subroutine57
      24  ?Subroutine58
       1  ?Subroutine59
       2  ?Subroutine6
       7  ?Subroutine60
       5  ?Subroutine61
      13  ?Subroutine62
       5  ?Subroutine63
      12  ?Subroutine64
       6  ?Subroutine65
       4  ?Subroutine66
      10  ?Subroutine67
      10  ?Subroutine68
       2  ?Subroutine69
       5  ?Subroutine7
      18  ?Subroutine70
       4  ?Subroutine71
      12  ?Subroutine72
       8  ?Subroutine73
       6  ?Subroutine74
      11  ?Subroutine75
       8  ?Subroutine76
      11  ?Subroutine77
      10  ?Subroutine78
      12  ?Subroutine79
       3  ?Subroutine8
       4  ?Subroutine80
      14  ?Subroutine81
       4  ?Subroutine82
      12  ?Subroutine83
       6  ?Subroutine84
       5  ?Subroutine85
      10  ?Subroutine86
       8  ?Subroutine87
       3  ?Subroutine88
      16  ?Subroutine89
       5  ?Subroutine9
       6  ?Subroutine90
      21  ?Subroutine91
       8  ?Subroutine92
      11  ?Subroutine93
       6  ?Subroutine94
       5  ?Subroutine95
      10  ?Subroutine96
      12  ?Subroutine97
       4  ?Subroutine98
       4  ?Subroutine99
       2  attrList
       2  clusterOptionList
       2  externalEndPointHandlerList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      33  zclAnalogDataType
       6  zclAnalogDataType::?relay
      60  zclAuthorizeWrite
       6  zclAuthorizeWrite::?relay
      99  zclBuildHdr
       6  zclBuildHdr::?relay
      92  zclCmdTable
     146  zclFindAttrRec
       6  zclFindAttrRec::?relay
      37  zclFindAttrRecsList
       6  zclFindAttrRecsList::?relay
     106  zclFindClusterOption
       6  zclFindClusterOption::?relay
      63  zclGetAttrDataLength
       6  zclGetAttrDataLength::?relay
     101  zclGetAttrDataLengthUsingCB
       6  zclGetAttrDataLengthUsingCB::?relay
      29  zclGetAuthorizeCB
       6  zclGetAuthorizeCB::?relay
      28  zclGetClusterOption
       6  zclGetClusterOption::?relay
     166  zclGetDataTypeLength
       6  zclGetDataTypeLength::?relay
      30  zclGetReadWriteCB
       6  zclGetReadWriteCB::?relay
     219  zclParseHdr
       6  zclParseHdr::?relay
     553  zclParseInConfigReportCmd
       6  zclParseInConfigReportCmd::?relay
      31  zclParseInDefaultRspCmd
       6  zclParseInDefaultRspCmd::?relay
      96  zclParseInReadCmd
       6  zclParseInReadCmd::?relay
      93  zclParseInReadReportCfgCmd
       6  zclParseInReadReportCfgCmd::?relay
     351  zclParseInReadRspCmd
       6  zclParseInReadRspCmd::?relay
     333  zclParseInWriteCmd
       6  zclParseInWriteCmd::?relay
     113  zclParseInWriteRspCmd
       6  zclParseInWriteRspCmd::?relay
     418  zclProcessInReadCmd
       6  zclProcessInReadCmd::?relay
     501  zclProcessInWriteCmd
       6  zclProcessInWriteCmd::?relay
     789  zclProcessInWriteUndividedCmd
       6  zclProcessInWriteUndividedCmd::?relay
     112  zclReadAttrData
       6  zclReadAttrData::?relay
      93  zclReadAttrDataUsingCB
       6  zclReadAttrDataUsingCB::?relay
     250  zclRevertWriteUndividedCmd
       6  zclRevertWriteUndividedCmd::?relay
     365  zclSerializeData
       6  zclSerializeData::?relay
      45  zclSetSecurityOption
       6  zclSetSecurityOption::?relay
     150  zclWriteAttrData
       6  zclWriteAttrData::?relay
     107  zclWriteAttrDataUsingCB
       6  zclWriteAttrDataUsingCB::?relay
     126  zcl_DeviceOperational
       6  zcl_DeviceOperational::?relay
     209  zcl_HandleExternal
       6  zcl_HandleExternal::?relay
       1  zcl_InSeqNum
      12  zcl_Init
       6  zcl_Init::?relay
    1071  zcl_ProcessMessageMSG
       6  zcl_ProcessMessageMSG::?relay
     131  zcl_ReadAttrData
       6  zcl_ReadAttrData::?relay
     418  zcl_SendCommand
       6  zcl_SendCommand::?relay
     245  zcl_SendConfigReportRspCmd
       6  zcl_SendConfigReportRspCmd::?relay
     135  zcl_SendDefaultRspCmd
       6  zcl_SendDefaultRspCmd::?relay
     191  zcl_SendRead
       6  zcl_SendRead::?relay
     529  zcl_SendReadReportCfgRspCmd
       6  zcl_SendReadReportCfgRspCmd::?relay
     414  zcl_SendReadRsp
       6  zcl_SendReadRsp::?relay
     217  zcl_SendReportCmd
       6  zcl_SendReportCmd::?relay
     217  zcl_SendWriteRequest
       6  zcl_SendWriteRequest::?relay
     222  zcl_SendWriteRsp
       6  zcl_SendWriteRsp::?relay
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
     139  zcl_addExternalFoundationHandler
       6  zcl_addExternalFoundationHandler::?relay
      98  zcl_event_loop
       6  zcl_event_loop::?relay
      60  zcl_getExternalFoundationHandler
       6  zcl_getExternalFoundationHandler::?relay
       9  zcl_getParsedTransSeqNum
       6  zcl_getParsedTransSeqNum::?relay
      12  zcl_getRawAFMsg
       6  zcl_getRawAFMsg::?relay
      89  zcl_registerAttrList
       6  zcl_registerAttrList::?relay
      73  zcl_registerClusterOptionList
       6  zcl_registerClusterOptionList::?relay
      10  zcl_registerForMsg
       6  zcl_registerForMsg::?relay
       8  zcl_registerForMsgExt
       6  zcl_registerForMsgExt::?relay
      98  zcl_registerPlugin
       6  zcl_registerPlugin::?relay
      55  zcl_registerReadWriteCB
       6  zcl_registerReadWriteCB::?relay
      15  zcl_registerValidateAttrData
       6  zcl_registerValidateAttrData::?relay

 
 11 797 bytes in segment BANKED_CODE
    336 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
     16 bytes in segment XDATA_Z
 
 12 225 bytes of CODE  memory
     16 bytes of XDATA memory

Errors: none
Warnings: none
