///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V9.30.1.3056 for 8051               26/Oct/2017  13:47:15
// Copyright 2004-2015 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        C:\Texas Instruments\Z-Stack
//        3.0.0\Components\stack\bdb\bdb_touchlink_initiator.c
//    Command line       =  
//        -f "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
//        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
//        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0}
//        -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
//        -DENABLE_LED4_DISABLE_S1) -f "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
//        "C:\Texas Instruments\Z-Stack
//        3.0.0\Components\stack\bdb\bdb_touchlink_initiator.c" -D
//        BDB_REPORTING -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE
//        -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D
//        xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
//        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
//        ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF -D ZCL_SCENES -D
//        ZCL_GROUPS -D xZCL_LEVEL_CTRL -lC "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List"
//        -lA "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List"
//        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\Obj"
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -I "C:\Texas
//        Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
//        "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\gp\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
//        -I "C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
//        -Ohz --require_prototypes
//    List file          =  
//        C:\Texas Instruments\Z-Stack
//        3.0.0\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List\bdb_touchlink_initiator.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME bdb_touchlink_initiator

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// C:\Texas Instruments\Z-Stack 3.0.0\Components\stack\bdb\bdb_touchlink_initiator.c
//    1 /**************************************************************************************************
//    2   Filename:       bdb_touchlink_initiator.c
//    3   Revised:        $Date: 2013-11-22 16:17:23 -0800 (Fri, 22 Nov 2013) $
//    4   Revision:       $Revision: 36220 $
//    5 
//    6   Description:    Zigbee Cluster Library - Light Link Initiator.
//    7 
//    8 
//    9   Copyright 2011-2013 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 
//   41 /*********************************************************************
//   42  * INCLUDES
//   43  */
//   44 #include "ZComDef.h"
//   45 #include "OSAL.h"
//   46 #include "OSAL_Tasks.h"
//   47 #include "OSAL_Nv.h"
//   48 #include "AF.h"
//   49 #include "ZDApp.h"
//   50 #include "ZDSecMgr.h"
//   51 #include "ZDObject.h"
//   52 #include "nwk_util.h"
//   53 #include "ZGlobals.h"
//   54 
//   55 #if defined ( POWER_SAVING )
//   56 #include "OSAL_PwrMgr.h"
//   57 #endif
//   58 
//   59 #include "stub_aps.h"
//   60 
//   61 #include "zcl.h"
//   62 #include "zcl_general.h"
//   63 #include "bdb.h"
//   64 #include "bdb_interface.h"
//   65 #include "bdb_tlCommissioning.h"
//   66 #include "bdb_touchlink.h"
//   67 
//   68 #include "bdb_touchlink_initiator.h"
//   69 #include "hal_lcd.h"
//   70 #include "hal_led.h"
//   71 
//   72 #if defined ( BDB_TL_INITIATOR )
//   73    
//   74 /*********************************************************************
//   75  * MACROS
//   76  */
//   77 
//   78 /*********************************************************************
//   79  * CONSTANTS
//   80  */
//   81 
//   82 #define TOUCHLINK_INITIATOR_REJOIN_TIMEOUT             2500 // 2.5 sec
//   83 
//   84 // for non-polling end-devices only
//   85 #define TOUCHLINK_INITIATOR_TEMP_POST_TL_POLL_RATE     1000
//   86 
//   87 #define DEV_INFO_INVALID_EP                            0xFE
//   88 
//   89 #define TOUCHLINK_INITIATOR_NUM_SCAN_REQ_PRIMARY       8  // 5 times on 1st channel, plus once for each remianing primary channel
//   90 #define TOUCHLINK_INITIATOR_NUM_SCAN_REQ_EXTENDED      20 // (TOUCHLINK_NUM_SCAN_REQ_PRIMARY + sizeof(TOUCHLINK_SECONDARY_CHANNELS_SET))
//   91 
//   92 /*********************************************************************
//   93  * TYPEDEFS
//   94  */
//   95 typedef union
//   96 {
//   97   bdbTLNwkStartRsp_t nwkStartRsp;
//   98   bdbTLNwkJoinRsp_t nwkJoinRsp;
//   99 } bdbTLRsp_t;
//  100 
//  101 typedef struct
//  102 {
//  103   bdbTLScanRsp_t scanRsp;
//  104   afAddrType_t srcAddr;
//  105   uint16 newNwkAddr;
//  106   uint8 rxChannel;  // channel scan response was heard on
//  107   int8 lastRssi;    // receieved RSSI
//  108 } targetCandidate_t;
//  109 
//  110 /*********************************************************************
//  111  * GLOBAL VARIABLES
//  112  */
//  113 uint8 touchLinkInitiator_TaskID;
//  114 
//  115 /*********************************************************************
//  116  * EXTERNAL VARIABLES
//  117  */
//  118 extern devStartModes_t devStartMode;
//  119 extern uint8 _tmpRejoinState;
//  120 
//  121 /*********************************************************************
//  122  * EXTERNAL FUNCTIONS
//  123  */
//  124 extern void bdb_setNodeIsOnANetwork(bool isOnANetwork);
//  125 
//  126 /*********************************************************************
//  127  * LOCAL VARIABLES
//  128  */
//  129 static uint8 initiatorSeqNum;
//  130 
//  131 // Touch Link channel tracking
//  132 static uint8 numScanReqSent;
//  133 static uint8 scanReqChannels;
//  134 
//  135 // Network key sent to the target to start the network with
//  136 static uint8 keyIndexSent;
//  137 static uint8 encKeySent[SEC_KEY_LEN];
//  138 static uint32 responseIDSent;
//  139 
//  140 // Info related to the received request
//  141 #if ZSTACK_END_DEVICE_BUILD
//  142 static bdbTLNwkJoinReq_t joinReq;
//  143 #endif
//  144 
//  145 // Info related to the received response
//  146 static targetCandidate_t selectedTarget;
//  147 static uint16 selectedTargetNwkAddr;
//  148 static bdbTLRsp_t rxRsp; // network start or join response
//  149 
//  150 static bdbTLNwkParams_t initiatorNwkParams = {0};
//  151 
//  152 // Addresses used for sending/receiving messages
//  153 static afAddrType_t bcastAddr;
//  154 
//  155 static uint16 savedPollRate;
//  156 static uint16 savedQueuedPollRate;
//  157 static uint16 savedResponsePollRate;
//  158 static uint8 savedRxOnIdle;
//  159 
//  160 // Application callback
//  161 static touchLink_NotifyAppTLCB_t pfnNotifyAppCB = NULL;
//  162 static touchLink_SelectDiscDevCB_t pfnSelectDiscDevCB = NULL;
//  163 
//  164 static uint8 initiatorRegisteredMsgAppTaskID = TASK_NO_TASK;
//  165 
//  166 /*********************************************************************
//  167  * GLOBAL FUNCTIONS
//  168  */
//  169 extern void touchLink_ItemInit( uint16 id, uint16 len, void *pBuf );
//  170 
//  171 /*********************************************************************
//  172  * LOCAL FUNCTIONS
//  173  */
//  174 
//  175 static ZStatus_t initiatorScanReqCB( afAddrType_t *srcAddr, bdbTLScanReq_t *pReq, uint8 seqNum );
//  176 static ZStatus_t initiatorDeviceInfoReqCB( afAddrType_t *srcAddr, bdbTLDeviceInfoReq_t *pReq, uint8 seqNum );
//  177 static ZStatus_t initiatorIdentifyReqCB( afAddrType_t *srcAddr, bdbTLIdentifyReq_t *pReq );
//  178 static ZStatus_t initiatorNwkJoinReqCB( afAddrType_t *srcAddr, bdbTLNwkJoinReq_t *pReq, uint8 seqNum );
//  179 static ZStatus_t initiatorNwkUpdateReqCB( afAddrType_t *srcAddr, bdbTLNwkUpdateReq_t *pReq );
//  180 static ZStatus_t initiatorScanRspCB( afAddrType_t *srcAddr, bdbTLScanRsp_t *pRsp );
//  181 static ZStatus_t initiatorDeviceInfoRspCB( afAddrType_t *srcAddr, bdbTLDeviceInfoRsp_t *pRsp );
//  182 static ZStatus_t initiatorNwkStartRspCB( afAddrType_t *srcAddr, bdbTLNwkStartRsp_t *pRsp );
//  183 static ZStatus_t initiatorNwkJoinRtrRspCB( afAddrType_t *srcAddr, bdbTLNwkJoinRsp_t *pRsp );
//  184 static ZStatus_t initiatorNwkJoinEDRspCB( afAddrType_t *srcAddr, bdbTLNwkJoinRsp_t *pRsp );
//  185 static void *initiatorZdoLeaveCnfCB( void *pParam );
//  186 static ZStatus_t touchLink_InitiatorSendScanRsp( uint8 srcEP, afAddrType_t *dstAddr, uint32 transID, uint8 seqNum );
//  187 static void initiatorProcessStateChange( devStates_t state );
//  188 static void initiatorSetNwkToInitState( void );
//  189 #if ( ZSTACK_ROUTER_BUILD )
//  190 static void initiatorJoinNwk( void );
//  191 #endif
//  192 static void initiatorReJoinNwk( devStartModes_t startMode );
//  193 static void initiatorSendScanReq( bool freshScan );
//  194 static ZStatus_t initiatorSendNwkStartReq( bdbTLScanRsp_t *pRsp );
//  195 static ZStatus_t initiatorSendNwkJoinReq( bdbTLScanRsp_t *pRsp );
//  196 static ZStatus_t initiatorSendNwkUpdateReq( bdbTLScanRsp_t *pRsp );
//  197 static void initiatorClearSelectedTarget( void );
//  198 
//  199 /*********************************************************************
//  200  * TOUCHLINK Initiator Callback Table
//  201  */
//  202 // Initiator Command Callbacks table
//  203 static bdbTL_InterPANCallbacks_t touchLinkInitiator_CmdCBs =
//  204 {
//  205   // Received Server Commands
//  206   initiatorScanReqCB,       // Scan Request command
//  207   initiatorDeviceInfoReqCB, // Device Information Request command
//  208   initiatorIdentifyReqCB,   // Identify Request command
//  209   NULL,                     // Reset to Factory New Request command
//  210   NULL,                     // Network Start Request command
//  211 #if ( ZSTACK_ROUTER_BUILD )
//  212   initiatorNwkJoinReqCB,    // Network Join Router Request command
//  213   NULL,                     // Network Join End Device Request command
//  214 #else
//  215   NULL,                     // Network Join Router Request command
//  216   initiatorNwkJoinReqCB,    // Network Join End Device Request command
//  217 #endif
//  218   initiatorNwkUpdateReqCB,  // Network Update Request command
//  219 
//  220   // Received Client Commands
//  221   initiatorScanRspCB,       // Scan Response command
//  222   initiatorDeviceInfoRspCB, // Device Information Response command
//  223   initiatorNwkStartRspCB,   // Network Start Response command
//  224   initiatorNwkJoinRtrRspCB, // Network Join Router Response command
//  225   initiatorNwkJoinEDRspCB   // Network Join End Device Response command
//  226 };
//  227 
//  228 /*********************************************************************
//  229  * PUBLIC FUNCTIONS
//  230  */
//  231 
//  232 /*********************************************************************
//  233  * @fn      touchLinkInitiator_InitDevice
//  234  *
//  235  * @brief   Start the TOUCHLINK Initiator device in the network if it's not
//  236  *          factory new. Otherwise, determine the network parameters
//  237  *          and wait for a touchlink command.
//  238  *
//  239  * @param   none
//  240  *
//  241  * @return  status
//  242  */
//  243 ZStatus_t touchLinkInitiator_InitDevice( void )
//  244 {
//  245   ZDO_Config_Node_Descriptor.LogicalType = zgDeviceLogicalType;
//  246   
//  247   // Is not factory new?
//  248   if ( bdbAttributes.bdbNodeIsOnANetwork == TRUE )
//  249   {
//  250     // Resume ZigBee functionality based on the info stored in NV
//  251     initiatorReJoinNwk( MODE_RESUME );
//  252   }
//  253   else
//  254   {
//  255     initiatorSelectNwkParams();
//  256   }
//  257 
//  258 #if defined ( POWER_SAVING )
//  259   osal_pwrmgr_device( PWRMGR_BATTERY );
//  260 #endif
//  261 
//  262 #if ( ZSTACK_ROUTER_BUILD )
//  263   // Enable our receiver
//  264   savedRxOnIdle = TRUE;
//  265   ZMacSetReq( ZMacRxOnIdle, &savedRxOnIdle );
//  266   touchLink_PermitJoin(0);
//  267 #endif
//  268 
//  269   return ( ZSuccess );
//  270 }
//  271 
//  272 /*********************************************************************
//  273  * @fn      touchLinkInitiator_RegisterNotifyTLCB
//  274  *
//  275  * @brief   Register an Application's Touch-Link Notify callback function.
//  276  *
//  277  * @param   pfnNotifyApp - application callback
//  278  *
//  279  * @return  none
//  280  */
//  281 void touchLinkInitiator_RegisterNotifyTLCB( touchLink_NotifyAppTLCB_t pfnNotifyApp )
//  282 {
//  283   pfnNotifyAppCB = pfnNotifyApp;
//  284 }
//  285 
//  286 /*********************************************************************
//  287  * @fn      touchLinkInitiator_RegisterSelectDiscDevCB
//  288  *
//  289  * @brief   Register an Application's Selection callback function, to select
//  290  *          a target from the discovered devices during a Touch-link scan.
//  291  *
//  292  * @param   pfnSelectDiscDev - application callback
//  293  *
//  294  * @return  none
//  295  */
//  296 void touchLinkInitiator_RegisterSelectDiscDevCB( touchLink_SelectDiscDevCB_t pfnSelectDiscDev )
//  297 {
//  298   pfnSelectDiscDevCB = pfnSelectDiscDev;
//  299 }
//  300 
//  301 /*********************************************************************
//  302  * @fn      touchLinkInitiator_StartDevDisc
//  303  *
//  304  * @brief   Start device discovery, scanning for other devices in the vicinity
//  305  *          of the originator (initiating first part of the Touch-Link process).
//  306  *          Device discovery shall only be initiated by address assignment capable
//  307  *          devices. To perform device discovery, the initiator shall broadcast
//  308  *          inter-PAN Scan Requests, spaced at an interval of
//  309  *          BDBCTL_SCAN_TIME_BASE_DURATION seconds.
//  310  *
//  311  * @param   none
//  312  *
//  313  * @return  status
//  314  */
//  315 ZStatus_t touchLinkInitiator_StartDevDisc( void )
//  316 {
//  317   osal_clear_event( ZDAppTaskID, ZDO_NETWORK_INIT ); // in case orphaned rejoin was called
//  318   ZDApp_StopJoiningCycle();
//  319 
//  320   //abort any touchlink in progress and start the new dev discovery.
//  321   touchLinkInitiator_AbortTL();
//  322 
//  323   // To perform device discovery, switch to channel 11 and broadcast five
//  324   // consecutive inter-PAN Scan Requests. Then switch to each remaining
//  325   // TOUCHLINK channels in turn (i.e., 15, 20, and 25) and broadcast a single
//  326   // inter-PAN Scan Request on each channel.
//  327   if ( !osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT ) )
//  328   {
//  329     uint8 x = TRUE;
//  330 
//  331     // Generate a new Transaction Id
//  332     touchLinkTransID = ( ( (uint32)osal_rand() ) << 16 ) + osal_rand();
//  333     osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TRANS_LIFETIME_EXPIRED_EVT,
//  334                         BDBCTL_INTER_PAN_TRANS_ID_LIFETIME );
//  335 
//  336     if ( bdbAttributes.bdbNodeIsOnANetwork == TRUE )
//  337     {
//  338       // Turn off polling during touch-link procedure
//  339       savedPollRate = zgPollRate;
//  340       savedQueuedPollRate = zgQueuedPollRate;
//  341       savedResponsePollRate = zgResponsePollRate;
//  342 
//  343       NLME_SetPollRate( 0 );
//  344       NLME_SetQueuedPollRate( 0 );
//  345       NLME_SetResponseRate( 0 );
//  346     }
//  347 
//  348     // Remember current rx state
//  349     ZMacGetReq( ZMacRxOnIdle, &savedRxOnIdle );
//  350 
//  351     // MAC receiver should be on during touch-link procedure
//  352     ZMacSetReq( ZMacRxOnIdle, &x );
//  353 
//  354     scanReqChannels = TOUCHLINK_SCAN_PRIMARY_CHANNELS;
//  355     numScanReqSent = 0;
//  356 
//  357     // Send out the first Scan Request
//  358     initiatorSendScanReq( TRUE );
//  359 
//  360     return ( ZSuccess );
//  361   }
//  362 
//  363   return ( ZFailure );
//  364 }
//  365 
//  366 /*********************************************************************
//  367  * @fn      bdbTL_Send_IndentifyReq
//  368  *
//  369  * @brief   Call to send out a scan request for factory new procedure
//  370  *
//  371  * @param   
//  372  *
//  373  * @return 
//  374  */
//  375 void touchLinkInitiator_ResetToFNProcedure( void )
//  376 {
//  377   if ( ( bdbCommissioningProcedureState.bdbCommissioningState == 0 ) || ( osal_get_timeoutEx( bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE ) == 0 ) )
//  378   {
//  379     touchlinkFNReset = TRUE;
//  380     touchLinkInitiator_StartDevDisc( );
//  381   }
//  382 }
//  383 
//  384 /*********************************************************************
//  385  * @fn      touchLinkInitiator_AbortTL
//  386  *
//  387  * @brief   Abort Touch-link device discovery.
//  388  *          Successful execution could be done before Network Start/Join
//  389  *          commands are sent. Until then, since no device parameters
//  390  *          such as network settings are altered, the Touch-Link is
//  391  *          still reversible.
//  392  *
//  393  * @param   none
//  394  *
//  395  * @return  status
//  396  */
//  397 ZStatus_t touchLinkInitiator_AbortTL( void )
//  398 {
//  399   if ( ( osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT ) == SUCCESS )
//  400        || ( osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT ) == SUCCESS )
//  401        || ( osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_START_RSP_EVT ) == SUCCESS )
//  402        || ( osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT ) == SUCCESS ) )
//  403   {
//  404     initiatorSetNwkToInitState();
//  405     touchLinkTransID = 0;
//  406     numScanReqSent = 0;
//  407     initiatorClearSelectedTarget();
//  408     selectedTargetNwkAddr = 0;
//  409 
//  410     return ( ZSuccess );
//  411   }
//  412 
//  413   return ( ZFailure );
//  414 }
//  415 
//  416 /*********************************************************************
//  417  * @fn          touchLinkInitiator_Init
//  418  *
//  419  * @brief       Initialization function for the TOUCHLINK Initiator task.
//  420  *
//  421  * @param       task_id - TOUCHLINK Initiator task id
//  422  *
//  423  * @return      none
//  424  */
//  425 void touchLinkInitiator_Init( uint8 task_id )
//  426 {
//  427   // Save our own Task ID
//  428   touchLinkInitiator_TaskID = task_id;
//  429 
//  430   touchLink_SetTouchLinkTaskId( touchLinkInitiator_TaskID );
//  431 
//  432 
//  433   // Build a broadcast address for the Scan Request
//  434   bcastAddr.addrMode = afAddrBroadcast;
//  435   bcastAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVALL;
//  436   bcastAddr.panId = 0xFFFF;
//  437   bcastAddr.endPoint = STUBAPS_INTER_PAN_EP;
//  438 
//  439   // Initialize TOUCHLINK common variables
//  440   touchLink_InitVariables( TRUE );
//  441 
//  442   savedPollRate = POLL_RATE;
//  443   savedQueuedPollRate = QUEUED_POLL_RATE;
//  444   savedResponsePollRate = RESPONSE_POLL_RATE;
//  445 
//  446   numScanReqSent = 0;
//  447   initiatorClearSelectedTarget();
//  448   scanReqChannels = TOUCHLINK_SCAN_PRIMARY_CHANNELS;
//  449 
//  450   initiatorSeqNum = 0;
//  451 
//  452   // Register to receive the unprocessed Foundation command/response messages
//  453   zcl_registerForMsg( touchLinkInitiator_TaskID );
//  454 
//  455   // Register for TOUCHLINK Initiator callbacks (for Inter-PAN commands)
//  456   bdbTL_RegisterInterPANCmdCallbacks( &touchLinkInitiator_CmdCBs );
//  457 
//  458   // Register for Initiator to receive Leave Confirm
//  459   ZDO_RegisterForZdoCB( ZDO_LEAVE_CNF_CBID, initiatorZdoLeaveCnfCB );
//  460 
//  461 #if (ZSTACK_ROUTER_BUILD)
//  462   // Register to process ZDO messages
//  463   ZDO_RegisterForZDOMsg( touchLinkInitiator_TaskID, Mgmt_Permit_Join_req );
//  464   ZDO_RegisterForZDOMsg( touchLinkInitiator_TaskID, Device_annce );
//  465 #endif
//  466 
//  467 }
//  468 
//  469 /*********************************************************************
//  470  * @fn      initiatorSelectNwkParams
//  471  *
//  472  * @brief   Select a unique PAN ID and Extended PAN ID when compared to
//  473  *          the PAN IDs and Extended PAN IDs of the networks detected
//  474  *          on the TOUCHLINK channels. The selected Extended PAN ID must be
//  475  *          a random number (and not equal to our IEEE address).
//  476  *
//  477  * @param   void
//  478  *
//  479  * @return  void
//  480  */
//  481 void initiatorSelectNwkParams( void )
//  482 {
//  483   // Set our group ID range
//  484   touchLink_PopGrpIDRange( touchLink_GetNumGrpIDs(), &touchLinkGrpIDsBegin, &touchLinkGrpIDsEnd );
//  485 
//  486   // Select a random Extended PAN ID
//  487   touchLink_GenerateRandNum( _NIB.extendedPANID, Z_EXTADDR_LEN );
//  488 
//  489   // Select a random PAN ID
//  490   _NIB.nwkPanId = osal_rand();
//  491 
//  492   if ( _NIB.nwkLogicalChannel == 0 )
//  493   {
//  494     if (TOUCHLINK_FIXED_CHANNEL_ENABLE == TRUE )
//  495     {
//  496       // Use the fixed channel defined in bdb_interface
//  497       _NIB.nwkLogicalChannel = TOUCHLINK_FIXED_CHANNEL;
//  498     }
//  499     else
//  500     {
//  501       // Select randomly one of the TouchLink channels as our logical channel
//  502       _NIB.nwkLogicalChannel = touchLink_GetRandPrimaryChannel( );
//  503     }
//  504   }
//  505   
//  506   selectedTargetNwkAddr = 0;
//  507 
//  508   if ( devState != DEV_INIT )
//  509   {
//  510     // Let's assume we're the first initiator
//  511     _NIB.nwkDevAddress = touchLink_PopNwkAddress();
//  512   }
//  513 
//  514   // Configure MAC with our network parameters
//  515   touchLink_SetMacNwkParams( _NIB.nwkDevAddress, _NIB.nwkPanId, _NIB.nwkLogicalChannel );
//  516 }
//  517 
//  518 /*********************************************************************
//  519  * @fn      touchLinkInitiator_RegisterForMsg
//  520  *
//  521  * @brief   Register application task to receive unprocessed messages
//  522  *          received by the initiator endpoint.
//  523  *
//  524  * @param   taskId - task Id of the Application where commands will be sent to
//  525  *
//  526  * @return  ZSuccess if task registration successful
//  527  *********************************************************************/
//  528 ZStatus_t touchLinkInitiator_RegisterForMsg( uint8 taskId )
//  529 {
//  530   if ( initiatorRegisteredMsgAppTaskID == TASK_NO_TASK )
//  531   {
//  532     initiatorRegisteredMsgAppTaskID = taskId;
//  533     return ( ZSuccess );
//  534   }
//  535   return ( ZFailure );
//  536 }
//  537 
//  538 /*********************************************************************
//  539  * @fn          touchLinkInitiator_event_loop
//  540  *
//  541  * @brief       Event Loop Processor for TOUCHLINK Initiator.
//  542  *
//  543  * @param       task_id - task id
//  544  * @param       events - event bitmap
//  545  *
//  546  * @return      unprocessed events
//  547  */
//  548 uint16 touchLinkInitiator_event_loop( uint8 task_id, uint16 events )
//  549 {
//  550   if ( events & SYS_EVENT_MSG )
//  551   {
//  552     osal_event_hdr_t *pMsg;
//  553     ZStatus_t stat = ZFailure;
//  554 
//  555     if ( (pMsg = (osal_event_hdr_t *)osal_msg_receive( task_id )) != NULL )
//  556     {
//  557       switch ( pMsg->event )
//  558       {
//  559 
//  560 #if (ZSTACK_ROUTER_BUILD)
//  561         case ZDO_CB_MSG:
//  562           // ZDO sends the message that we registered for
//  563           touchLink_RouterProcessZDOMsg( (zdoIncomingMsg_t *)pMsg );
//  564           stat = ZSuccess;
//  565           break;
//  566 #endif
//  567         case ZDO_STATE_CHANGE:
//  568           initiatorProcessStateChange( (devStates_t)pMsg->status );
//  569           stat = ZSuccess;
//  570           break;
//  571 
//  572         default:
//  573           break;
//  574       }
//  575 
//  576       if ( stat == ZSuccess )
//  577       {
//  578         // Release the OSAL message
//  579         VOID osal_msg_deallocate( (uint8 *)pMsg );
//  580       }
//  581       else
//  582       {
//  583         // forward to the application
//  584         osal_msg_send( initiatorRegisteredMsgAppTaskID, (uint8 *)pMsg );
//  585       }
//  586     }
//  587 
//  588     // return unprocessed events
//  589     return ( events ^ SYS_EVENT_MSG );
//  590   }
//  591 
//  592   if ( events & TOUCHLINK_TL_SCAN_BASE_EVT )
//  593   {
//  594     if ( ( ( scanReqChannels == TOUCHLINK_SCAN_PRIMARY_CHANNELS ) && ( numScanReqSent < TOUCHLINK_INITIATOR_NUM_SCAN_REQ_PRIMARY  ) ) ||
//  595          ( ( scanReqChannels == TOUCHLINK_SCAN_SECONDARY_CHANNELS ) && ( numScanReqSent < TOUCHLINK_INITIATOR_NUM_SCAN_REQ_EXTENDED ) ) )
//  596     {
//  597       // Send another Scan Request on the next channel
//  598       initiatorSendScanReq( FALSE );
//  599     }
//  600     else // Channels scan is complete
//  601     {
//  602       if ( ( scanReqChannels == TOUCHLINK_SCAN_PRIMARY_CHANNELS ) && ( bdbAttributes.bdbNodeIsOnANetwork == FALSE ) )
//  603       {
//  604         // Extended scan is required, lets scan secondary channels
//  605         scanReqChannels = TOUCHLINK_SCAN_SECONDARY_CHANNELS;
//  606 
//  607         // Send another Scan Request on the next channel
//  608         initiatorSendScanReq( FALSE );
//  609       }
//  610       // See if we've received any Scan Responses back
//  611       else if ( ( selectedTarget.lastRssi != TOUCHLINK_WORST_RSSI )
//  612                && ( selectedTarget.scanRsp.deviceInfo.endpoint != DEV_INFO_INVALID_EP ) )
//  613       {
//  614         // Make sure the responder is not a factory new initiator if this device is also 
//  615         // factory new
//  616         if ( ( selectedTarget.scanRsp.touchLinkInitiator == FALSE ) ||
//  617              ( bdbAttributes.bdbNodeIsOnANetwork == TRUE ) )
//  618         {
//  619           bdbTLIdentifyReq_t req;
//  620 
//  621           // Tune to the channel that the Scan Response was heard on
//  622           touchLink_SetChannel( selectedTarget.rxChannel );
//  623 
//  624           req.transID = selectedTarget.scanRsp.transID;
//  625           req.IdDuration = BDB_TL_IDENTIFY_TIME;
//  626           
//  627           if ( touchlinkFNReset == TRUE )
//  628           {
//  629             osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT );
//  630             return ( events ^ TOUCHLINK_TL_SCAN_BASE_EVT );
//  631           }
//  632           
//  633           bdbTL_Send_IndentifyReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), &req, initiatorSeqNum++ );
//  634 
//  635 #if ZSTACK_ROUTER_BUILD
//  636           uint8 i = 0;
//  637             
//  638           while ( !CHECK_BIT ( selectedTarget.scanRsp.keyBitmask , i ) ) 
//  639           {
//  640             i++;
//  641           }
//  642     
//  643           initiatorNwkParams.keyIndex = i;
//  644           zTouchLinkNwkStartRtr = TRUE;
//  645           // Disabe other TouchLink events
//  646           osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_DISABLE_RX_EVT );
//  647 #endif
//  648           osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT, TOUCHLINK_INITIATOR_IDENTIFY_INTERVAL );
//  649         }
//  650         // else wait for touch-link commands from the other initiator
//  651       }
//  652       else
//  653       {
//  654         // We did not manage to select any target
//  655         // Let's just go back to our initial configuration
//  656         osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_DISABLE_RX_EVT );
//  657         bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TL_NO_SCAN_RESPONSE;
//  658         bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
//  659       }
//  660     }
//  661 
//  662     // return unprocessed events
//  663     return ( events ^ TOUCHLINK_TL_SCAN_BASE_EVT );
//  664   }
//  665 
//  666   if ( events & TOUCHLINK_CFG_TARGET_EVT )
//  667   {
//  668     ZStatus_t status = ZFailure;
//  669 
//  670     bdbTLIdentifyReq_t req;
//  671 
//  672     req.transID = selectedTarget.scanRsp.transID;
//  673     req.IdDuration = 0x00;
//  674     uint8 tcExtAddr[Z_EXTADDR_LEN];
//  675     uint8 DistributedSecurityNwkAddress[Z_EXTADDR_LEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
//  676         
//  677     if ( zTouchLinkNwkStartRtr == FALSE )
//  678     {
//  679       // Send an Identify stop Request
//  680       bdbTL_Send_IndentifyReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), &req, initiatorSeqNum++ );
//  681     }
//  682     
//  683    // See if the target is part of our network
//  684     if ( !TOUCHLINK_SAME_NWK( selectedTarget.scanRsp.PANID, selectedTarget.scanRsp.extendedPANID ) )
//  685     {
//  686       // If the local device is not the trust center, always return TRUE
//  687       status = APSME_GetRequest( apsTrustCenterAddress, 0, tcExtAddr );
//  688         
//  689       // Notify BDB state machine
//  690       if ( bdbAttributes.bdbNodeIsOnANetwork == TRUE )
//  691       {
//  692         if ( ( status == ZSuccess ) && ( !osal_ExtAddrEqual( DistributedSecurityNwkAddress, tcExtAddr ) ) )
//  693         {
//  694           bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TL_NOT_PERMITTED;
//  695           bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
//  696           return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
//  697         }
//  698       }
//  699             
//  700       // verify address ranges split possible if required
//  701       if ( !touchLink_IsValidSplitFreeRanges( selectedTarget.scanRsp.totalGrpIDs ) )
//  702       {
//  703         bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TL_NOT_AA_CAPABLE;
//  704         bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
//  705         return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
//  706       }
//  707       
//  708       if ( touchlinkFNReset == TRUE )
//  709       {
//  710         touchlinkFNReset = FALSE;
//  711         touchLinkInitiator_ResetToFNSelectedTarget( );
//  712         osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_DISABLE_RX_EVT );
//  713         
//  714         return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
//  715       }
//  716         
//  717       if ( bdbAttributes.bdbNodeIsOnANetwork == TRUE )
//  718       {
//  719         // Ask the target to join our network
//  720         osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_NWK_FORMATION_SUCCESS_EVT, 50);
//  721         zTouchLinkNwkStartRtr = FALSE;
//  722         return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
//  723       }
//  724       else if ( ZSTACK_ROUTER_BUILD == TRUE )
//  725       {
//  726         // Tune to the channel that the Scan Response was heard on
//  727         touchLink_SetChannel( selectedTarget.rxChannel );
//  728         
//  729         // Try to form a new network
//  730         osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_NWK_RTR_START_EVT);
//  731         return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
//  732       }
//  733       else if ( ZSTACK_ROUTER_BUILD == FALSE )
//  734       {
//  735         if ( selectedTarget.scanRsp.zLogicalType == ZG_DEVICETYPE_ROUTER )
//  736         {
//  737           if ( bdbAttributes.bdbNodeIsOnANetwork == FALSE )
//  738           {
//  739             _NIB.nwkDevAddress = APL_FREE_NWK_ADDR_RANGE_BEGIN;
//  740           }
//  741           
//  742           // Must be the first light; ask the light to start the network
//  743           status = initiatorSendNwkStartReq( &(selectedTarget.scanRsp) );
//  744         }
//  745         else
//  746         {
//  747           // Notify the BDB state machine 
//  748           bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
//  749           bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
//  750           return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
//  751         }
//  752       }
//  753     }
//  754     
//  755     else if ( _NIB.nwkUpdateId != selectedTarget.scanRsp.nwkUpdateId )
//  756     {
//  757       // Set NWK task to run
//  758       nwk_setStateIdle( TRUE );
//  759       
//  760       // Target is already part of our network
//  761       if ( selectedTarget.scanRsp.nwkUpdateId > _NIB.nwkUpdateId )
//  762       {
//  763         // Update our network update id and logical channel
//  764         touchLink_ProcessNwkUpdate( selectedTarget.scanRsp.nwkUpdateId, selectedTarget.scanRsp.logicalChannel );
//  765 
//  766         // We're done here
//  767         status = ZSuccess;
//  768       }
//  769       else if ( selectedTarget.scanRsp.nwkUpdateId < _NIB.nwkUpdateId )
//  770       {
//  771         // Inform the target to update its network update id and logical channel
//  772         initiatorSendNwkUpdateReq( &(selectedTarget.scanRsp) ); // there's no corresponding response!
//  773 
//  774         // Notify the application about this device
//  775         osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_NOTIFY_APP_EVT );
//  776       }
//  777       
//  778       bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
//  779       bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, TRUE );
//  780       return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
//  781     }
//  782     
//  783     //we are touchlinking to a light in our network, just send application the device info
//  784     else if ( selectedTarget.scanRsp.touchLinkInitiator == FALSE )
//  785     {
//  786       epInfoRec_t rec;
//  787       rec.nwkAddr = selectedTarget.scanRsp.nwkAddr;
//  788       rec.endpoint = selectedTarget.scanRsp.deviceInfo.endpoint;
//  789       rec.profileID = selectedTarget.scanRsp.deviceInfo.profileID;
//  790       rec.deviceID = selectedTarget.scanRsp.deviceInfo.deviceID;
//  791       rec.version = selectedTarget.scanRsp.deviceInfo.version;
//  792       // Notify the application
//  793       if ( pfnNotifyAppCB )
//  794       {
//  795         (*pfnNotifyAppCB)( &rec );
//  796       }
//  797       bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
//  798       bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, TRUE );
//  799     }
//  800 
//  801     // return unprocessed events
//  802     return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
//  803   }
//  804 
//  805   if ( events & TOUCHLINK_W4_NWK_START_RSP_EVT )
//  806   {
//  807     bdbTLNwkStartRsp_t *pRsp = &(rxRsp.nwkStartRsp);
//  808 
//  809     // Look if we have a valid response
//  810     if ( ( pRsp->status == TOUCHLINK_NETWORK_START_RSP_STATUS_SUCCESS )
//  811        && ( ( nwk_ExtPANIDValid( pRsp->extendedPANID ) ) && ( touchLink_IsValidTransID( pRsp->transID ) ) ) )
//  812     {
//  813       // Copy the new network parameters to NIB
//  814       touchLink_SetNIB( ( ZSTACK_ROUTER_BUILD ? NWK_ROUTER : NWK_REJOINING ),
//  815                   _NIB.nwkDevAddress, pRsp->extendedPANID,
//  816                   pRsp->logicalChannel, pRsp->panId, pRsp->nwkUpdateId );
//  817 
//  818       // Apply the received network key
//  819       touchLink_DecryptNwkKey( encKeySent, keyIndexSent, pRsp->transID, responseIDSent );
//  820 
//  821       // This is not a usual Trust Center protected network
//  822       ZDSecMgrUpdateTCAddress( NULL );
//  823 
//  824       // Notify the application about this device
//  825       osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_NOTIFY_APP_EVT );
//  826 
//  827       // Wait at least BDBCTL_MIN_STARTUP_DELAY_TIME seconds to allow the
//  828       // target to start the network correctly. Join the target afterwards.
//  829       osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_START_NWK_EVT, BDBCTL_MIN_STARTUP_DELAY_TIME );
//  830     }
//  831     else
//  832     {
//  833       // Notify the BDB state machine 
//  834       bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
//  835       bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );        
//  836     }
//  837 
//  838     // return unprocessed events
//  839     return ( events ^ TOUCHLINK_W4_NWK_START_RSP_EVT );
//  840   }
//  841 
//  842   if ( events & TOUCHLINK_START_NWK_EVT )
//  843   {
//  844     // Rejoins without NWK scan
//  845 
//  846     bdbTLNwkStartRsp_t *pRsp = &(rxRsp.nwkStartRsp);
//  847     bdbTLNwkRejoin_t rejoinInf;
//  848     
//  849     rejoinInf.panId = pRsp->panId;
//  850     rejoinInf.logicalChannel = pRsp->logicalChannel;
//  851     osal_memcpy( rejoinInf.extendedPANID, pRsp->extendedPANID, Z_EXTADDR_LEN);
//  852     rejoinInf.nwkAddr = selectedTargetNwkAddr;
//  853     rejoinInf.nwkUpdateId = pRsp->nwkUpdateId;
//  854       
//  855     touchLink_DevRejoin( &rejoinInf );
//  856 
//  857     // return unprocessed events
//  858     return ( events ^ TOUCHLINK_START_NWK_EVT );
//  859   }
//  860 
//  861   if ( events & TOUCHLINK_W4_NWK_JOIN_RSP_EVT )
//  862   {
//  863     bdbTLNwkJoinRsp_t *pRsp = &(rxRsp.nwkJoinRsp);
//  864 
//  865     if ( pRsp->status == TOUCHLINK_NETWORK_JOIN_RSP_STATUS_SUCCESS )
//  866     {
//  867       // Wait at least BDBCTL_MIN_STARTUP_DELAY_TIME seconds to allow the
//  868       // target to start operating on the network correctly. Notify the
//  869       // application afterwards.
//  870       osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_NOTIFY_APP_EVT,
//  871                           BDBCTL_MIN_STARTUP_DELAY_TIME );
//  872       
//  873       // Establish bind links
//  874       if ( pRespondentHead != NULL )
//  875       {
//  876         osal_start_timerEx( bdb_TaskID, BDB_RESPONDENT_SIMPLEDESC_TIMEOUT, 20000 );
//  877       }
//  878       
//  879       // We're done with touch-link procedure here
//  880       initiatorSetNwkToInitState();
//  881       //bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
//  882       //bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, TRUE );
//  883 
//  884       touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
//  885 
//  886       if ( ( POLL_RATE == 0 ) && ( selectedTarget.scanRsp.zLogicalType == ZG_DEVICETYPE_ENDDEVICE ) )
//  887       {
//  888         //allow to respond to TOUCHLINK commission utility commands after TL
//  889         NLME_SetPollRate( TOUCHLINK_INITIATOR_TEMP_POST_TL_POLL_RATE );
//  890         //polling should reset when TL life time expires
//  891       }
//  892     }
//  893     else 
//  894     {
//  895       touchLink_SendLeaveReq( );
//  896       bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TL_TARGET_FAILURE;
//  897       bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
//  898     }
//  899 
//  900     // return unprocessed events
//  901     return ( events ^ TOUCHLINK_W4_NWK_JOIN_RSP_EVT );
//  902   }
//  903 
//  904   if ( events & TOUCHLINK_NWK_JOIN_IND_EVT )
//  905   {
//  906     // If not factory new, perform a Leave on our old network
//  907     if ( ( bdbAttributes.bdbNodeIsOnANetwork == TRUE ) && ( touchLink_SendLeaveReq( ) == ZSuccess ) )
//  908     {
//  909       // Wait for Leave confirmation before joining the new network
//  910       touchLinkLeaveInitiated = TOUCHLINK_LEAVE_TO_JOIN_NWK;
//  911     }
//  912     else
//  913     {
//  914 #if ( ZSTACK_ROUTER_BUILD )
//  915       // Notify our task to join this network
//  916       osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_JOIN_NWK_ATTEMPT_EVT );
//  917 #else
//  918       bdbTLNwkParams_t *pParams = &(joinReq.nwkParams);
//  919       
//  920       // Notify our task to join this network
//  921       // Perform Network Discovery to verify our new network parameters uniqeness
//  922       touchLink_PerformNetworkDisc( (uint32)1 << pParams->logicalChannel );
//  923 #endif
//  924     }
//  925 
//  926     // return unprocessed events
//  927     return ( events ^ TOUCHLINK_NWK_JOIN_IND_EVT );
//  928   }
//  929 
//  930   if ( events & TOUCHLINK_JOIN_NWK_ATTEMPT_EVT )
//  931   {
//  932     // Join the network
//  933 #if ( ZSTACK_ROUTER_BUILD )
//  934     initiatorJoinNwk();
//  935 #else
//  936     bdbTLNwkParams_t *pParams = &(joinReq.nwkParams);
//  937     
//  938     bdbTLNwkRejoin_t rejoinInf;
//  939          
//  940     rejoinInf.panId = pParams->panId;
//  941     rejoinInf.logicalChannel = pParams->logicalChannel;
//  942     osal_memcpy( rejoinInf.extendedPANID, pParams->extendedPANID, Z_EXTADDR_LEN);
//  943     rejoinInf.nwkAddr = pDiscoveredNwkParamList->chosenRouter;
//  944     rejoinInf.nwkUpdateId = joinReq.nwkUpdateId;
//  945       
//  946     touchLink_DevRejoin( &rejoinInf );
//  947 #endif
//  948     touchLink_FreeNwkParamList();
//  949 
//  950     // return unprocessed events
//  951     return ( events ^ TOUCHLINK_JOIN_NWK_ATTEMPT_EVT );
//  952   }
//  953 
//  954   if ( events & TOUCHLINK_DISABLE_RX_EVT )
//  955   {
//  956     // We're not asked to join a network
//  957     initiatorSetNwkToInitState();
//  958 
//  959     scanReqChannels = TOUCHLINK_SCAN_PRIMARY_CHANNELS;
//  960     numScanReqSent = 0;
//  961     // Reset selected target
//  962     if ( zTouchLinkNwkStartRtr == FALSE )
//  963     {
//  964       initiatorClearSelectedTarget();
//  965     }
//  966 
//  967     // return unprocessed events
//  968     return ( events ^ TOUCHLINK_DISABLE_RX_EVT );
//  969   }
//  970 
//  971   if ( events & TOUCHLINK_W4_REJOIN_EVT )
//  972   {
//  973     // Stop joining cycle
//  974     ZDApp_StopJoiningCycle();
//  975 
//  976     // return unprocessed events
//  977     return ( events ^ TOUCHLINK_W4_REJOIN_EVT );
//  978   }
//  979 
//  980   if ( events & TOUCHLINK_NOTIFY_APP_EVT )
//  981   {
//  982     if ( selectedTarget.lastRssi > TOUCHLINK_WORST_RSSI )
//  983     {
//  984       epInfoRec_t rec;
//  985       rec.nwkAddr = selectedTarget.newNwkAddr; // newly assigned network address
//  986       rec.endpoint = selectedTarget.scanRsp.deviceInfo.endpoint;
//  987       rec.profileID = selectedTarget.scanRsp.deviceInfo.profileID;
//  988       rec.deviceID = selectedTarget.scanRsp.deviceInfo.deviceID;
//  989       rec.version = selectedTarget.scanRsp.deviceInfo.version;
//  990       // Notify the application
//  991       if ( pfnNotifyAppCB )
//  992       {
//  993         (*pfnNotifyAppCB)( &rec );
//  994       }
//  995     }
//  996     // return unprocessed events
//  997     return ( events ^ TOUCHLINK_NOTIFY_APP_EVT );
//  998   }
//  999   
// 1000   if ( events & TOUCHLINK_NWK_RTR_START_EVT )
// 1001   {
// 1002     uint16 nwkAddr = INVALID_NODE_ADDR;
// 1003     
// 1004     osal_nv_write( ZCD_NV_NIB, osal_offsetof( nwkIB_t, nwkDevAddress ),
// 1005                    sizeof( uint16), &nwkAddr );
// 1006     
// 1007     // If the PAN Id, Extended PAN Id or Logical Channel are zero then
// 1008     // determine each of these parameters
// 1009     if ( !nwk_ExtPANIDValid( initiatorNwkParams.extendedPANID ) )
// 1010     {
// 1011       touchLink_GenerateRandNum( initiatorNwkParams.extendedPANID, Z_EXTADDR_LEN );
// 1012     }
// 1013 
// 1014     if ( initiatorNwkParams.panId == 0 )
// 1015     {
// 1016       initiatorNwkParams.panId = osal_rand();
// 1017     }
// 1018 
// 1019     if ( initiatorNwkParams.logicalChannel == 0 )
// 1020     {
// 1021       initiatorNwkParams.logicalChannel = touchLink_GetRandPrimaryChannel();
// 1022     }
// 1023 
// 1024     if ( selectedTarget.scanRsp.touchLinkAddressAssignment)
// 1025     {
// 1026       touchLink_GerFreeRanges( &initiatorNwkParams );
// 1027     }
// 1028 
// 1029     // Perform Network Discovery to verify our new network parameters uniqeness
// 1030     touchLink_PerformNetworkDisc( (uint32)1 << initiatorNwkParams.logicalChannel );
// 1031 
// 1032     // return unprocessed events
// 1033     return ( events ^ TOUCHLINK_NWK_RTR_START_EVT );
// 1034   }
// 1035   
// 1036   if ( events & TOUCHLINK_NWK_FORMATION_SUCCESS_EVT )
// 1037   {
// 1038     if( bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_TL )
// 1039     {
// 1040       bdbTLNwkJoinRsp_t *pRsp = &(rxRsp.nwkJoinRsp);
// 1041       pRsp->status = TOUCHLINK_NETWORK_JOIN_RSP_STATUS_FAILURE;
// 1042       
// 1043       // Tune to the channel that the Scan Response was heard on
// 1044       touchLink_SetChannel( selectedTarget.rxChannel );
// 1045       
// 1046       if ( _NIB.nwkUpdateId <= selectedTarget.scanRsp.nwkUpdateId )
// 1047       {
// 1048         NLME_SetUpdateID( selectedTarget.scanRsp.nwkUpdateId );
// 1049       }
// 1050       // Ask the target to join our network
// 1051       bdb_Initiator_SendNwkJoinReq( );
// 1052       zTouchLinkNwkStartRtr = FALSE;
// 1053     }
// 1054     return ( events ^ TOUCHLINK_NWK_FORMATION_SUCCESS_EVT );
// 1055   }
// 1056 
// 1057   if ( events & TOUCHLINK_NWK_DISC_CNF_EVT )
// 1058   {
// 1059 #if ZSTACK_ROUTER_BUILD
// 1060     if ( bdbAttributes.bdbNodeIsOnANetwork == FALSE )
// 1061     {
// 1062       initiatorNwkParams.nwkAddr = APL_FREE_NWK_ADDR_RANGE_BEGIN;
// 1063     }
// 1064     // Copy in the encrypted network key
// 1065     touchLink_EncryptNwkKey( initiatorNwkParams.nwkKey, initiatorNwkParams.keyIndex, touchLinkTransID, touchLinkResponseID );
// 1066     // Start operating on the new network
// 1067     touchLinkStartRtr( &initiatorNwkParams, touchLinkTransID );
// 1068 #else
// 1069     // Join to the chosen network
// 1070     osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_JOIN_NWK_ATTEMPT_EVT );
// 1071 #endif
// 1072     // return unprocessed events
// 1073     return ( events ^ TOUCHLINK_NWK_DISC_CNF_EVT );
// 1074   }
// 1075 
// 1076   if ( events & TOUCHLINK_TRANS_LIFETIME_EXPIRED_EVT )
// 1077   {
// 1078     touchLinkTransID = 0;
// 1079     initiatorClearSelectedTarget();
// 1080     initiatorSetNwkToInitState();
// 1081 
// 1082     // return unprocessed events
// 1083     return ( events ^ TOUCHLINK_TRANS_LIFETIME_EXPIRED_EVT );
// 1084   }
// 1085 
// 1086   // If reach here, the events are unknown
// 1087   // Discard or make more handlers
// 1088   return 0;
// 1089 }
// 1090 
// 1091 /*********************************************************************
// 1092  * @fn      touchLinkInitiator_ChannelChange
// 1093  *
// 1094  * @brief   Change channel to supprot Frequency agility.
// 1095  *
// 1096  * @param   targetChannel - channel to
// 1097  *
// 1098  * @return  status
// 1099  */
// 1100 ZStatus_t touchLinkInitiator_ChannelChange( uint8 targetChannel )
// 1101 {
// 1102     uint32 channelMask;
// 1103     zAddrType_t dstAddr = {0};
// 1104     if ( ( targetChannel < 11 ) || targetChannel > 26 )
// 1105     {
// 1106       if (TOUCHLINK_PRIMARY_CHANNEL (_NIB.nwkLogicalChannel))
// 1107       {
// 1108         switch (_NIB.nwkLogicalChannel)
// 1109         {
// 1110         case TOUCHLINK_FIRST_CHANNEL:
// 1111           targetChannel = TOUCHLINK_SECOND_CHANNEL;
// 1112           break;
// 1113         case TOUCHLINK_SECOND_CHANNEL:
// 1114           targetChannel = TOUCHLINK_THIRD_CHANNEL;
// 1115           break;
// 1116         case TOUCHLINK_THIRD_CHANNEL:
// 1117           targetChannel = TOUCHLINK_FOURTH_CHANNEL;
// 1118           break;
// 1119         case TOUCHLINK_FOURTH_CHANNEL:
// 1120           targetChannel = TOUCHLINK_FIRST_CHANNEL;
// 1121         }
// 1122       }
// 1123       else
// 1124       {
// 1125         targetChannel = _NIB.nwkLogicalChannel + 1;
// 1126         if ( _NIB.nwkLogicalChannel > 26 )
// 1127           targetChannel = 11;
// 1128       }
// 1129     }
// 1130 
// 1131     dstAddr.addrMode = AddrBroadcast;
// 1132     dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
// 1133     channelMask = (uint32)1 << targetChannel;
// 1134 
// 1135     // Increment the nwkUpdateId parameter and set the updateID in the beacon
// 1136     NLME_SetUpdateID(_NIB.nwkUpdateId + 1);
// 1137 
// 1138     ZDP_MgmtNwkUpdateReq( &dstAddr, channelMask, 0xfe, 0, _NIB.nwkUpdateId, 0 );
// 1139 
// 1140     return ZSuccess;
// 1141 }
// 1142 
// 1143 /*********************************************************************
// 1144  * @fn      touchLinkSampleRemote_SendEPInfo
// 1145  *
// 1146  * @brief   Send Endpoint info command.
// 1147  *
// 1148  * @param   srcEP - source endpoint
// 1149  * @param   dstAddr - destination address
// 1150  * @param   seqNum - transaction sequnece number
// 1151  *
// 1152  * @return  ZStatus_t
// 1153  */
// 1154 ZStatus_t touchLinkInitiator_SendEPInfo( uint8 srcEP, afAddrType_t *dstAddr, uint8 seqNum)
// 1155 {
// 1156     bdbTLEndpointInfo_t bdbTLEndpointInfoCmd;
// 1157     bdbTLDeviceInfo_t  bdbTLDeviceInfo;
// 1158       //send Epinfo cmd
// 1159     touchLink_GetSubDeviceInfo( 0, &bdbTLDeviceInfo );
// 1160     bdbTLEndpointInfoCmd.endpoint = bdbTLDeviceInfo.endpoint;
// 1161     bdbTLEndpointInfoCmd.profileID = bdbTLDeviceInfo.profileID;
// 1162     bdbTLEndpointInfoCmd.deviceID = bdbTLDeviceInfo.deviceID;
// 1163     bdbTLEndpointInfoCmd.version = bdbTLDeviceInfo.version;
// 1164 
// 1165     osal_cpyExtAddr( bdbTLEndpointInfoCmd.ieeeAddr, NLME_GetExtAddr() );
// 1166     bdbTLEndpointInfoCmd.nwkAddr = NLME_GetShortAddr();
// 1167 
// 1168     dstAddr->panId = _NIB.nwkPanId;
// 1169     return bdbTL_Send_EndpointInfo( srcEP, dstAddr, &bdbTLEndpointInfoCmd,
// 1170                                           0, seqNum );
// 1171 }
// 1172 
// 1173 /*********************************************************************
// 1174  * @fn      touchLinkInitiator_ResetToFNSelectedTarget
// 1175  *
// 1176  * @brief   Send Reset to Factory New Request command to the selected
// 1177  *          target of the current Touch-Link transaction.
// 1178  *          Note - this function should be called within no later than
// 1179  *          BDBCTL_INTER_PAN_TRANS_ID_LIFETIME ms from the Scan Request.
// 1180  *
// 1181  * @param   none
// 1182  *
// 1183  * @return  status - failure is returned due to invalid selected target or
// 1184  *          expired Touch-Link transaction.
// 1185  */
// 1186 ZStatus_t touchLinkInitiator_ResetToFNSelectedTarget( void )
// 1187 {
// 1188   bdbTLResetToFNReq_t req;
// 1189   req.transID = touchLinkTransID;
// 1190 
// 1191   // Cancel further touch-link commissioning (if called during identify interval)
// 1192   osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT );
// 1193 
// 1194   touchLink_SetChannel( selectedTarget.rxChannel );
// 1195   return bdbTL_Send_ResetToFNReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), &req, initiatorSeqNum++ );
// 1196 }
// 1197 
// 1198 /*********************************************************************
// 1199  * @fn      touchLink_InitiatorSendScanRsp
// 1200  *
// 1201  * @brief   Send out a Scan Response command.
// 1202  *
// 1203  * @param   srcEP - sender's endpoint
// 1204  * @param   dstAddr - pointer to destination address struct
// 1205  * @param   transID - received transaction id
// 1206  * @param   seqNum - received sequence number
// 1207  *
// 1208  * @return  ZStatus_t
// 1209  */
// 1210 static ZStatus_t touchLink_InitiatorSendScanRsp( uint8 srcEP, afAddrType_t *dstAddr, uint32 transID, uint8 seqNum )
// 1211 {
// 1212   ZStatus_t status = ZSuccess;
// 1213 
// 1214   // Make sure we respond only once during a Device Discovery
// 1215   if ( touchLinkLastAcceptedTransID != transID )
// 1216   {
// 1217     bdbTLScanRsp_t *pRsp;    
// 1218 
// 1219     pRsp = (bdbTLScanRsp_t *)osal_mem_alloc( sizeof( bdbTLScanRsp_t ) );
// 1220     if ( pRsp )
// 1221     {
// 1222       osal_memset( pRsp, 0, sizeof( bdbTLScanRsp_t ) );
// 1223 
// 1224       // Save transaction id
// 1225       touchLinkLastAcceptedTransID = transID;
// 1226       osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TRANS_LIFETIME_EXPIRED_EVT,
// 1227                           BDBCTL_INTER_PAN_TRANS_ID_LIFETIME );
// 1228 
// 1229       pRsp->transID = transID;
// 1230       pRsp->rssiCorrection = TOUCHLINK_RSSI_CORRECTION;
// 1231       pRsp->zLogicalType = zgDeviceLogicalType;
// 1232       pRsp->touchLinkAddressAssignment = touchLink_IsValidSplitFreeRanges( 0 );
// 1233       pRsp->touchLinkInitiator = TRUE;
// 1234       pRsp->touchLinkProfileInterop = TRUE;
// 1235 
// 1236       if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
// 1237       {
// 1238         pRsp->zRxOnWhenIdle = TRUE;
// 1239       }
// 1240 
// 1241       pRsp->touchLinklinkPriority = FALSE;
// 1242       pRsp->keyBitmask = touchLink_GetNwkKeyBitmask();
// 1243 
// 1244       // Generate a new Response ID
// 1245       touchLinkResponseID = ( ((uint32)osal_rand()) << 16 ) + osal_rand();
// 1246       pRsp->responseID = touchLinkResponseID;
// 1247 
// 1248       pRsp->touchLinkFactoryNew = !bdbAttributes.bdbNodeIsOnANetwork;
// 1249       if ( pRsp->touchLinkFactoryNew )
// 1250       {
// 1251         pRsp->nwkAddr = 0xFFFF;
// 1252         pRsp->nwkUpdateId = 0;
// 1253       }
// 1254       else
// 1255       {
// 1256         pRsp->nwkAddr = _NIB.nwkDevAddress;
// 1257         pRsp->nwkUpdateId = _NIB.nwkUpdateId;
// 1258       }
// 1259       pRsp->PANID = _NIB.nwkPanId;
// 1260       pRsp->logicalChannel = _NIB.nwkLogicalChannel;
// 1261       osal_cpyExtAddr( pRsp->extendedPANID, _NIB.extendedPANID );
// 1262 
// 1263       pRsp->numSubDevices = touchLink_GetNumSubDevices( 0 );
// 1264       if ( pRsp->numSubDevices == 1 )
// 1265       {
// 1266         touchLink_GetSubDeviceInfo( 0, &(pRsp->deviceInfo) );
// 1267       }
// 1268 
// 1269       pRsp->totalGrpIDs = touchLink_GetNumGrpIDs();
// 1270 
// 1271       // Send a response back
// 1272       status = bdbTL_Send_ScanRsp( srcEP, dstAddr, pRsp, seqNum );
// 1273 
// 1274       osal_mem_free( pRsp );
// 1275     }
// 1276     else
// 1277     {
// 1278       status = ZMemError;
// 1279     }
// 1280   }
// 1281 
// 1282   return ( status );
// 1283 }
// 1284 
// 1285 /*********************************************************************
// 1286  * @fn      bdb_Initiator_SendNwkJoinReq
// 1287  *
// 1288  * @brief   Send out a Network Join Router or End Device Request command.
// 1289  *          using the selected Target.
// 1290  *
// 1291  * @param   -
// 1292  *
// 1293  * @return  ZStatus_t
// 1294  */
// 1295 ZStatus_t bdb_Initiator_SendNwkJoinReq( void )
// 1296 {
// 1297   // Set NWK task to idle
// 1298   nwk_setStateIdle( TRUE );
// 1299   return initiatorSendNwkJoinReq( &(selectedTarget.scanRsp) );
// 1300 }  
// 1301 
// 1302 #if (ZSTACK_ROUTER_BUILD)
// 1303 /*********************************************************************
// 1304  * @fn      touchLinkInitiator_PermitJoin
// 1305  *
// 1306  * @brief   Set the router permit join flag, to allow or deny classical
// 1307  *          commissioning by other ZigBee devices.
// 1308  *
// 1309  * @param   duration - enable up to aplcMaxPermitJoinDuration seconds,
// 1310  *                     0 to disable
// 1311  *
// 1312  * @return  status
// 1313  */
// 1314 ZStatus_t touchLinkInitiator_PermitJoin( uint8 duration )
// 1315 {
// 1316   return touchLink_PermitJoin( duration );
// 1317 }  
// 1318 #endif //(ZSTACK_ROUTER_BUILD)
// 1319 
// 1320 /*********************************************************************
// 1321  * LOCAL FUNCTIONS
// 1322  */
// 1323 
// 1324 /*********************************************************************
// 1325  * @fn      initiatorScanReqCB
// 1326  *
// 1327  * @brief   This callback is called to process a Scan Request command.
// 1328  *
// 1329  * @param   srcAddr - sender's address
// 1330  * @param   pReq - parsed command
// 1331  * @param   seqNum - command sequence number
// 1332  *
// 1333  * @return  ZStatus_t
// 1334  */
// 1335 static ZStatus_t initiatorScanReqCB( afAddrType_t *srcAddr, bdbTLScanReq_t *pReq, uint8 seqNum )
// 1336 {
// 1337   int8 rssi;
// 1338   rssi = touchLink_GetMsgRssi();
// 1339   if( ( rssi > TOUCHLINK_WORST_RSSI ) && ( pReq->touchLinkInitiator == TRUE ) )
// 1340   {
// 1341     // response to the originator, but switch to dst PAN 0xFFFF
// 1342     afAddrType_t dstAddr;
// 1343     osal_memcpy(&dstAddr, srcAddr, sizeof(afAddrType_t));
// 1344     dstAddr.panId = 0xFFFF;
// 1345 
// 1346     // If we are factory new and revice a Scan Request from other factory new
// 1347     // device then drop the request.
// 1348     if ( ( pReq->touchLinkFactoryNew == TRUE ) && ( bdbAttributes.bdbNodeIsOnANetwork == FALSE ) )
// 1349     {
// 1350       return ( ZSuccess );
// 1351     }
// 1352     // If, during its scan, a non factory new initiator receives another scan
// 1353     // request inter-PAN command frame from a factory new target, it shall be ignored.
// 1354     if ( ( pReq->touchLinkFactoryNew == TRUE ) && ( bdbAttributes.bdbNodeIsOnANetwork == TRUE ) &&
// 1355          osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT ) )
// 1356     {
// 1357       return ( ZSuccess );
// 1358     }
// 1359 
// 1360     // Send a Scan Response back
// 1361     if ( touchLink_InitiatorSendScanRsp( TOUCHLINK_INTERNAL_ENDPOINT, &dstAddr, pReq->transID, seqNum ) == ZSuccess )
// 1362     {
// 1363       // If we're a factory new initiator and are in the middle of a Device
// 1364       // Discovery, stop the procedure and wait for subsequent configuration
// 1365       // information from the non-factory new initiator that we just responded to.
// 1366       if ( ( bdbAttributes.bdbNodeIsOnANetwork == FALSE ) && !pReq->touchLinkFactoryNew )
// 1367       {
// 1368         osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT );
// 1369       }
// 1370     }
// 1371   }
// 1372 
// 1373   return ( ZSuccess );
// 1374 }
// 1375 
// 1376 /*********************************************************************
// 1377  * @fn      initiatorDeviceInfoReqCB
// 1378  *
// 1379  * @brief   This callback is called to process a Device Information
// 1380  *          Request command.
// 1381  *
// 1382  * @param   srcAddr - sender's address
// 1383  * @param   pReq - parsed command
// 1384  * @param   seqNum - command sequence number
// 1385  *
// 1386  * @return  ZStatus_t
// 1387  */
// 1388 static ZStatus_t initiatorDeviceInfoReqCB( afAddrType_t *srcAddr, bdbTLDeviceInfoReq_t *pReq, uint8 seqNum )
// 1389 {
// 1390   if ( touchLink_IsValidTransID( pReq->transID ) == FALSE )
// 1391   {
// 1392     return ( ZFailure );
// 1393   }
// 1394   return ( touchLink_SendDeviceInfoRsp( TOUCHLINK_INTERNAL_ENDPOINT, srcAddr,
// 1395                                   pReq->startIndex, pReq->transID, seqNum ) );
// 1396 }
// 1397 
// 1398 /*********************************************************************
// 1399  * @fn      initiatorIdentifyReqCB
// 1400  *
// 1401  * @brief   This callback is called to process an Identify Request command.
// 1402  *
// 1403  * @param   srcAddr - sender's address
// 1404  * @param   pReq - parsed command
// 1405  *
// 1406  * @return  ZStatus_t
// 1407  */
// 1408 static ZStatus_t initiatorIdentifyReqCB( afAddrType_t *srcAddr, bdbTLIdentifyReq_t *pReq )
// 1409 {
// 1410   if ( touchLink_IsValidTransID( pReq->transID ) == FALSE )
// 1411   {
// 1412     return ( ZFailure );
// 1413   }
// 1414 
// 1415   // The target should identify itself
// 1416   zclIdentify_t cmd;
// 1417   endPointDesc_t * bdb_CurrEpDescriptor;
// 1418   
// 1419   cmd.srcAddr = srcAddr;
// 1420 
// 1421   // Values of the Identify Duration field:
// 1422   // - Exit identify mode: 0x0000
// 1423   // - Length of time to remain in identify mode: 0x0001-0xfffe
// 1424   // - Remain in identify mode for a default time known by the receiver: 0xffff
// 1425   if ( pReq->IdDuration == 0xffff )
// 1426   {
// 1427     cmd.identifyTime = TOUCHLINK_DEFAULT_IDENTIFY_TIME;
// 1428   }
// 1429   else
// 1430   {
// 1431     cmd.identifyTime = pReq->IdDuration;
// 1432   }
// 1433 
// 1434   bdb_CurrEpDescriptor = bdb_setEpDescListToActiveEndpoint( );
// 1435   
// 1436   bdb_ZclIdentifyCmdInd( &cmd, bdb_CurrEpDescriptor->endPoint );
// 1437 
// 1438   return ( ZSuccess );
// 1439 }
// 1440 
// 1441 /*********************************************************************
// 1442  * @fn      initiatorNwkJoinReqCB
// 1443  *
// 1444  * @brief   This callback is called to process Network Join
// 1445  *          Request and Network Join End Device Request commands.
// 1446  *
// 1447  * @param   srcAddr - sender's address
// 1448  * @param   pReq - parsed command
// 1449  * @param   seqNum - command sequence number
// 1450  *
// 1451  * @return  ZStatus_t
// 1452  */
// 1453 static ZStatus_t initiatorNwkJoinReqCB( afAddrType_t *srcAddr, bdbTLNwkJoinReq_t *pReq, uint8 seqNum )
// 1454 {
// 1455   bdbTLNwkJoinRsp_t rsp;
// 1456   afAddrType_t dstAddr;
// 1457   nwk_states_t nwkState;
// 1458 
// 1459   if ( touchLink_IsValidTransID( pReq->transID ) == FALSE )
// 1460   {
// 1461     return ( ZFailure );
// 1462   }
// 1463 
// 1464   rsp.transID = pReq->transID;
// 1465 
// 1466   if ( nwk_ExtPANIDValid( pReq->nwkParams.extendedPANID ) )
// 1467     //NOTE: additional nwk params verification may be added here, e.g. ranges.
// 1468   {
// 1469 #if ( ZSTACK_ROUTER_BUILD )
// 1470     nwkState = NWK_ROUTER;
// 1471 #else
// 1472     // Save the request for later
// 1473     joinReq = *pReq;
// 1474     nwkState = NWK_ENDDEVICE;
// 1475 #endif
// 1476 
// 1477     // Notify our task to join the new network
// 1478     osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_NWK_JOIN_IND_EVT, BDBCTL_MIN_STARTUP_DELAY_TIME );
// 1479 
// 1480     osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_DISABLE_RX_EVT );
// 1481     osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT );
// 1482 
// 1483     rsp.status = TOUCHLINK_NETWORK_JOIN_RSP_STATUS_SUCCESS;
// 1484     
// 1485     bdb_setNodeIsOnANetwork(TRUE);
// 1486     
// 1487     // Apply the received network key
// 1488     touchLink_DecryptNwkKey( pReq->nwkParams.nwkKey, pReq->nwkParams.keyIndex, pReq->transID, touchLinkResponseID );
// 1489 
// 1490     // This is not a usual Trust Center protected network
// 1491     ZDSecMgrUpdateTCAddress( NULL );
// 1492     
// 1493     // Configure MAC with our network parameters
// 1494     NLME_InitNV();
// 1495     touchLink_SetNIB( nwkState, pReq->nwkParams.nwkAddr, pReq->nwkParams.extendedPANID,
// 1496                  _NIB.nwkLogicalChannel, pReq->nwkParams.panId, pReq->nwkParams.panId );
// 1497     
// 1498     touchLink_SetChannel( _NIB.nwkLogicalChannel );
// 1499     touchLink_SetMacNwkParams( _NIB.nwkDevAddress, _NIB.nwkPanId, _NIB.nwkLogicalChannel );
// 1500   }
// 1501   else
// 1502   {
// 1503     rsp.status = TOUCHLINK_NETWORK_JOIN_RSP_STATUS_FAILURE;
// 1504   }
// 1505 
// 1506   dstAddr = *srcAddr;
// 1507   dstAddr.panId = 0xFFFF;
// 1508 
// 1509   // Send a response back
// 1510 #if ( ZSTACK_ROUTER_BUILD )
// 1511   bdbTL_Send_NwkJoinRtrRsp( TOUCHLINK_INTERNAL_ENDPOINT, &dstAddr, &rsp, seqNum );
// 1512 #else
// 1513   bdbTL_Send_NwkJoinEDRsp( TOUCHLINK_INTERNAL_ENDPOINT, &dstAddr, &rsp, seqNum );
// 1514 #endif
// 1515 
// 1516   return ( ZSuccess );
// 1517 }
// 1518 
// 1519 /*********************************************************************
// 1520  * @fn      initiatorNwkUpdateReqCB
// 1521  *
// 1522  * @brief   This callback is called to process a Network Update Request
// 1523  *          command.
// 1524  *
// 1525  * @param   srcAddr - sender's address
// 1526  * @param   pReq - parsed command
// 1527  *
// 1528  * @return  ZStatus_t
// 1529  */
// 1530 static ZStatus_t initiatorNwkUpdateReqCB( afAddrType_t *srcAddr, bdbTLNwkUpdateReq_t *pReq )
// 1531 {
// 1532   if ( touchLink_IsValidTransID( pReq->transID ) == FALSE )
// 1533   {
// 1534     return ( ZFailure );
// 1535   }
// 1536   // Discard the request if the Extended PAN ID and PAN ID are not
// 1537   // identical with our corresponding stored values
// 1538   if ( TOUCHLINK_SAME_NWK( pReq->PANID, pReq->extendedPANID ) )
// 1539   {
// 1540     uint8 newUpdateId = touchLink_NewNwkUpdateId( pReq->nwkUpdateId, _NIB.nwkUpdateId);
// 1541     if ( _NIB.nwkUpdateId != newUpdateId )
// 1542     {
// 1543       // Update the network update id and logical channel
// 1544       touchLink_ProcessNwkUpdate( pReq->nwkUpdateId, pReq->logicalChannel );
// 1545     }
// 1546   }
// 1547 
// 1548   return ( ZSuccess );
// 1549 }
// 1550 
// 1551 /*********************************************************************
// 1552  * @fn      initiatorScanRspCB
// 1553  *
// 1554  * @brief   This callback is called to process a Scan Response command.
// 1555  *
// 1556  * @param   srcAddr - sender's address
// 1557  * @param   pRsp - parsed command
// 1558  *
// 1559  * @return  ZStatus_t
// 1560  */
// 1561 static ZStatus_t initiatorScanRspCB( afAddrType_t *srcAddr, bdbTLScanRsp_t *pRsp )
// 1562 {
// 1563   bdbFindingBindingRespondent_t *pCurr;
// 1564   
// 1565   if ( osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT )
// 1566        && ( touchLink_IsValidTransID( pRsp->transID ) )
// 1567        && ( pRsp->keyBitmask & touchLink_GetNwkKeyBitmask() ) )
// 1568   {
// 1569 
// 1570     uint8 selectThisTarget = FALSE;
// 1571     int8 rssi = touchLink_GetMsgRssi();
// 1572     if ( pfnSelectDiscDevCB != NULL )
// 1573     {
// 1574       selectThisTarget = pfnSelectDiscDevCB( pRsp, rssi );
// 1575     }
// 1576     // Default selection - according to RSSI
// 1577     else if ( rssi > TOUCHLINK_WORST_RSSI )
// 1578     {
// 1579       if ( ( rssi + pRsp->rssiCorrection ) > selectedTarget.lastRssi )
// 1580       {
// 1581         // Better RSSI, select this target
// 1582         selectThisTarget = TRUE;
// 1583       }
// 1584     }
// 1585 
// 1586     if ( selectThisTarget )
// 1587     {
// 1588       selectedTarget.scanRsp = *pRsp;
// 1589       selectedTarget.lastRssi = rssi;
// 1590       selectedTarget.srcAddr = *srcAddr;
// 1591       selectedTarget.srcAddr.panId = 0xFFFF;
// 1592       touchLinkResponseID = pRsp->responseID;
// 1593       touchLinkTransID = pRsp->transID;
// 1594 
// 1595       // Remember channel we heard back this scan response on
// 1596       ZMacGetReq( ZMacChannel, &(selectedTarget.rxChannel));
// 1597 
// 1598       if ( pRsp->numSubDevices > 1 )
// 1599       {
// 1600         selectedTarget.scanRsp.deviceInfo.endpoint = DEV_INFO_INVALID_EP;
// 1601 
// 1602         bdbTLDeviceInfoReq_t devInfoReq;
// 1603         devInfoReq.transID = pRsp->transID;
// 1604         devInfoReq.startIndex = 0;
// 1605 
// 1606         return bdbTL_Send_DeviceInfoReq( TOUCHLINK_INTERNAL_ENDPOINT, srcAddr,
// 1607                                     &devInfoReq, initiatorSeqNum++ );
// 1608       }
// 1609         
// 1610       // add new node to the list
// 1611       pCurr = bdb_AddRespondentNode( &pRespondentHead, NULL );
// 1612       
// 1613       if ( pCurr != NULL )
// 1614       {
// 1615         pCurr->data.endPoint = pRsp->deviceInfo.endpoint;
// 1616         pCurr->data.panId = srcAddr->panId;
// 1617       }
// 1618     }
// 1619     return ( ZSuccess );
// 1620   }
// 1621 
// 1622   return ( ZFailure );
// 1623 }
// 1624 
// 1625 /*********************************************************************
// 1626  * @fn      initiatorDeviceInfoRspCB
// 1627  *
// 1628  * @brief   This callback is called to process a Device Information
// 1629  *          Response command.
// 1630  *          If sub-device is selected, selectedTarget data is updated.
// 1631  *
// 1632  * @param   srcAddr - sender's address
// 1633  * @param   pRsp - parsed command
// 1634  *
// 1635  * @return  ZStatus_t
// 1636  */
// 1637 static ZStatus_t initiatorDeviceInfoRspCB( afAddrType_t *srcAddr, bdbTLDeviceInfoRsp_t *pRsp )
// 1638 {
// 1639   bdbFindingBindingRespondent_t *pCurr;
// 1640   
// 1641   if ( touchLink_IsValidTransID( pRsp->transID )
// 1642        && ( srcAddr->addr.shortAddr == selectedTarget.srcAddr.addr.shortAddr ) )
// 1643   {
// 1644     uint8 i;
// 1645     uint8 selectedIdx = pRsp->cnt;
// 1646     bdbTLScanRsp_t tmpInfo = selectedTarget.scanRsp;
// 1647 
// 1648     for ( i = 0; i < pRsp->cnt; ++i )
// 1649     {
// 1650       if ( pfnSelectDiscDevCB != NULL )
// 1651       {
// 1652         tmpInfo.deviceInfo = pRsp->devInfoRec[i].deviceInfo;
// 1653         if ( pfnSelectDiscDevCB( &tmpInfo, selectedTarget.lastRssi ) )
// 1654         {
// 1655           selectedIdx = i;
// 1656           // no break here to allow cycling through all sub-devices
// 1657         }
// 1658       }
// 1659       else
// 1660       {
// 1661         if ( ( pRsp->devInfoRec[i].deviceInfo.profileID == TOUCHLINK_PROFILE_ID ) ||
// 1662              ( pRsp->devInfoRec[i].deviceInfo.profileID == Z3_PROFILE_ID ) )
// 1663         {
// 1664           selectedIdx = i;
// 1665           break; // first match
// 1666         }
// 1667       }
// 1668     }
// 1669     if ( selectedIdx < pRsp->cnt )
// 1670     {
// 1671       // NOTE - the original scan response device info is overwritten with the
// 1672       // selected sub-device info, to complete the data required for the application.
// 1673       selectedTarget.scanRsp.deviceInfo = pRsp->devInfoRec[selectedIdx].deviceInfo;
// 1674       
// 1675       for ( i = 0; i < pRsp->cnt; ++i )
// 1676       {
// 1677         if ( ( pRsp->devInfoRec[i].deviceInfo.profileID == TOUCHLINK_PROFILE_ID ) ||
// 1678              ( pRsp->devInfoRec[i].deviceInfo.profileID == Z3_PROFILE_ID ) )
// 1679         {
// 1680           // add new node to the list
// 1681           pCurr = bdb_AddRespondentNode( &pRespondentHead, NULL );
// 1682           
// 1683           if ( pCurr != NULL )
// 1684           {
// 1685             pCurr->data.endPoint = pRsp->devInfoRec[i].deviceInfo.endpoint;
// 1686             pCurr->data.panId = srcAddr->panId;
// 1687           }
// 1688         }
// 1689       }
// 1690     }
// 1691     else
// 1692     {
// 1693       // no sub-device of the currently selected device was selected.
// 1694       // clear selection
// 1695       initiatorClearSelectedTarget();
// 1696       bdb_zclRespondentListClean( &pRespondentHead );
// 1697     }
// 1698     return ( ZSuccess );
// 1699   }
// 1700   return ( ZFailure );
// 1701 }
// 1702 
// 1703 /*********************************************************************
// 1704  * @fn      initiatorNwkStartRspCB
// 1705  *
// 1706  * @brief   This callback is called to process a Network Start Response command.
// 1707  *
// 1708  * @param   srcAddr - sender's address
// 1709  * @param   pRsp - parsed command
// 1710  *
// 1711  * @return  ZStatus_t
// 1712  */
// 1713 static ZStatus_t initiatorNwkStartRspCB( afAddrType_t *srcAddr, bdbTLNwkStartRsp_t *pRsp )
// 1714 {
// 1715   if ( touchLink_IsValidTransID( pRsp->transID ) == FALSE )
// 1716   {
// 1717     return ( ZFailure );
// 1718   }
// 1719   // Make sure we didn't timeout waiting for this response
// 1720   if ( osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_START_RSP_EVT ) )
// 1721   {
// 1722     // Save the Network Start Response for later
// 1723     rxRsp.nwkStartRsp = *pRsp;
// 1724 
// 1725     // No need to wait longer
// 1726     osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_START_RSP_EVT, 0 );  
// 1727   }
// 1728 
// 1729   return ( ZSuccess );
// 1730 }
// 1731 
// 1732 /*********************************************************************
// 1733  * @fn      initiatorNwkJoinRtrRspCB
// 1734  *
// 1735  * @brief   This callback is called to process a Network Join Router
// 1736  *          Response command.
// 1737  *
// 1738  * @param   srcAddr - sender's address
// 1739  * @param   pRsp - parsed command
// 1740  *
// 1741  * @return  ZStatus_t
// 1742  */
// 1743 static ZStatus_t initiatorNwkJoinRtrRspCB( afAddrType_t *srcAddr, bdbTLNwkJoinRsp_t *pRsp )
// 1744 {
// 1745   if ( ( touchLink_IsValidTransID( pRsp->transID ) == FALSE ) || 
// 1746      ( ( srcAddr->addrMode != afAddr64Bit ) || ( !osal_memcmp( selectedTarget.srcAddr.addr.extAddr, srcAddr->addr.extAddr, Z_EXTADDR_LEN ) ) ) )
// 1747   {
// 1748     return ( ZFailure );
// 1749   }
// 1750   
// 1751   // Make sure we didn't timeout waiting for this response
// 1752   if ( osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT ) )
// 1753   {
// 1754     // Save the Network Start Response for later
// 1755     rxRsp.nwkJoinRsp = *pRsp;
// 1756 
// 1757     // No need to wait longer
// 1758     osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT, 0 );
// 1759   }
// 1760 
// 1761   return ( ZSuccess );
// 1762 }
// 1763 
// 1764 /*********************************************************************
// 1765  * @fn      initiatorNwkJoinEDRspCB
// 1766  *
// 1767  * @brief   This callback is called to process a Network Join End Device
// 1768  *          Response command.
// 1769  *
// 1770  * @param   srcAddr - sender's address
// 1771  * @param   pRsp - parsed command
// 1772  *
// 1773  * @return  ZStatus_t
// 1774  */
// 1775 static ZStatus_t initiatorNwkJoinEDRspCB( afAddrType_t *srcAddr, bdbTLNwkJoinRsp_t *pRsp )
// 1776 {
// 1777   if ( ( touchLink_IsValidTransID( pRsp->transID ) == FALSE ) || 
// 1778      ( ( srcAddr->addrMode != afAddr64Bit ) || ( !osal_memcmp( selectedTarget.srcAddr.addr.extAddr, srcAddr->addr.extAddr, Z_EXTADDR_LEN ) ) ) )
// 1779   {
// 1780     return ( ZFailure );
// 1781   }
// 1782   
// 1783   // Make sure we didn't timeout waiting for this response
// 1784   if ( osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT ) )
// 1785   {
// 1786     // Save the Network Start Response for later
// 1787     rxRsp.nwkJoinRsp = *pRsp;
// 1788 
// 1789     // No need to wait longer
// 1790     osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT, 0 );
// 1791 
// 1792   }
// 1793   else
// 1794   {
// 1795     rxRsp.nwkJoinRsp.status = TOUCHLINK_NETWORK_JOIN_RSP_STATUS_FAILURE;
// 1796   }
// 1797 
// 1798   return ( ZSuccess );
// 1799 }
// 1800 
// 1801 /******************************************************************************
// 1802  * @fn      initiatorZdoLeaveCnfCB
// 1803  *
// 1804  * @brief   This callback is called to process a Leave Confirmation message.
// 1805  *
// 1806  *          Note: this callback function returns a pointer if it has handled
// 1807  *                the confirmation message and no further action should be
// 1808  *                taken with it. It returns NULL if it has not handled the
// 1809  *                confirmation message and normal processing should take place.
// 1810  *
// 1811  * @param   pParam - received message
// 1812  *
// 1813  * @return  Pointer if message processed. NULL, otherwise.
// 1814  */
// 1815 static void *initiatorZdoLeaveCnfCB( void *pParam )
// 1816 {
// 1817   (void)pParam;
// 1818 
// 1819   // Did we initiate the leave?
// 1820   if ( touchLinkLeaveInitiated == FALSE )
// 1821   {
// 1822     return ( NULL );
// 1823   }
// 1824 
// 1825   if ( touchLinkLeaveInitiated == TOUCHLINK_LEAVE_TO_JOIN_NWK )
// 1826   {
// 1827     // Notify our task to join the new network
// 1828     osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_JOIN_NWK_ATTEMPT_EVT );
// 1829   }
// 1830 
// 1831   return ( (void *)&touchLinkLeaveInitiated );
// 1832 }
// 1833 
// 1834 /*********************************************************************
// 1835  * @fn      initiatorProcessStateChange
// 1836  *
// 1837  * @brief   Process ZDO device state change
// 1838  *
// 1839  * @param   state - The device's network state
// 1840  *
// 1841  * @return  none
// 1842  */
// 1843 static void initiatorProcessStateChange( devStates_t state )
// 1844 {
// 1845   if ( ( state == DEV_ROUTER ) || ( state == DEV_END_DEVICE ) )
// 1846   {
// 1847     // Save the latest NIB to update our parent's address
// 1848     touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_NIB );
// 1849    
// 1850     if ( !_NIB.CapabilityFlags )
// 1851     {
// 1852       _NIB.CapabilityFlags = ZDO_Config_Node_Descriptor.CapabilityFlags;
// 1853     }
// 1854 
// 1855     if ( ZSTACK_ROUTER_BUILD )
// 1856     {
// 1857       ZDP_DeviceAnnce( NLME_GetShortAddr(), NLME_GetExtAddr(),
// 1858                        ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
// 1859       
// 1860       bdb_setNodeIsOnANetwork(TRUE);
// 1861       osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_NWK_FORMATION_SUCCESS_EVT, 500);
// 1862     }
// 1863 
// 1864     // We found our parent
// 1865     osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_REJOIN_EVT );
// 1866   }
// 1867   
// 1868   else if ( ( state == DEV_NWK_ORPHAN ) || ( state == DEV_NWK_DISC ) )
// 1869   {
// 1870     // Device has lost information about its parent; give it some time to rejoin
// 1871     if ( !osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_REJOIN_EVT ) )
// 1872     {
// 1873       osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_REJOIN_EVT,
// 1874                           (NUM_DISC_ATTEMPTS + 1) * TOUCHLINK_INITIATOR_REJOIN_TIMEOUT );
// 1875     }
// 1876   }
// 1877 }
// 1878 
// 1879 /*********************************************************************
// 1880  * @fn      initiatorSetNwkToInitState
// 1881  *
// 1882  * @brief   Set our network state to its original state.
// 1883  *
// 1884  * @param   void
// 1885  *
// 1886  * @return  void
// 1887  */
// 1888 static void initiatorSetNwkToInitState()
// 1889 {
// 1890   // Turn MAC receiver back to its old state
// 1891   ZMacSetReq( ZMacRxOnIdle, &savedRxOnIdle );
// 1892 
// 1893   // Tune back to our channel
// 1894   touchLink_SetChannel( _NIB.nwkLogicalChannel );
// 1895 
// 1896   // Set NWK task to run
// 1897   nwk_setStateIdle( FALSE );
// 1898 
// 1899   if ( savedPollRate != zgPollRate )
// 1900   {
// 1901     NLME_SetPollRate( savedPollRate );
// 1902     savedPollRate = POLL_RATE;
// 1903   }
// 1904 
// 1905   if ( savedQueuedPollRate != zgQueuedPollRate )
// 1906   {
// 1907     NLME_SetQueuedPollRate( savedQueuedPollRate );
// 1908     savedQueuedPollRate = QUEUED_POLL_RATE;
// 1909   }
// 1910 
// 1911   if ( savedResponsePollRate != zgResponsePollRate )
// 1912   {
// 1913     NLME_SetResponseRate( savedResponsePollRate );
// 1914     savedResponsePollRate = RESPONSE_POLL_RATE;
// 1915   }
// 1916 }
// 1917 
// 1918 #if ( ZSTACK_ROUTER_BUILD )
// 1919 /*********************************************************************
// 1920  * @fn      initiatorJoinNwk
// 1921  *
// 1922  * @brief   Initiate a network join request.
// 1923  *
// 1924  * @param   void
// 1925  *
// 1926  * @return  void
// 1927  */
// 1928 static void initiatorJoinNwk( void )
// 1929 {
// 1930   // Save free ranges
// 1931   touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
// 1932 
// 1933   // In case we're here after a leave
// 1934   touchLinkLeaveInitiated = FALSE;
// 1935 
// 1936   // Clear leave control logic
// 1937   ZDApp_LeaveCtrlReset();
// 1938 
// 1939   if ( POLL_RATE == 0 )
// 1940   {
// 1941     //allow to respond to TOUCHLINK commission utility commands after TL
// 1942     NLME_SetPollRate( TOUCHLINK_INITIATOR_TEMP_POST_TL_POLL_RATE );
// 1943     //polling should reset when TL life time expires
// 1944   }
// 1945 
// 1946   touchLinkInitiator_PermitJoin( 0 );
// 1947 
// 1948   ZDOInitDevice( 0 );
// 1949   // Perform a network rejoin request
// 1950   _NIB.nwkState = NWK_REJOINING;
// 1951   initiatorReJoinNwk( MODE_REJOIN );
// 1952 }
// 1953 #endif
// 1954 
// 1955 /*********************************************************************
// 1956  * @fn      initiatorReJoinNwk
// 1957  *
// 1958  * @brief   Send out an Rejoin Request.
// 1959  *
// 1960  * @param   startMode - MODE_REJOIN or MODE_RESUME
// 1961  *
// 1962  * @return  none
// 1963  */
// 1964 static void initiatorReJoinNwk( devStartModes_t startMode )
// 1965 {
// 1966   // Set NWK task to run
// 1967   nwk_setStateIdle( FALSE );
// 1968 
// 1969   // Configure MAC with our network parameters
// 1970   touchLink_SetMacNwkParams( _NIB.nwkDevAddress, _NIB.nwkPanId, _NIB.nwkLogicalChannel );
// 1971 
// 1972   // Use the new network paramters
// 1973   zgConfigPANID = _NIB.nwkPanId;
// 1974   zgDefaultChannelList = _NIB.channelList;
// 1975   osal_cpyExtAddr( ZDO_UseExtendedPANID, _NIB.extendedPANID );
// 1976 
// 1977   devStartMode = startMode;
// 1978 
// 1979   _tmpRejoinState = TRUE;
// 1980 
// 1981   // Start the network joining process
// 1982   osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
// 1983 }
// 1984 
// 1985 /*********************************************************************
// 1986  * @fn      initiatorSendScanReq
// 1987  *
// 1988  * @brief   Send out an Scan Request command on one of the TOUCHLINK channels.
// 1989  *
// 1990  * @param   freshScan - TRUE to start fresh scan, FALSE to resume existing process.
// 1991  *
// 1992  * @return  void
// 1993  */
// 1994 static void initiatorSendScanReq( bool freshScan )
// 1995 {
// 1996   bdbTLScanReq_t req;
// 1997   uint8 newChannel;
// 1998   uint8 secondaryChList[] = TOUCHLINK_SECONDARY_CHANNELS_SET;
// 1999   static uint8 channelIndex = 0;
// 2000   
// 2001   // Set the device as initiator of touchlink commissioning
// 2002   touchLink_DeviceIsInitiator( TRUE );
// 2003 
// 2004   if ( freshScan )
// 2005   {
// 2006     channelIndex = 0;
// 2007   }
// 2008 
// 2009   // First figure out the channel
// 2010   if ( scanReqChannels == TOUCHLINK_SCAN_PRIMARY_CHANNELS )
// 2011   {
// 2012     if ( numScanReqSent < 5 )
// 2013     {
// 2014       // First five consecutive requests are sent on channel 11
// 2015       newChannel = TOUCHLINK_FIRST_CHANNEL;
// 2016     }
// 2017     else if ( numScanReqSent == 5 )
// 2018     {
// 2019       // Sixth request is sent on channel 15
// 2020       newChannel = TOUCHLINK_SECOND_CHANNEL;
// 2021     }
// 2022     else if ( numScanReqSent == 6 )
// 2023     {
// 2024       // Seventh request is sent on channel 20
// 2025       newChannel = TOUCHLINK_THIRD_CHANNEL;
// 2026     }
// 2027     else
// 2028     {
// 2029       // Last request is sent on channel 25
// 2030       newChannel = TOUCHLINK_FOURTH_CHANNEL;
// 2031     }
// 2032   }
// 2033   else
// 2034   {
// 2035     // scan secondary channel list
// 2036     if ( channelIndex < sizeof(secondaryChList) )
// 2037     {
// 2038        newChannel = secondaryChList[channelIndex++];
// 2039     }
// 2040     else
// 2041     {
// 2042       // set it to initial value for next discovery process
// 2043       channelIndex = 0;
// 2044       return;
// 2045     }
// 2046   }
// 2047 
// 2048   if ( touchLinkTransID != 0 )
// 2049   {
// 2050     // Build the request
// 2051     req.transID = touchLinkTransID;
// 2052     touchLinkLastAcceptedTransID = touchLinkTransID;
// 2053 
// 2054     req.zInfo.zInfoByte = 0;
// 2055     req.zLogicalType = zgDeviceLogicalType;
// 2056     if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
// 2057     {
// 2058       req.zRxOnWhenIdle = TRUE;
// 2059     }
// 2060 
// 2061     req.touchLinkInfo.touchLinkInfoByte = 0;
// 2062     req.touchLinkFactoryNew = !bdbAttributes.bdbNodeIsOnANetwork;
// 2063     req.touchLinkAddressAssignment = TRUE;
// 2064     req.touchLinkInitiator = TRUE;
// 2065 
// 2066     // First switch to the right channel
// 2067     touchLink_SetChannel( newChannel );
// 2068 
// 2069     // Broadcast the request
// 2070     bdbTL_Send_ScanReq( TOUCHLINK_INTERNAL_ENDPOINT, &bcastAddr, &req, initiatorSeqNum++ );
// 2071 
// 2072     numScanReqSent++;
// 2073 
// 2074     // After each transmission, wait BDBCTL_SCAN_TIME_BASE_DURATION seconds
// 2075     // to receive any responses.
// 2076     osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT, BDBCTL_SCAN_TIME_BASE_DURATION );
// 2077   }
// 2078   else
// 2079   {
// 2080     touchLinkInitiator_AbortTL();
// 2081   }
// 2082 }
// 2083 
// 2084 /*********************************************************************
// 2085  * @fn      initiatorSendNwkStartReq
// 2086  *
// 2087  * @brief   Send out a Network Start Request command.
// 2088  *
// 2089  * @param   pRsp - received Scan Response
// 2090  *
// 2091  * @return  ZStatus_t
// 2092  */
// 2093 static ZStatus_t initiatorSendNwkStartReq( bdbTLScanRsp_t *pRsp )
// 2094 {
// 2095   bdbTLNwkStartReq_t *pReq;
// 2096   ZStatus_t status;
// 2097 
// 2098   pReq = (bdbTLNwkStartReq_t *)osal_mem_alloc( sizeof( bdbTLNwkStartReq_t ) );
// 2099   if ( pReq != NULL )
// 2100   {
// 2101     uint16 i;
// 2102     bdbTLNwkParams_t *pParams = &(pReq->nwkParams);
// 2103 
// 2104     osal_memset( pReq, 0, sizeof( bdbTLNwkStartReq_t ) );
// 2105 
// 2106     // Build the request
// 2107     pReq->transID = selectedTarget.scanRsp.transID;
// 2108 
// 2109     // Find out key index (prefer highest)
// 2110     for ( i = 15; i > 0; i-- )
// 2111     {
// 2112       if ( ( (uint16)1 << i ) & pRsp->keyBitmask )
// 2113       {
// 2114         break;
// 2115       }
// 2116     }
// 2117     pParams->keyIndex = i;
// 2118 
// 2119     // Copy in the encrypted network key
// 2120     touchLink_EncryptNwkKey( pParams->nwkKey, i, pRsp->transID, pRsp->responseID );
// 2121 
// 2122     pParams->nwkAddr = touchLink_PopNwkAddress();
// 2123     if ( pParams->nwkAddr == 0 )
// 2124     {
// 2125       pParams->nwkAddr = osal_rand();
// 2126     }
// 2127     // update address for app notification
// 2128     selectedTarget.newNwkAddr = pParams->nwkAddr;
// 2129     selectedTargetNwkAddr = pParams->nwkAddr;
// 2130 
// 2131     // Set group ID range
// 2132     if ( pRsp->totalGrpIDs > 0 )
// 2133     {
// 2134       touchLink_PopGrpIDRange( pRsp->totalGrpIDs, &(pParams->grpIDsBegin), &(pParams->grpIDsEnd) );
// 2135     }
// 2136 
// 2137     if ( pRsp->touchLinkAddressAssignment )
// 2138     {
// 2139       touchLink_SplitFreeRanges( &(pParams->freeNwkAddrBegin), &(pParams->freeNwkAddrEnd),
// 2140                            &(pParams->freeGrpIDBegin), &(pParams->freeGrpIDEnd) );
// 2141     }
// 2142 
// 2143 #ifdef TOUCHLINK_INITIATOR_SET_NEW_NWK_PARAMS
// 2144     pParams->logicalChannel = _NIB.nwkLogicalChannel;
// 2145     pParams->panId = _NIB.nwkPanId;
// 2146     osal_memcpy( pParams->extendedPANID, _NIB.extendedPANID ,Z_EXTADDR_LEN);
// 2147 #endif
// 2148 
// 2149     osal_cpyExtAddr( pReq->initiatorIeeeAddr, NLME_GetExtAddr() );
// 2150     pReq->initiatorNwkAddr = _NIB.nwkDevAddress;
// 2151 
// 2152     status = bdbTL_Send_NwkStartReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), pReq, initiatorSeqNum++ );
// 2153     if ( status == ZSuccess )
// 2154     {
// 2155       // Keep a copy of the encryted network key sent to the target
// 2156       keyIndexSent = i;
// 2157       osal_memcpy( encKeySent, pParams->nwkKey, SEC_KEY_LEN );
// 2158       responseIDSent = pRsp->responseID;
// 2159 
// 2160       // After the transmission, wait BDBCTL_RX_WINDOW_DURATION seconds to
// 2161       // receive a response.
// 2162       osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_START_RSP_EVT, BDBCTL_RX_WINDOW_DURATION );
// 2163     }
// 2164 
// 2165     osal_mem_free( pReq );
// 2166   }
// 2167   else
// 2168   {
// 2169     status = ZMemError;
// 2170   }
// 2171 
// 2172   return ( status );
// 2173 }
// 2174 
// 2175 /*********************************************************************
// 2176  * @fn      initiatorSendNwkJoinReq
// 2177  *
// 2178  * @brief   Send out a Network Join Router or End Device Request command.
// 2179  *
// 2180  * @param   pRsp - received Scan Response
// 2181  *
// 2182  * @return  ZStatus_t
// 2183  */
// 2184 static ZStatus_t initiatorSendNwkJoinReq( bdbTLScanRsp_t *pRsp )
// 2185 {
// 2186   bdbTLNwkJoinReq_t *pReq;
// 2187   ZStatus_t status;
// 2188   bdbFindingBindingRespondent_t *pCurr;
// 2189 
// 2190   pReq = (bdbTLNwkJoinReq_t *)osal_mem_alloc( sizeof( bdbTLNwkJoinReq_t ) );
// 2191   if ( pReq != NULL )
// 2192   {
// 2193     uint16 i;
// 2194     bdbTLNwkParams_t *pParams = &(pReq->nwkParams);
// 2195 
// 2196     osal_memset( pReq, 0, sizeof( bdbTLNwkJoinReq_t ) );
// 2197 
// 2198     // Build the request
// 2199     pReq->transID = selectedTarget.scanRsp.transID;
// 2200 
// 2201     // Find out key index (prefer highest)
// 2202     for ( i = 15; i > 0; i-- )
// 2203     {
// 2204       if ( ( (uint16)1 << i ) & pRsp->keyBitmask )
// 2205       {
// 2206         break;
// 2207       }
// 2208     }
// 2209     pParams->keyIndex = i;
// 2210 
// 2211     // Copy in the encrypted network key
// 2212     touchLink_EncryptNwkKey( pParams->nwkKey, i, pRsp->transID, pRsp->responseID );
// 2213 
// 2214     pParams->nwkAddr = touchLink_PopNwkAddress();
// 2215     if ( pParams->nwkAddr == 0 )
// 2216     {
// 2217       pParams->nwkAddr = osal_rand();
// 2218     }
// 2219     // update address for app notification
// 2220     selectedTarget.newNwkAddr = pParams->nwkAddr;
// 2221     selectedTargetNwkAddr = pParams->nwkAddr;
// 2222     
// 2223     // Set group ID range
// 2224     if ( pRsp->totalGrpIDs > 0 )
// 2225     {
// 2226       touchLink_PopGrpIDRange( pRsp->totalGrpIDs, &(pParams->grpIDsBegin), &(pParams->grpIDsEnd) );
// 2227     }
// 2228 
// 2229     if ( pRsp->touchLinkAddressAssignment )
// 2230     {
// 2231       touchLink_SplitFreeRanges( &(pParams->freeNwkAddrBegin), &(pParams->freeNwkAddrEnd),
// 2232                            &(pParams->freeGrpIDBegin), &(pParams->freeGrpIDEnd) );
// 2233     }
// 2234     // update 
// 2235     pCurr = pRespondentHead;
// 2236     while( pCurr != NULL )
// 2237     {
// 2238       pCurr->data.addr.shortAddr = pParams->nwkAddr;
// 2239       pCurr->data.addrMode = afAddr16Bit;
// 2240       pCurr->data.panId = _NIB.nwkPanId;
// 2241       pCurr = pCurr->pNext;
// 2242     }
// 2243 
// 2244     pParams->logicalChannel = _NIB.nwkLogicalChannel;
// 2245     pParams->panId = _NIB.nwkPanId;
// 2246     osal_cpyExtAddr( pParams->extendedPANID, _NIB.extendedPANID );
// 2247     pReq->nwkUpdateId = _NIB.nwkUpdateId;
// 2248 
// 2249     // Let PAN ID, Extended PAN ID and Logical Channel to be determined by the target
// 2250     if ( pRsp->zLogicalType == ZG_DEVICETYPE_ROUTER )
// 2251     {
// 2252       // It's a light
// 2253       status = bdbTL_Send_NwkJoinRtrReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), pReq, initiatorSeqNum++ );
// 2254     }
// 2255     else // another controller
// 2256     {
// 2257       status = bdbTL_Send_NwkJoinEDReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), pReq, initiatorSeqNum++ );
// 2258     }
// 2259 
// 2260     if ( status == ZSuccess )
// 2261     {
// 2262       // After the transmission, wait BDBCTL_RX_WINDOW_DURATION seconds to
// 2263       // receive a response.
// 2264       osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT, BDBCTL_RX_WINDOW_DURATION );
// 2265     }
// 2266 
// 2267     osal_mem_free( pReq );
// 2268   }
// 2269   else
// 2270   {
// 2271     status = ZMemError;
// 2272   }
// 2273 
// 2274   return ( status );
// 2275 }
// 2276 
// 2277 /*********************************************************************
// 2278  * @fn      initiatorSendNwkUpdateReq
// 2279  *
// 2280  * @brief   Send out a Network Update Request command.
// 2281  *
// 2282  * @param   pRsp - received Scan Response
// 2283  *
// 2284  * @return  ZStatus_t
// 2285  */
// 2286 static ZStatus_t initiatorSendNwkUpdateReq( bdbTLScanRsp_t *pRsp )
// 2287 {
// 2288   bdbTLNwkUpdateReq_t *pReq;
// 2289   ZStatus_t status;
// 2290 
// 2291   pReq = (bdbTLNwkUpdateReq_t *)osal_mem_alloc( sizeof( bdbTLNwkUpdateReq_t ) );
// 2292   if ( pReq!= NULL )
// 2293   {
// 2294     // Build the request
// 2295     pReq->transID = pRsp->transID;
// 2296     osal_cpyExtAddr( pReq->extendedPANID, _NIB.extendedPANID );
// 2297     pReq->nwkUpdateId = _NIB.nwkUpdateId;
// 2298     pReq->logicalChannel = _NIB.nwkLogicalChannel;
// 2299     pReq->PANID = _NIB.nwkPanId;
// 2300     pReq->nwkAddr = pRsp->nwkAddr;
// 2301 
// 2302     status = bdbTL_Send_NwkUpdateReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), pReq, initiatorSeqNum++ );
// 2303 
// 2304     osal_mem_free( pReq );
// 2305   }
// 2306   else
// 2307   {
// 2308     status = ZMemError;
// 2309   }
// 2310 
// 2311   return ( status );
// 2312 }
// 2313 
// 2314 /*********************************************************************
// 2315  * @fn      initiatorClearSelectedTarget
// 2316  *
// 2317  * @brief   clear selected target variable.
// 2318  *
// 2319  * @param   none
// 2320  *
// 2321  * @return  none
// 2322  */
// 2323 static void initiatorClearSelectedTarget( void )
// 2324 {
// 2325   osal_memset( &selectedTarget, 0x00, sizeof(targetCandidate_t) );
// 2326   selectedTarget.lastRssi = TOUCHLINK_WORST_RSSI;
// 2327 }
// 2328 
// 2329 #endif //BDB_TL_INITIATOR
// 2330 
// 2331 /*********************************************************************
// 2332 *********************************************************************/
// 
//
// 
//
//
//Errors: none
//Warnings: none
